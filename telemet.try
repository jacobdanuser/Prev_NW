diff --git a/telemetry_restriction.py b/telemetry_restriction.py
new file mode 100644
index 0000000000000000000000000000000000000000..6ba644bd364773ca5280ff0edaef97ee6c883684
--- /dev/null
+++ b/telemetry_restriction.py
@@ -0,0 +1,162 @@
+#!/usr/bin/env python3
+"""Process-scoped telemetry restriction utility.
+
+This tool applies a conservative, reversible policy to reduce telemetry for the
+current Python process (and optionally a spawned subprocess).
+
+It does NOT attempt to break or interfere with system-wide software.
+"""
+
+from __future__ import annotations
+
+import argparse
+import os
+import socket
+import subprocess
+import sys
+from dataclasses import dataclass, field
+from typing import Iterable
+
+
+DEFAULT_BLOCKED_HOSTS = {
+    "telemetry.microsoft.com",
+    "vortex.data.microsoft.com",
+    "settings-win.data.microsoft.com",
+    "app-measurement.com",
+    "google-analytics.com",
+    "www.google-analytics.com",
+    "ssl.google-analytics.com",
+    "api.segment.io",
+    "cdn.segment.com",
+    "sentry.io",
+    "o447951.ingest.sentry.io",
+}
+
+DEFAULT_ENV_UPDATES = {
+    "DO_NOT_TRACK": "1",
+    "OTEL_SDK_DISABLED": "true",
+    "SCARF_NO_ANALYTICS": "true",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "DOTNET_CLI_TELEMETRY_OPTOUT": "1",
+    "POWERSHELL_TELEMETRY_OPTOUT": "1",
+    "GATSBY_TELEMETRY_DISABLED": "1",
+    "NEXT_TELEMETRY_DISABLED": "1",
+}
+
+
+@dataclass
+class TelemetryPolicy:
+    blocked_hosts: set[str] = field(default_factory=lambda: set(DEFAULT_BLOCKED_HOSTS))
+    env_updates: dict[str, str] = field(default_factory=lambda: dict(DEFAULT_ENV_UPDATES))
+    _original_getaddrinfo: object | None = None
+
+    def apply_env(self) -> None:
+        for key, value in self.env_updates.items():
+            os.environ[key] = value
+
+    def apply_socket_guard(self) -> None:
+        if self._original_getaddrinfo is not None:
+            return
+
+        original = socket.getaddrinfo
+        blocked = {h.lower() for h in self.blocked_hosts}
+
+        def guarded_getaddrinfo(host: str, *args, **kwargs):
+            host_text = (host or "").lower()
+            if any(blocked_host in host_text for blocked_host in blocked):
+                raise OSError(f"Blocked telemetry endpoint: {host}")
+            return original(host, *args, **kwargs)
+
+        self._original_getaddrinfo = original
+        socket.getaddrinfo = guarded_getaddrinfo
+
+    def restore_socket_guard(self) -> None:
+        if self._original_getaddrinfo is not None:
+            socket.getaddrinfo = self._original_getaddrinfo
+            self._original_getaddrinfo = None
+
+
+def parse_args(argv: Iterable[str]) -> argparse.Namespace:
+    parser = argparse.ArgumentParser(
+        description="Apply process-level telemetry restrictions."
+    )
+    parser.add_argument(
+        "--block-host",
+        action="append",
+        default=[],
+        help="Additional host substring to block (repeatable).",
+    )
+    parser.add_argument(
+        "--set-env",
+        action="append",
+        default=[],
+        metavar="KEY=VALUE",
+        help="Extra environment variable override.",
+    )
+    parser.add_argument(
+        "--print-policy",
+        action="store_true",
+        help="Print the effective policy and exit.",
+    )
+    parser.add_argument(
+        "command",
+        nargs=argparse.REMAINDER,
+        help="Optional command to run with restricted telemetry (prefix with --).",
+    )
+    return parser.parse_args(list(argv))
+
+
+def parse_env_overrides(pairs: Iterable[str]) -> dict[str, str]:
+    overrides: dict[str, str] = {}
+    for item in pairs:
+        if "=" not in item:
+            raise ValueError(f"Invalid --set-env value: {item!r}; expected KEY=VALUE")
+        key, value = item.split("=", 1)
+        key = key.strip()
+        if not key:
+            raise ValueError(f"Invalid env key in --set-env value: {item!r}")
+        overrides[key] = value
+    return overrides
+
+
+def run() -> int:
+    args = parse_args(sys.argv[1:])
+
+    policy = TelemetryPolicy()
+    policy.blocked_hosts.update(h.lower() for h in args.block_host)
+    policy.env_updates.update(parse_env_overrides(args.set_env))
+
+    if args.print_policy:
+        print("Telemetry policy:")
+        print("  Environment overrides:")
+        for key in sorted(policy.env_updates):
+            print(f"    {key}={policy.env_updates[key]}")
+        print("  Blocked hosts:")
+        for host in sorted(policy.blocked_hosts):
+            print(f"    {host}")
+        return 0
+
+    policy.apply_env()
+    policy.apply_socket_guard()
+
+    command = args.command
+    if command and command[0] == "--":
+        command = command[1:]
+
+    if not command:
+        print("Telemetry restrictions applied to current process.")
+        print("Tip: pass a command after '--' to run a subprocess with these restrictions.")
+        return 0
+
+    try:
+        completed = subprocess.run(command, env=os.environ.copy(), check=False)
+        return completed.returncode
+    finally:
+        policy.restore_socket_guard()
+
+
+if __name__ == "__main__":
+    raise SystemExit(run())
diff --git a/telemetry_restriction.py b/telemetry_restriction.py
new file mode 100644
index 0000000000000000000000000000000000000000..461eb4745145cf3cf16e6e9662c796a5973c1988
--- /dev/null
+++ b/telemetry_restriction.py
@@ -0,0 +1,152 @@
+"""Utilities for strictly controlling telemetry in a safe, opt-in way.
+
+This module is intentionally defensive: it helps applications disable or
+sanitize telemetry output without harming unrelated programs or the system.
+"""
+
+from __future__ import annotations
+
+import json
+import os
+from dataclasses import dataclass, field
+from pathlib import Path
+from typing import Dict, Mapping, Optional
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Policy describing how telemetry should be handled.
+
+    Attributes:
+        enabled: Global on/off switch for telemetry.
+        blocked_events: Event names that must never be emitted.
+        redacted_keys: Payload keys whose values are replaced by "[REDACTED]".
+        max_payload_bytes: Optional payload size cap.
+    """
+
+    enabled: bool = False
+    blocked_events: frozenset[str] = field(default_factory=frozenset)
+    redacted_keys: frozenset[str] = field(
+        default_factory=lambda: frozenset(
+            {
+                "email",
+                "password",
+                "token",
+                "access_token",
+                "refresh_token",
+                "ssn",
+                "phone",
+            }
+        )
+    )
+    max_payload_bytes: Optional[int] = 8_192
+
+    @staticmethod
+    def from_env(prefix: str = "TELEMETRY") -> "TelemetryPolicy":
+        """Build policy from environment variables.
+
+        Supported variables:
+          - <prefix>_ENABLED (0/1, true/false)
+          - <prefix>_BLOCKED_EVENTS (comma-separated)
+          - <prefix>_REDACTED_KEYS (comma-separated)
+          - <prefix>_MAX_PAYLOAD_BYTES (int)
+        """
+
+        def parse_bool(value: str, default: bool) -> bool:
+            if value is None:
+                return default
+            return value.strip().lower() in {"1", "true", "yes", "on"}
+
+        enabled = parse_bool(os.getenv(f"{prefix}_ENABLED"), False)
+
+        blocked_raw = os.getenv(f"{prefix}_BLOCKED_EVENTS", "")
+        blocked_events = frozenset(
+            x.strip() for x in blocked_raw.split(",") if x.strip()
+        )
+
+        redacted_raw = os.getenv(f"{prefix}_REDACTED_KEYS", "")
+        redacted = frozenset(
+            x.strip() for x in redacted_raw.split(",") if x.strip()
+        )
+
+        max_size_raw = os.getenv(f"{prefix}_MAX_PAYLOAD_BYTES")
+        max_payload_bytes = int(max_size_raw) if max_size_raw else 8_192
+
+        return TelemetryPolicy(
+            enabled=enabled,
+            blocked_events=blocked_events,
+            redacted_keys=redacted if redacted else TelemetryPolicy().redacted_keys,
+            max_payload_bytes=max_payload_bytes,
+        )
+
+
+class TelemetryGuard:
+    """Enforces a telemetry policy against events and payloads."""
+
+    def __init__(self, policy: TelemetryPolicy):
+        self.policy = policy
+
+    def sanitize_payload(self, payload: Mapping[str, object]) -> Dict[str, object]:
+        sanitized: Dict[str, object] = {}
+        for key, value in payload.items():
+            if key in self.policy.redacted_keys:
+                sanitized[key] = "[REDACTED]"
+            else:
+                sanitized[key] = value
+        return sanitized
+
+    def should_emit(self, event_name: str, payload: Mapping[str, object]) -> bool:
+        if not self.policy.enabled:
+            return False
+        if event_name in self.policy.blocked_events:
+            return False
+
+        if self.policy.max_payload_bytes is not None:
+            encoded = json.dumps(payload, default=str).encode("utf-8")
+            if len(encoded) > self.policy.max_payload_bytes:
+                return False
+
+        return True
+
+    def process(
+        self,
+        event_name: str,
+        payload: Mapping[str, object],
+    ) -> Optional[Dict[str, object]]:
+        """Return sanitized event payload if allowed, otherwise None."""
+        sanitized = self.sanitize_payload(payload)
+        if not self.should_emit(event_name, sanitized):
+            return None
+        return sanitized
+
+
+def write_example_config(path: str | Path = ".telemetry-policy.json") -> Path:
+    """Create a local telemetry policy config template."""
+    path = Path(path)
+    config = {
+        "TELEMETRY_ENABLED": "false",
+        "TELEMETRY_BLOCKED_EVENTS": "startup,heartbeat",
+        "TELEMETRY_REDACTED_KEYS": "email,password,token",
+        "TELEMETRY_MAX_PAYLOAD_BYTES": "8192",
+    }
+    path.write_text(json.dumps(config, indent=2) + "\n", encoding="utf-8")
+    return path
+
+
+if __name__ == "__main__":
+    # Demonstration only.
+    policy = TelemetryPolicy.from_env()
+    guard = TelemetryGuard(policy)
+
+    event = "user_login"
+    payload = {
+        "email": "someone@example.com",
+        "method": "password",
+        "success": True,
+    }
+
+    result = guard.process(event, payload)
+    if result is None:
+        print("Telemetry blocked")
+    else:
+        print("Telemetry allowed:", result)
diff --git a/tests/test_telemetry_restriction.py b/tests/test_telemetry_restriction.py
new file mode 100644
index 0000000000000000000000000000000000000000..4fff2561e20ed32d8d68f4668759ef3cffb499d2
--- /dev/null
+++ b/tests/test_telemetry_restriction.py
@@ -0,0 +1,24 @@
+import unittest
+
+from telemetry_restriction import TelemetryGuard, TelemetryPolicy
+
+
+class TelemetryGuardTests(unittest.TestCase):
+    def test_disabled_blocks_everything(self):
+        guard = TelemetryGuard(TelemetryPolicy(enabled=False))
+        self.assertIsNone(guard.process("event", {"ok": True}))
+
+    def test_redacts_sensitive_fields(self):
+        guard = TelemetryGuard(TelemetryPolicy(enabled=True))
+        payload = guard.process("event", {"email": "a@b.com", "value": 3})
+        self.assertEqual(payload["email"], "[REDACTED]")
+        self.assertEqual(payload["value"], 3)
+
+    def test_blocked_event_is_dropped(self):
+        policy = TelemetryPolicy(enabled=True, blocked_events=frozenset({"heartbeat"}))
+        guard = TelemetryGuard(policy)
+        self.assertIsNone(guard.process("heartbeat", {"ok": True}))
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/tests/test_telemetry_restrictions.py b/tests/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..e9669378316112877b8ea95ead37d41f8023bae6
--- /dev/null
+++ b/tests/test_telemetry_restrictions.py
@@ -0,0 +1,43 @@
+import os
+import socket
+import tempfile
+import unittest
+from pathlib import Path
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryFirewall,
+    TelemetryPolicy,
+    harden_runtime_environment,
+    remove_local_telemetry_artifacts,
+)
+
+
+class TestTelemetryRestrictions(unittest.TestCase):
+    def test_policy_blocks_known_endpoint(self):
+        policy = TelemetryPolicy(blocked_hosts=("*.sentry.io",))
+        self.assertFalse(policy.allows("ingest.sentry.io"))
+        self.assertTrue(policy.allows("example.org"))
+
+    def test_firewall_blocks_connection_attempt(self):
+        policy = TelemetryPolicy(blocked_hosts=("*.sentry.io",))
+        with TelemetryFirewall(policy):
+            with self.assertRaises(TelemetryBlockedError):
+                socket.create_connection(("ingest.sentry.io", 443), timeout=0.01)
+
+    def test_harden_runtime_environment_sets_flags(self):
+        harden_runtime_environment()
+        self.assertEqual(os.environ.get("DO_NOT_TRACK"), "1")
+        self.assertEqual(os.environ.get("TELEMETRY_DISABLED"), "1")
+
+    def test_artifact_scan_dry_run(self):
+        with tempfile.TemporaryDirectory() as d:
+            p = Path(d) / "telemetry.log"
+            p.write_text("x")
+            found = remove_local_telemetry_artifacts([Path(d)], dry_run=True)
+            self.assertEqual(found, [p])
+            self.assertTrue(p.exists())
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a0d9375de8ecd4d4fc50c48be7ad1ac1f86ff699
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,189 @@
+"""Telemetry restriction toolkit (defensive use only).
+
+This module is intentionally scoped to the current Python process so it can be
+used to reduce telemetry/data-exfiltration from software you control, test, or
+sandbox. It does not attempt to modify system-wide networking.
+"""
+
+from __future__ import annotations
+
+import argparse
+import fnmatch
+import os
+import socket
+from dataclasses import dataclass, field
+from pathlib import Path
+from typing import Iterable, List, Sequence
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is contacted."""
+
+
+@dataclass
+class TelemetryPolicy:
+    """Rule set used to decide if a destination should be blocked."""
+
+    blocked_hosts: Sequence[str] = field(default_factory=lambda: (
+        "*.sentry.io",
+        "*.datadoghq.com",
+        "*.segment.io",
+        "*.mixpanel.com",
+        "*.amplitude.com",
+        "*.google-analytics.com",
+        "*.doubleclick.net",
+    ))
+    allowed_hosts: Sequence[str] = field(default_factory=tuple)
+    block_private_ranges: bool = False
+
+    def allows(self, host: str) -> bool:
+        host = (host or "").strip().lower()
+        if not host:
+            return False
+
+        if any(fnmatch.fnmatch(host, pattern.lower()) for pattern in self.allowed_hosts):
+            return True
+
+        if self.block_private_ranges:
+            try:
+                ip = socket.gethostbyname(host)
+            except OSError:
+                ip = ""
+            if ip.startswith(("10.", "192.168.", "172.16.", "172.17.", "172.18.", "172.19.", "127.")):
+                return False
+
+        if any(fnmatch.fnmatch(host, pattern.lower()) for pattern in self.blocked_hosts):
+            return False
+
+        return True
+
+
+class TelemetryFirewall:
+    """Runtime network guard for telemetry suppression in one process."""
+
+    def __init__(self, policy: TelemetryPolicy):
+        self.policy = policy
+        self._orig_create_connection = socket.create_connection
+        self._orig_connect = socket.socket.connect
+        self.enabled = False
+
+    def _extract_host(self, address: object) -> str:
+        if isinstance(address, tuple) and address:
+            return str(address[0])
+        return str(address)
+
+    def _enforce(self, address: object) -> None:
+        host = self._extract_host(address)
+        if not self.policy.allows(host):
+            raise TelemetryBlockedError(f"Telemetry destination blocked: {host}")
+
+    def install(self) -> None:
+        if self.enabled:
+            return
+
+        def guarded_create_connection(address, *args, **kwargs):  # type: ignore[no-untyped-def]
+            self._enforce(address)
+            return self._orig_create_connection(address, *args, **kwargs)
+
+        def guarded_connect(sock, address):  # type: ignore[no-untyped-def]
+            self._enforce(address)
+            return self._orig_connect(sock, address)
+
+        socket.create_connection = guarded_create_connection  # type: ignore[assignment]
+        socket.socket.connect = guarded_connect  # type: ignore[assignment]
+        self.enabled = True
+
+    def uninstall(self) -> None:
+        if not self.enabled:
+            return
+        socket.create_connection = self._orig_create_connection  # type: ignore[assignment]
+        socket.socket.connect = self._orig_connect  # type: ignore[assignment]
+        self.enabled = False
+
+    def __enter__(self) -> "TelemetryFirewall":
+        self.install()
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> None:  # type: ignore[no-untyped-def]
+        self.uninstall()
+
+
+def harden_runtime_environment() -> None:
+    """Set widely-used opt-out environment variables for telemetry."""
+    env_updates = {
+        "DO_NOT_TRACK": "1",
+        "TELEMETRY_DISABLED": "1",
+        "SENTRY_DSN": "",
+        "SEGMENT_WRITE_KEY": "",
+        "AMPLITUDE_API_KEY": "",
+    }
+    os.environ.update(env_updates)
+
+
+def remove_local_telemetry_artifacts(paths: Iterable[Path], dry_run: bool = True) -> List[Path]:
+    """Remove telemetry-like local files in specified locations.
+
+    This function only touches paths explicitly provided by the caller.
+    """
+    removed: List[Path] = []
+    patterns = ("*telemetry*", "*analytics*", "*tracking*")
+
+    for root in paths:
+        root = root.expanduser().resolve()
+        if not root.exists() or not root.is_dir():
+            continue
+
+        for candidate in root.iterdir():
+            if any(fnmatch.fnmatch(candidate.name.lower(), p) for p in patterns):
+                if not dry_run:
+                    if candidate.is_file():
+                        candidate.unlink(missing_ok=True)
+                    elif candidate.is_dir():
+                        for child in candidate.rglob("*"):
+                            if child.is_file():
+                                child.unlink(missing_ok=True)
+                        candidate.rmdir()
+                removed.append(candidate)
+    return removed
+
+
+def _parse_csv(value: str) -> Sequence[str]:
+    if not value.strip():
+        return ()
+    return tuple(v.strip() for v in value.split(",") if v.strip())
+
+
+def main() -> int:
+    parser = argparse.ArgumentParser(description="Restrict telemetry from this Python process.")
+    parser.add_argument("--block", default="", help="Comma-separated host globs to block.")
+    parser.add_argument("--allow", default="", help="Comma-separated host globs to allow.")
+    parser.add_argument("--scan-dir", action="append", default=[], help="Directory to scan for local telemetry artifacts.")
+    parser.add_argument("--delete", action="store_true", help="Actually delete discovered artifacts.")
+    args = parser.parse_args()
+
+    harden_runtime_environment()
+
+    policy = TelemetryPolicy(
+        blocked_hosts=_parse_csv(args.block) or TelemetryPolicy().blocked_hosts,
+        allowed_hosts=_parse_csv(args.allow),
+    )
+
+    firewall = TelemetryFirewall(policy)
+    firewall.install()
+
+    scan_paths = [Path(p) for p in args.scan_dir]
+    found = remove_local_telemetry_artifacts(scan_paths, dry_run=not args.delete)
+
+    print("Telemetry firewall enabled for current process.")
+    print(f"Blocked host patterns: {', '.join(policy.blocked_hosts)}")
+    if found:
+        mode = "would remove" if not args.delete else "removed"
+        print(f"Artifacts {mode}: {', '.join(str(p) for p in found)}")
+    else:
+        print("No local telemetry artifacts discovered in provided directories.")
+
+    return 0
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..637080d1739ad01090a4a4de8b579d3da030dcd8
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,176 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(
+        default_factory=lambda: {
+            # Python / tooling
+            "DO_NOT_TRACK": "1",
+            "PYTHONWARNINGS": "ignore::UserWarning",
+            "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+            "PIP_NO_PYTHON_VERSION_WARNING": "1",
+            # Node ecosystem (often present in mixed repos)
+            "NPM_CONFIG_FUND": "false",
+            "NPM_CONFIG_AUDIT": "false",
+            "YARN_ENABLE_TELEMETRY": "0",
+            "NEXT_TELEMETRY_DISABLED": "1",
+            "ASTRO_TELEMETRY_DISABLED": "1",
+            # Cloud/ML SDK examples
+            "HF_HUB_DISABLE_TELEMETRY": "1",
+            "WANDB_DISABLED": "true",
+            "SENTRY_DSN": "",
+            "SEGMENT_WRITE_KEY": "",
+            "AMPLITUDE_API_KEY": "",
+        }
+    )
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "segment.io",
+            "api.segment.io",
+            "api.mixpanel.com",
+            "sentry.io",
+            "o447951.ingest.sentry.io",
+            "plausible.io",
+            "telemetry.pypi.org",
+            "api.amplitude.com",
+        }
+    )
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_IS_NETWORK_BLOCK_ACTIVE = False
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    return normalized in blocked_hosts
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _IS_NETWORK_BLOCK_ACTIVE
+    if _IS_NETWORK_BLOCK_ACTIVE:
+        return
+
+    blocked_hosts = set(policy.blocked_hosts)
+
+    def _guarded_getaddrinfo(host, *args, **kwargs):
+        if _is_host_blocked(host, blocked_hosts):
+            raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+        return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+    socket.getaddrinfo = _guarded_getaddrinfo
+    _IS_NETWORK_BLOCK_ACTIVE = True
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution."""
+    global _IS_NETWORK_BLOCK_ACTIVE
+    if not _IS_NETWORK_BLOCK_ACTIVE:
+        return
+    socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+    _IS_NETWORK_BLOCK_ACTIVE = False
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {"expected": expected, "actual": env.get(key), "active": env.get(key) == expected}
+        for key, expected in policy.env_overrides.items()
+    }
+
+    return {
+        "env": env_status,
+        "network_block_active": _IS_NETWORK_BLOCK_ACTIVE,
+        "blocked_hosts": sorted(policy.blocked_hosts),
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled.")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Blocked telemetry hosts: {', '.join(report['blocked_hosts'])}")
import psutil
import socket
import threading
import time
import json
import os
from datetime import datetime

CONFIG_FILE = "telemetry_config.json"
LOG_FILE = "telemetry_activity.log"

DEFAULT_CONFIG = {
    "mode": "monitor",  # monitor | block | whitelist
    "blocked_keywords": ["telemetry", "analytics", "tracking", "metrics"],
    "whitelist_domains": [],
    "blocked_domains": []
}

# --------------------------------------------------
# Config Management
# --------------------------------------------------

def load_config():
    if not os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "w") as f:
            json.dump(DEFAULT_CONFIG, f, indent=2)
    with open(CONFIG_FILE, "r") as f:
        return json.load(f)

def log_event(msg):
    with open(LOG_FILE, "a") as f:
        f.write(f"[{datetime.now()}] {msg}\n")
    print(msg)

# --------------------------------------------------
# Detection Logic
# --------------------------------------------------

def classify_domain(domain, config):
    domain = domain.lower()

    if domain in config["whitelist_domains"]:
        return "allowed"

    if domain in config["blocked_domains"]:
        return "blocked"

    for keyword in config["blocked_keywords"]:
        if keyword in domain:
            return "blocked"

    if config["mode"] == "whitelist":
        return "blocked"

    return "allowed"

# --------------------------------------------------
# Blocking via hosts file (Cross-platform basic)
# --------------------------------------------------

def block_domain_hosts(domain):
    hosts_path = "/etc/hosts"
    if os.name == "nt":
        hosts_path = r"C:\Windows\System32\drivers\etc\hosts"

    entry = f"127.0.0.1 {domain}\n"

    try:
        with open(hosts_path, "a") as f:
            f.write(entry)
        log_event(f"[HOSTS BLOCKED] {domain}")
    except Exception as e:
        log_event(f"[ERROR] Could not modify hosts: {e}")

# --------------------------------------------------
# Monitor Outbound Connections
# --------------------------------------------------

def monitor():
    config = load_config()
    seen = set()

    while True:
        for conn in psutil.net_connections(kind="inet"):
            if conn.raddr:
                ip = conn.raddr.ip

                if ip in seen:
                    continue

                try:
                    domain = socket.gethostbyaddr(ip)[0]
                except:
                    domain = ip

                decision = classify_domain(domain, config)

                if decision == "blocked":
                    log_event(f"[BLOCKED] {domain}")
                    if config["mode"] != "monitor":
                        block_domain_hosts(domain)

                else:
                    log_event(f"[ALLOWED] {domain}")

                seen.add(ip)

        time.sleep(5)

# --------------------------------------------------
# Main
# --------------------------------------------------

if __name__ == "__main__":
    log_event("Telemetry Controller Started")
    monitor()
from dnslib.server import DNSServer, BaseResolver
from dnslib import RR, QTYPE, A
import json

CONFIG_FILE = "telemetry_config.json"

class SinkholeResolver(BaseResolver):
    def resolve(self, request, handler):
        reply = request.reply()
        domain = str(request.q.qname).rstrip('.')

        with open(CONFIG_FILE) as f:
            config = json.load(f)

        for keyword in config["blocked_keywords"]:
            if keyword in domain:
                reply.add_answer(RR(domain, QTYPE.A, rdata=A("127.0.0.1"), ttl=60))
                return reply

        return reply  # normal resolution

if __name__ == "__main__":
    resolver = SinkholeResolver()
    server = DNSServer(resolver, port=53, address="0.0.0.0")
    server.start()
pip install psutil dnslib
import os
import subprocess
import psutil
import socket
import json
import time
from dnslib.server import DNSServer, BaseResolver
from dnslib import RR, QTYPE, A

CONFIG_FILE = "essential_policy.json"
LOG_FILE = "essential_guard.log"

DEFAULT_POLICY = {
    "whitelist_domains": [
        "example.com"
    ],
    "blocked_ports": [853, 443],  # Block DoT and HTTPS by default
    "enforce_firewall": True
}

# --------------------------------------------------
# Utility
# --------------------------------------------------

def log(msg):
    with open(LOG_FILE, "a") as f:
        f.write(msg + "\n")
    print(msg)

def load_policy():
    if not os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "w") as f:
            json.dump(DEFAULT_POLICY, f, indent=2)
    with open(CONFIG_FILE) as f:
        return json.load(f)

# --------------------------------------------------
# Firewall Enforcement (Linux iptables)
# --------------------------------------------------

def enforce_firewall(policy):
    if not policy["enforce_firewall"]:
        return

    log("Applying default deny firewall policy")

    subprocess.run(["iptables", "-P", "OUTPUT", "DROP"])
    subprocess.run(["iptables", "-F", "OUTPUT"])

    for domain in policy["whitelist_domains"]:
        try:
            ip = socket.gethostbyname(domain)
            subprocess.run(["iptables", "-A", "OUTPUT", "-d", ip, "-j", "ACCEPT"])
            log(f"Whitelisted: {domain} ({ip})")
        except:
            log(f"Could not resolve whitelist domain: {domain}")

# --------------------------------------------------
# DNS Sinkhole
# --------------------------------------------------

class ZeroTrustResolver(BaseResolver):
    def resolve(self, request, handler):
        reply = request.reply()
        domain = str(request.q.qname).rstrip('.')
        policy = load_policy()

        if domain not in policy["whitelist_domains"]:
            reply.add_answer(RR(domain, QTYPE.A, rdata=A("0.0.0.0"), ttl=60))
            log(f"DNS BLOCKED: {domain}")
        return reply

def start_dns_sinkhole():
    server = DNSServer(ZeroTrustResolver(), port=53, address="0.0.0.0")
    server.start_thread()
    log("DNS Sinkhole Active")

# --------------------------------------------------
# Process Monitoring
# --------------------------------------------------

def monitor_process_connections():
    while True:
        for conn in psutil.net_connections(kind="inet"):
            if conn.raddr:
                log(f"Process {conn.pid} attempted connection to {conn.raddr.ip}")
        time.sleep(5)

# --------------------------------------------------
# Main
# --------------------------------------------------

if __name__ == "__main__":
    log("Starting Essential Zero Trust Guard")

    policy = load_policy()

    enforce_firewall(policy)
    start_dns_sinkhole()
    monitor_process_connections()
# Block critical telemetry
python3 ethical_telemetry_blocker.py --block

# Check status
python3 ethical_telemetry_blocker.py --status

# Generate audit report (see what's blocked)
python3 ethical_telemetry_blocker.py --report

# Unblock everything (fully reversible)
python3 ethical_telemetry_blocker.py --unblock
# Install dependencies
pip install flask psutil requests

# Scan your system
python3 universal_system_remediation.py --system LINUX --scan

# Fix all issues
python3 universal_system_remediation.py --system LINUX --fix

# Start web dashboard
python3 universal_system_remediation.py --web --port 5000
# Open: http://localhost:5000
// Extract from multi_language_remediation.py
const { SystemRemediator } = require('./remediation.js');
const rem = new SystemRemediator('linux');
const results = await rem.remediateAll();
// Extract from multi_language_remediation.py
var remediator = new SystemRemediator(SystemType.Windows);
var results = await remediator.RemediateAllAsync();
az login
python3 << 'EOF'
# Extract Azure module from multi_language_remediation.py
# Run Azure-specific remediation
EOF
# PRIVACY-PRESERVING TELEMETRY BLOCKER
# Blocks telemetry WHILE keeping systems functional

"""
Ethical Telemetry Blocker
- Blocks known telemetry endpoints
- Preserves all system functionality
- Transparent about what it does
- Can be audited/disabled
- Respects user choice
"""
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff27a28b3e434a160482aa23958020aca504cfd7
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,212 @@
+"""Telemetry and outbound AI-service restriction utilities.
+
+This module provides a defensive approach to reduce telemetry emission and,
+when required by policy, prevent outbound traffic to common AI service hosts
+for the current Python process.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+from typing import Dict, Iterable, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(
+        default_factory=lambda: {
+            # Cross-ecosystem telemetry toggles
+            "DO_NOT_TRACK": "1",
+            "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+            "PIP_NO_PYTHON_VERSION_WARNING": "1",
+            "NPM_CONFIG_FUND": "false",
+            "NPM_CONFIG_AUDIT": "false",
+            "YARN_ENABLE_TELEMETRY": "0",
+            "NEXT_TELEMETRY_DISABLED": "1",
+            "ASTRO_TELEMETRY_DISABLED": "1",
+            "HF_HUB_DISABLE_TELEMETRY": "1",
+            "WANDB_DISABLED": "true",
+            "SENTRY_DSN": "",
+            "SEGMENT_WRITE_KEY": "",
+            "AMPLITUDE_API_KEY": "",
+        }
+    )
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "segment.io",
+            "api.segment.io",
+            "api.mixpanel.com",
+            "sentry.io",
+            "o447951.ingest.sentry.io",
+            "plausible.io",
+            "telemetry.pypi.org",
+            "api.amplitude.com",
+        }
+    )
+
+
+@dataclass(frozen=True)
+class AIEndpointPolicy:
+    """Policy for disabling outbound connections to popular AI endpoints."""
+
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "openai.com",
+            "api.openai.com",
+            "anthropic.com",
+            "api.anthropic.com",
+            "googleapis.com",
+            "generativelanguage.googleapis.com",
+            "cohere.com",
+            "api.cohere.ai",
+            "huggingface.co",
+            "api-inference.huggingface.co",
+        }
+    )
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_ACTIVE_BLOCKLIST: Set[str] = set()
+
+
+class HostBlockedError(ConnectionError):
+    """Raised when a blocked destination host is requested."""
+
+
+class TelemetryBlockedError(HostBlockedError):
+    """Backwards-compatible alias for telemetry-only blocks."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _iter_host_candidates(host: str) -> Iterable[str]:
+    """Yield host and parent domains for suffix-aware matching."""
+    parts = host.split(".")
+    for i in range(len(parts) - 1):
+        yield ".".join(parts[i:])
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    return any(candidate in blocked_hosts for candidate in _iter_host_candidates(normalized))
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(*blocked_host_sets: Set[str]) -> None:
+    """Deny DNS resolution for blocked hosts in the current Python process."""
+    global _ACTIVE_BLOCKLIST
+
+    for host_set in blocked_host_sets:
+        _ACTIVE_BLOCKLIST.update(_normalize_host(host) for host in host_set)
+
+    def _guarded_getaddrinfo(host, *args, **kwargs):
+        if _is_host_blocked(host, _ACTIVE_BLOCKLIST):
+            raise HostBlockedError(f"Blocked destination host: {host}")
+        return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+    socket.getaddrinfo = _guarded_getaddrinfo
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution and clear active blocklist."""
+    global _ACTIVE_BLOCKLIST
+    socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+    _ACTIVE_BLOCKLIST.clear()
+
+
+def audit_policy_state(
+    telemetry_policy: Optional[TelemetryPolicy] = None,
+    *,
+    ai_policy: Optional[AIEndpointPolicy] = None,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions and policy coverage."""
+    env = os.environ if environment is None else environment
+    telemetry = telemetry_policy or TelemetryPolicy()
+
+    env_status = {
+        key: {"expected": expected, "actual": env.get(key), "active": env.get(key) == expected}
+        for key, expected in telemetry.env_overrides.items()
+    }
+
+    report = {
+        "env": env_status,
+        "network_block_active": socket.getaddrinfo is not _ORIGINAL_GETADDRINFO,
+        "active_blocked_hosts": sorted(_ACTIVE_BLOCKLIST),
+        "telemetry_blocked_hosts": sorted(telemetry.blocked_hosts),
+    }
+
+    if ai_policy is not None:
+        report["ai_blocked_hosts"] = sorted(ai_policy.blocked_hosts)
+
+    return report
+
+
+@contextmanager
+def telemetry_restricted(
+    telemetry_policy: Optional[TelemetryPolicy] = None,
+    *,
+    ai_policy: Optional[AIEndpointPolicy] = None,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Apply telemetry restrictions and optional AI-endpoint blocking."""
+    active_policy = telemetry_policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        host_sets = [set(active_policy.blocked_hosts)]
+        if ai_policy is not None:
+            host_sets.append(set(ai_policy.blocked_hosts))
+        activate_network_block(*host_sets)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    telemetry_policy = TelemetryPolicy()
+    ai_policy = AIEndpointPolicy()
+
+    with telemetry_restricted(telemetry_policy, ai_policy=ai_policy):
+        report = audit_policy_state(telemetry_policy, ai_policy=ai_policy)
+        enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+        print("Restrictions enabled for this process.")
+        print(f"Telemetry env overrides active: {enabled_count}/{len(telemetry_policy.env_overrides)}")
+        print(f"Active blocked hosts: {len(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..b30d1875390b4c9c6f05b650bd5006d7af307e5a
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,79 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    AIEndpointPolicy,
+    HostBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_suffix_subdomain(self):
+        activate_network_block({"segment.io"})
+
+        with self.assertRaises(HostBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        activate_network_block({"segment.io"})
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_context_manager_blocks_ai_endpoints(self):
+        telemetry_policy = TelemetryPolicy(env_overrides={}, blocked_hosts=set())
+        ai_policy = AIEndpointPolicy(blocked_hosts={"openai.com"})
+
+        with telemetry_restricted(telemetry_policy, ai_policy=ai_policy, environment={}, block_network=True):
+            with self.assertRaises(HostBlockedError):
+                socket.getaddrinfo("api.openai.com", 443)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        telemetry_policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+        ai_policy = AIEndpointPolicy(blocked_hosts={"openai.com"})
+
+        report = audit_policy_state(telemetry_policy, ai_policy=ai_policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["telemetry_blocked_hosts"], ["segment.io"])
+        self.assertEqual(report["ai_blocked_hosts"], ["openai.com"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..ffe695a2eaf1bf3901e00ef3979d30d40abe0f42
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,214 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(
+        default_factory=lambda: {
+            # Generic controls
+            "DO_NOT_TRACK": "1",
+            # Python / tooling
+            "PYTHONWARNINGS": "ignore::UserWarning",
+            "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+            "PIP_NO_PYTHON_VERSION_WARNING": "1",
+            # Node ecosystem (often present in mixed repos)
+            "NPM_CONFIG_FUND": "false",
+            "NPM_CONFIG_AUDIT": "false",
+            "YARN_ENABLE_TELEMETRY": "0",
+            "NEXT_TELEMETRY_DISABLED": "1",
+            "ASTRO_TELEMETRY_DISABLED": "1",
+            # Cloud/ML SDK examples
+            "HF_HUB_DISABLE_TELEMETRY": "1",
+            "WANDB_DISABLED": "true",
+            "SENTRY_DSN": "",
+            "SEGMENT_WRITE_KEY": "",
+            "AMPLITUDE_API_KEY": "",
+        }
+    )
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "segment.io",
+            "mixpanel.com",
+            "sentry.io",
+            "plausible.io",
+            "telemetry.pypi.org",
+            "amplitude.com",
+        }
+    )
+    allowed_hosts: Set[str] = field(default_factory=set)
+    block_subdomains: bool = True
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_IS_NETWORK_BLOCK_ACTIVE = False
+_ACTIVE_BLOCK_COUNT = 0
+_ACTIVE_POLICY_STACK: list[TelemetryPolicy] = []
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _host_matches(candidate: str, base: str, *, allow_subdomains: bool) -> bool:
+    if candidate == base:
+        return True
+    if allow_subdomains and candidate.endswith(f".{base}"):
+        return True
+    return False
+
+
+def _is_host_blocked(host: object, policy: TelemetryPolicy) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    if any(_host_matches(normalized, _normalize_host(allowed), allow_subdomains=True)
+           for allowed in policy.allowed_hosts):
+        return False
+
+    return any(
+        _host_matches(normalized, _normalize_host(blocked), allow_subdomains=policy.block_subdomains)
+        for blocked in policy.blocked_hosts
+    )
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Patch socket name resolution to deny configured telemetry destinations."""
+    global _IS_NETWORK_BLOCK_ACTIVE, _ACTIVE_BLOCK_COUNT, _ACTIVE_POLICY_STACK
+
+    _ACTIVE_BLOCK_COUNT += 1
+    _ACTIVE_POLICY_STACK.append(policy)
+
+    if _IS_NETWORK_BLOCK_ACTIVE:
+        return
+
+    def _guarded_getaddrinfo(host, *args, **kwargs):
+        current_policy = _ACTIVE_POLICY_STACK[-1] if _ACTIVE_POLICY_STACK else None
+        if current_policy and _is_host_blocked(host, current_policy):
+            raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+        return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+    socket.getaddrinfo = _guarded_getaddrinfo
+    _IS_NETWORK_BLOCK_ACTIVE = True
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution."""
+    global _IS_NETWORK_BLOCK_ACTIVE, _ACTIVE_BLOCK_COUNT, _ACTIVE_POLICY_STACK
+
+    if _ACTIVE_POLICY_STACK:
+        _ACTIVE_POLICY_STACK.pop()
+
+    if _ACTIVE_BLOCK_COUNT > 0:
+        _ACTIVE_BLOCK_COUNT -= 1
+
+    if _ACTIVE_BLOCK_COUNT > 0:
+        return
+
+    if not _IS_NETWORK_BLOCK_ACTIVE:
+        return
+
+    socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+    _IS_NETWORK_BLOCK_ACTIVE = False
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {"expected": expected, "actual": env.get(key), "active": env.get(key) == expected}
+        for key, expected in policy.env_overrides.items()
+    }
+
+    return {
+        "env": env_status,
+        "network_block_active": _IS_NETWORK_BLOCK_ACTIVE,
+        "active_block_count": _ACTIVE_BLOCK_COUNT,
+        "blocked_hosts": sorted(policy.blocked_hosts),
+        "allowed_hosts": sorted(policy.allowed_hosts),
+        "block_subdomains": policy.block_subdomains,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled.")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Blocked telemetry hosts: {', '.join(report['blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..42ad50e41c19288bc9356694fc59c3a04d08fe44
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,107 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain_by_default(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_allowed_hosts_override_blocking(self):
+        policy = TelemetryPolicy(
+            env_overrides={},
+            blocked_hosts={"localhost"},
+            allowed_hosts={"localhost"},
+        )
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_nested_context_manager_unwinds_network_block(self):
+        outer = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        inner = TelemetryPolicy(env_overrides={}, blocked_hosts={"mixpanel.com"})
+
+        with telemetry_restricted(outer):
+            with telemetry_restricted(inner):
+                with self.assertRaises(TelemetryBlockedError):
+                    socket.getaddrinfo("api.mixpanel.com", 443)
+
+            with self.assertRaises(TelemetryBlockedError):
+                socket.getaddrinfo("segment.io", 443)
+
+        result = socket.getaddrinfo("segment.io", 443)
+        self.assertTrue(len(result) > 0)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+            allowed_hosts={"api.segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+        self.assertEqual(report["allowed_hosts"], ["api.segment.io"])
+        self.assertTrue(report["block_subdomains"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..3f147a0abec1bbc2b70c98becbefcf51c037035d
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,208 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(
+        default_factory=lambda: {
+            # General
+            "DO_NOT_TRACK": "1",
+            # Python / tooling
+            "PYTHONWARNINGS": "ignore::UserWarning",
+            "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+            "PIP_NO_PYTHON_VERSION_WARNING": "1",
+            "POETRY_NO_INTERACTION": "1",
+            # Node ecosystem (often present in mixed repos)
+            "NPM_CONFIG_FUND": "false",
+            "NPM_CONFIG_AUDIT": "false",
+            "YARN_ENABLE_TELEMETRY": "0",
+            "NEXT_TELEMETRY_DISABLED": "1",
+            "ASTRO_TELEMETRY_DISABLED": "1",
+            # Common SDK telemetry controls
+            "HF_HUB_DISABLE_TELEMETRY": "1",
+            "WANDB_DISABLED": "true",
+            "SENTRY_DSN": "",
+            "SEGMENT_WRITE_KEY": "",
+            "AMPLITUDE_API_KEY": "",
+            "POSTHOG_DISABLED": "1",
+        }
+    )
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "segment.io",
+            "mixpanel.com",
+            "sentry.io",
+            "plausible.io",
+            "telemetry.pypi.org",
+            "amplitude.com",
+            "posthog.com",
+        }
+    )
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= {_normalize_host(h) for h in policy.blocked_hosts}
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in policy.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": _NETWORK_BLOCK_REFCOUNT,
+        "blocked_hosts": sorted({_normalize_host(h) for h in policy.blocked_hosts}),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled.")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..636ff49d8941f461da0cecd9d3eab8d2fa8b9ad3
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,108 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
/mnt/user-data/outputs/
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..6923abc273c8d5f646e7323838bd140d2178aa5f
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,226 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(
+        default_factory=lambda: {
+            # General
+            "DO_NOT_TRACK": "1",
+            # Python / tooling
+            "PYTHONWARNINGS": "ignore::UserWarning",
+            "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+            "PIP_NO_PYTHON_VERSION_WARNING": "1",
+            "POETRY_NO_INTERACTION": "1",
+            # Node ecosystem (often present in mixed repos)
+            "NPM_CONFIG_FUND": "false",
+            "NPM_CONFIG_AUDIT": "false",
+            "YARN_ENABLE_TELEMETRY": "0",
+            "NEXT_TELEMETRY_DISABLED": "1",
+            "ASTRO_TELEMETRY_DISABLED": "1",
+            # Common SDK telemetry controls
+            "HF_HUB_DISABLE_TELEMETRY": "1",
+            "WANDB_DISABLED": "true",
+            "SENTRY_DSN": "",
+            "SEGMENT_WRITE_KEY": "",
+            "AMPLITUDE_API_KEY": "",
+            "POSTHOG_DISABLED": "1",
+        }
+    )
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "segment.io",
+            "mixpanel.com",
+            "sentry.io",
+            "plausible.io",
+            "telemetry.pypi.org",
+            "amplitude.com",
+            "posthog.com",
+        }
+    )
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def build_restricted_environment(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    base_environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Return a copy of environment variables with telemetry restrictions applied.
+
+    This helper is suitable for launching child processes with `subprocess` while
+    keeping changes scoped to that process invocation.
+    """
+    active_policy = policy or TelemetryPolicy()
+    new_env = dict(os.environ if base_environment is None else base_environment)
+    for key, value in active_policy.env_overrides.items():
+        new_env[key] = value
+    return new_env
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= {_normalize_host(h) for h in policy.blocked_hosts}
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in policy.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted({_normalize_host(h) for h in policy.blocked_hosts}),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (local process scope).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..c93f2fcddbaa28182de1153653b15c8343193329
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,121 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    build_restricted_environment,
+    deactivate_network_block,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_build_restricted_environment_isolated_copy(self):
+        base = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        new_env = build_restricted_environment(policy, base_environment=base)
+
+        self.assertEqual(new_env["DO_NOT_TRACK"], "1")
+        self.assertEqual(new_env["X"], "abc")
+        self.assertEqual(new_env["UNCHANGED"], "yes")
+        self.assertEqual(base["DO_NOT_TRACK"], "0")
+        self.assertNotIn("X", base)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..2fae90e72d98c8dae9a6a7f898810ed5c658e54d
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,128 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_network_block_allows_allowlisted_subdomain(self):
+        policy = TelemetryPolicy(
+            env_overrides={},
+            blocked_hosts={"segment.io"},
+            allowed_hosts={"api.segment.io"},
+        )
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("api.segment.io", 443)
+        self.assertTrue(len(result) > 0)
+
+    def test_create_connection_guard_blocks(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.create_connection(("segment.io", 443), timeout=0.1)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+            allowed_hosts={"internal.example"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+        self.assertEqual(report["allowed_hosts"], ["internal.example"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..f90e88712fed6ffaf0def07f0ae004206da22878
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,251 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(
+        default_factory=lambda: {
+            # General
+            "DO_NOT_TRACK": "1",
+            # Python / tooling
+            "PYTHONWARNINGS": "ignore::UserWarning",
+            "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+            "PIP_NO_PYTHON_VERSION_WARNING": "1",
+            "POETRY_NO_INTERACTION": "1",
+            # Node ecosystem (often present in mixed repos)
+            "NPM_CONFIG_FUND": "false",
+            "NPM_CONFIG_AUDIT": "false",
+            "YARN_ENABLE_TELEMETRY": "0",
+            "NEXT_TELEMETRY_DISABLED": "1",
+            "ASTRO_TELEMETRY_DISABLED": "1",
+            # Common SDK telemetry controls
+            "HF_HUB_DISABLE_TELEMETRY": "1",
+            "WANDB_DISABLED": "true",
+            "SENTRY_DSN": "",
+            "SEGMENT_WRITE_KEY": "",
+            "AMPLITUDE_API_KEY": "",
+            "POSTHOG_DISABLED": "1",
+        }
+    )
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "segment.io",
+            "mixpanel.com",
+            "sentry.io",
+            "plausible.io",
+            "telemetry.pypi.org",
+            "amplitude.com",
+            "posthog.com",
+        }
+    )
+    allowed_hosts: Set[str] = field(default_factory=set)
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_ORIGINAL_CREATE_CONNECTION = socket.create_connection
+_ORIGINAL_SOCKET_CONNECT = socket.socket.connect
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+_CURRENT_ALLOWED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _matches_domain(host: str, domain: str) -> bool:
+    return host == domain or host.endswith(f".{domain}")
+
+
+def _is_host_allowed(host: object, allowed_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+    return any(_matches_domain(normalized, allowed) for allowed in allowed_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str], allowed_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+    if _is_host_allowed(normalized, allowed_hosts):
+        return False
+    return any(_matches_domain(normalized, blocked) for blocked in blocked_hosts)
+
+
+def _extract_host_from_address(address: object) -> object:
+    if isinstance(address, tuple) and address:
+        return address[0]
+    return None
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Patch DNS and socket connection calls to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+    global _CURRENT_ALLOWED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= {_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}
+        _CURRENT_ALLOWED_HOSTS |= {_normalize_host(h) for h in policy.allowed_hosts if _normalize_host(h)}
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS, _CURRENT_ALLOWED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            def _guarded_create_connection(address, *args, **kwargs):
+                host = _extract_host_from_address(address)
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS, _CURRENT_ALLOWED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_CREATE_CONNECTION(address, *args, **kwargs)
+
+            def _guarded_socket_connect(sock, address):
+                host = _extract_host_from_address(address)
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS, _CURRENT_ALLOWED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_SOCKET_CONNECT(sock, address)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+            socket.create_connection = _guarded_create_connection
+            socket.socket.connect = _guarded_socket_connect
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket behavior when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+    global _CURRENT_ALLOWED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            socket.create_connection = _ORIGINAL_CREATE_CONNECTION
+            socket.socket.connect = _ORIGINAL_SOCKET_CONNECT
+            _CURRENT_BLOCKED_HOSTS = set()
+            _CURRENT_ALLOWED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in policy.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        active_allowed_hosts = sorted(_CURRENT_ALLOWED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": _NETWORK_BLOCK_REFCOUNT,
+        "blocked_hosts": sorted({_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}),
+        "allowed_hosts": sorted({_normalize_host(h) for h in policy.allowed_hosts if _normalize_host(h)}),
+        "active_blocked_hosts": active_hosts,
+        "active_allowed_hosts": active_allowed_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled.")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
+    if report["active_allowed_hosts"]:
+        print(f"Allowed telemetry hosts: {', '.join(report['active_allowed_hosts'])}")
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..23466994ad540240bf4adefbf143c4db463ee6dc
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,306 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Callable, Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(
+        default_factory=lambda: {
+            "DO_NOT_TRACK": "1",
+            "PYTHONWARNINGS": "ignore::UserWarning",
+            "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+            "PIP_NO_PYTHON_VERSION_WARNING": "1",
+            "POETRY_NO_INTERACTION": "1",
+            "NPM_CONFIG_FUND": "false",
+            "NPM_CONFIG_AUDIT": "false",
+            "YARN_ENABLE_TELEMETRY": "0",
+            "NEXT_TELEMETRY_DISABLED": "1",
+            "ASTRO_TELEMETRY_DISABLED": "1",
+            "HF_HUB_DISABLE_TELEMETRY": "1",
+            "WANDB_DISABLED": "true",
+            "SENTRY_DSN": "",
+            "SEGMENT_WRITE_KEY": "",
+            "AMPLITUDE_API_KEY": "",
+            "POSTHOG_DISABLED": "1",
+        }
+    )
+    blocked_hosts: Set[str] = field(
+        default_factory=lambda: {
+            "segment.io",
+            "mixpanel.com",
+            "sentry.io",
+            "plausible.io",
+            "telemetry.pypi.org",
+            "amplitude.com",
+            "posthog.com",
+        }
+    )
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+_PATCH_LOCK = threading.Lock()
+_PATCHED_CLIENTS_REFCOUNT = 0
+_PATCH_REVERT_STACK: list[Callable[[], None]] = []
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+    return any(normalized == blocked or normalized.endswith(f".{blocked}") for blocked in blocked_hosts)
+
+
+def _extract_host_from_url(url: str) -> str:
+    candidate = url.strip()
+    if "://" in candidate:
+        candidate = candidate.split("://", 1)[1]
+    candidate = candidate.split("/", 1)[0].split("@")[-1]
+    if ":" in candidate:
+        candidate = candidate.split(":", 1)[0]
+    return _normalize_host(candidate)
+
+
+def _is_url_blocked(url: str, blocked_hosts: Set[str]) -> bool:
+    return _is_host_blocked(_extract_host_from_url(url), blocked_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= {_normalize_host(h) for h in policy.blocked_hosts}
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def _patch_requests(blocked_hosts: Set[str]) -> Optional[Callable[[], None]]:
+    try:
+        import requests.sessions as requests_sessions  # type: ignore
+    except ImportError:
+        return None
+
+    original_request = requests_sessions.Session.request
+
+    def guarded_request(self, method, url, *args, **kwargs):
+        if _is_url_blocked(str(url), blocked_hosts):
+            raise TelemetryBlockedError(f"Blocked telemetry URL: {url}")
+        return original_request(self, method, url, *args, **kwargs)
+
+    requests_sessions.Session.request = guarded_request
+
+    def revert() -> None:
+        requests_sessions.Session.request = original_request
+
+    return revert
+
+
+def _patch_httpx(blocked_hosts: Set[str]) -> Optional[Callable[[], None]]:
+    try:
+        import httpx._client as httpx_client  # type: ignore
+    except ImportError:
+        return None
+
+    original_send = httpx_client.Client.send
+
+    def guarded_send(self, request, *args, **kwargs):
+        host = _normalize_host(getattr(getattr(request, "url", None), "host", ""))
+        if _is_host_blocked(host, blocked_hosts):
+            raise TelemetryBlockedError(f"Blocked telemetry URL host: {host}")
+        return original_send(self, request, *args, **kwargs)
+
+    httpx_client.Client.send = guarded_send
+
+    def revert() -> None:
+        httpx_client.Client.send = original_send
+
+    return revert
+
+
+def activate_http_client_guards(policy: TelemetryPolicy) -> None:
+    """Patch common HTTP clients to block requests to telemetry hosts."""
+    global _PATCHED_CLIENTS_REFCOUNT
+
+    with _PATCH_LOCK:
+        if _PATCHED_CLIENTS_REFCOUNT == 0:
+            blockers = {_normalize_host(h) for h in policy.blocked_hosts}
+            for patcher in (_patch_requests, _patch_httpx):
+                revert = patcher(blockers)
+                if revert is not None:
+                    _PATCH_REVERT_STACK.append(revert)
+
+        _PATCHED_CLIENTS_REFCOUNT += 1
+
+
+def deactivate_http_client_guards() -> None:
+    """Revert HTTP client guards when the last activation exits."""
+    global _PATCHED_CLIENTS_REFCOUNT
+
+    with _PATCH_LOCK:
+        if _PATCHED_CLIENTS_REFCOUNT == 0:
+            return
+
+        _PATCHED_CLIENTS_REFCOUNT -= 1
+        if _PATCHED_CLIENTS_REFCOUNT == 0:
+            while _PATCH_REVERT_STACK:
+                revert = _PATCH_REVERT_STACK.pop()
+                revert()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in policy.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        net_refcount = _NETWORK_BLOCK_REFCOUNT
+
+    with _PATCH_LOCK:
+        client_refcount = _PATCHED_CLIENTS_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": net_refcount,
+        "http_client_guards_active": client_refcount > 0,
+        "http_client_guards_refcount": client_refcount,
+        "blocked_hosts": sorted({_normalize_host(h) for h in policy.blocked_hosts}),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+    guard_http_clients: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+    if guard_http_clients:
+        activate_http_client_guards(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if guard_http_clients:
+            deactivate_http_client_guards()
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+    activate_http_client_guards(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled.")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(
+        "HTTP client guards active: "
+        f"{report['http_client_guards_active']} (refcount={report['http_client_guards_refcount']})"
+    )
+    print(f"Blocked telemetry hosts: {', '.join(report['blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..e09945d5a90237747c12950fcf5ffdf3efdbdf81
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,125 @@
+import socket
+import unittest
+
+import telemetry_restrictions as tr
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_http_client_guards,
+    deactivate_network_block,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_http_client_guards()
+        deactivate_http_client_guards()
+        deactivate_http_client_guards()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_extract_host_from_url(self):
+        self.assertEqual(tr._extract_host_from_url("https://api.segment.io/v1/t"), "api.segment.io")
+        self.assertEqual(tr._extract_host_from_url("http://user:pass@sentry.io:443/api"), "sentry.io")
+
+    def test_http_client_guards_refcount_exposed_in_audit(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+
+        tr.activate_http_client_guards(policy)
+        tr.activate_http_client_guards(policy)
+        report = audit_policy_state(policy, environment={})
+        self.assertTrue(report["http_client_guards_active"])
+        self.assertEqual(report["http_client_guards_refcount"], 2)
+
+        deactivate_http_client_guards()
+        report = audit_policy_state(policy, environment={})
+        self.assertEqual(report["http_client_guards_refcount"], 1)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False, guard_http_clients=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..4513a68fa8b4326e565103aa4157577fa4571e15
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,226 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        combined_env.update(policy.env_overrides)
+        combined_hosts |= {_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= {_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in policy.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted({_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..5792717c3bd513c2eb3f0f073d71a0d422dfe729
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,119 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
python3 cybersecurity_telemetry_system.py --check
python3 cybersecurity_telemetry_system.py --compliance
python3 cybersecurity_telemetry_system.py --report --output weekly_report.txt
python3 cybersecurity_telemetry_system.py --check
python3 cybersecurity_telemetry_system.py --violations
# Execute remediation steps
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..166f336a8df6a347e813bb82f2dd52e5ca220dd2
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,249 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+- It does not interfere with OS/network infrastructure outside this process.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_ORIGINAL_CREATE_CONNECTION = socket.create_connection
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def _collect_normalized_hosts(hosts: Set[str]) -> Set[str]:
+    return {h for h in (_normalize_host(host) for host in hosts) if h}
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        combined_env.update(policy.env_overrides)
+        combined_hosts |= _collect_normalized_hosts(policy.blocked_hosts)
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Install process-local socket guards for blocked telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= _collect_normalized_hosts(policy.blocked_hosts)
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            def _guarded_create_connection(address, *args, **kwargs):
+                host = address[0] if isinstance(address, tuple) and address else address
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_CREATE_CONNECTION(address, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+            socket.create_connection = _guarded_create_connection
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket functions when the last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            socket.create_connection = _ORIGINAL_CREATE_CONNECTION
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in policy.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(_collect_normalized_hosts(policy.blocked_hosts)),
+        "active_blocked_hosts": active_hosts,
+        "guarded_functions": {
+            "getaddrinfo": socket.getaddrinfo is not _ORIGINAL_GETADDRINFO,
+            "create_connection": socket.create_connection is not _ORIGINAL_CREATE_CONNECTION,
+        },
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
+    print(
+        "Socket guards: "
+        f"getaddrinfo={report['guarded_functions']['getaddrinfo']}, "
+        f"create_connection={report['guarded_functions']['create_connection']}"
+    )
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..28c7052d24705c33cd9f658f5400d045f45c4226
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,138 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_blocks_create_connection(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.create_connection(("api.segment.io", 443), timeout=0.05)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+    def test_audit_reports_guarded_socket_functions(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+
+        inactive_report = audit_policy_state(policy, environment={})
+        self.assertFalse(inactive_report["guarded_functions"]["getaddrinfo"])
+        self.assertFalse(inactive_report["guarded_functions"]["create_connection"])
+
+        activate_network_block(policy)
+        active_report = audit_policy_state(policy, environment={})
+        self.assertTrue(active_report["guarded_functions"]["getaddrinfo"])
+        self.assertTrue(active_report["guarded_functions"]["create_connection"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..6433f693891b38672a1f5d2cd79f6f19b27230f1
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,293 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+from enum import Enum
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+class NetworkMode(str, Enum):
+    """How outbound DNS resolution is controlled."""
+
+    DENYLIST = "denylist"
+    ALLOWLIST = "allowlist"
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+DEFAULT_SAFE_ALLOWED_HOSTS: Set[str] = {"localhost", "127.0.0.1", "::1"}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+    allowed_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_SAFE_ALLOWED_HOSTS))
+    network_mode: NetworkMode = NetworkMode.DENYLIST
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+_CURRENT_ALLOWED_HOSTS: Set[str] = set(DEFAULT_SAFE_ALLOWED_HOSTS)
+_CURRENT_NETWORK_MODE: NetworkMode = NetworkMode.DENYLIST
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+    return str(host).strip().lower().rstrip(".")
+
+
+def _matches_host_or_subdomain(host: str, rule: str) -> bool:
+    return host == rule or host.endswith(f".{rule}")
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    for blocked in blocked_hosts:
+        if _matches_host_or_subdomain(normalized, blocked):
+            return True
+    return False
+
+
+def _is_host_allowed(host: object, allowed_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    for allowed in allowed_hosts:
+        if _matches_host_or_subdomain(normalized, allowed):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy.
+
+    Later policies win for scalar values (`network_mode`) and env key conflicts.
+    Host sets are unioned.
+    """
+    combined_env: Dict[str, str] = {}
+    combined_blocked: Set[str] = set()
+    combined_allowed: Set[str] = set()
+    network_mode = NetworkMode.DENYLIST
+
+    for policy in policies:
+        combined_env.update(policy.env_overrides)
+        combined_blocked |= {_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}
+        combined_allowed |= {_normalize_host(h) for h in policy.allowed_hosts if _normalize_host(h)}
+        network_mode = policy.network_mode
+
+    return TelemetryPolicy(
+        env_overrides=combined_env,
+        blocked_hosts=combined_blocked,
+        allowed_hosts=combined_allowed,
+        network_mode=network_mode,
+    )
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in policy.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution according to policy mode."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+    global _CURRENT_ALLOWED_HOSTS
+    global _CURRENT_NETWORK_MODE
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= {_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}
+        _CURRENT_ALLOWED_HOSTS |= {_normalize_host(h) for h in policy.allowed_hosts if _normalize_host(h)}
+        _CURRENT_NETWORK_MODE = policy.network_mode
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _CURRENT_NETWORK_MODE == NetworkMode.DENYLIST:
+                    if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                        raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                else:
+                    if not _is_host_allowed(host, _CURRENT_ALLOWED_HOSTS):
+                        raise TelemetryBlockedError(f"Host not allowed in allowlist mode: {host}")
+
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+    global _CURRENT_ALLOWED_HOSTS
+    global _CURRENT_NETWORK_MODE
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+            _CURRENT_ALLOWED_HOSTS = set(DEFAULT_SAFE_ALLOWED_HOSTS)
+            _CURRENT_NETWORK_MODE = NetworkMode.DENYLIST
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in policy.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_blocked_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        active_allowed_hosts = sorted(_CURRENT_ALLOWED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+        active_mode = _CURRENT_NETWORK_MODE.value
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "network_mode": policy.network_mode.value,
+        "active_network_mode": active_mode,
+        "blocked_hosts": sorted({_normalize_host(h) for h in policy.blocked_hosts if _normalize_host(h)}),
+        "allowed_hosts": sorted({_normalize_host(h) for h in policy.allowed_hosts if _normalize_host(h)}),
+        "active_blocked_hosts": active_blocked_hosts,
+        "active_allowed_hosts": active_allowed_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = policy or TelemetryPolicy()
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = TelemetryPolicy()
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(
+        "Network block active: "
+        f"{report['network_block_active']} "
+        f"(mode={report['active_network_mode']}, refcount={report['network_block_refcount']})"
+    )
+    if report["active_network_mode"] == NetworkMode.DENYLIST.value:
+        print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
+    else:
+        print(f"Allowed hosts: {', '.join(report['active_allowed_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..b190b40c881b615c3641691d3ab2a8d93c904e5d
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,144 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    NetworkMode,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_allowlist_mode_blocks_non_allowed_hosts(self):
+        policy = TelemetryPolicy(
+            env_overrides={},
+            blocked_hosts=set(),
+            allowed_hosts={"localhost"},
+            network_mode=NetworkMode.ALLOWLIST,
+        )
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("example.com", 80)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(
+            env_overrides={"B": "2", "A": "override"},
+            blocked_hosts={"sentry.io"},
+            allowed_hosts={"localhost"},
+            network_mode=NetworkMode.ALLOWLIST,
+        )
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+        self.assertEqual(merged.allowed_hosts, {"localhost", "127.0.0.1", "::1"})
+        self.assertEqual(merged.network_mode, NetworkMode.ALLOWLIST)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+            network_mode=NetworkMode.DENYLIST,
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+        self.assertEqual(report["network_mode"], "denylist")
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..b190b40c881b615c3641691d3ab2a8d93c904e5d
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,144 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    NetworkMode,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_allowlist_mode_blocks_non_allowed_hosts(self):
+        policy = TelemetryPolicy(
+            env_overrides={},
+            blocked_hosts=set(),
+            allowed_hosts={"localhost"},
+            network_mode=NetworkMode.ALLOWLIST,
+        )
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("example.com", 80)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(
+            env_overrides={"B": "2", "A": "override"},
+            blocked_hosts={"sentry.io"},
+            allowed_hosts={"localhost"},
+            network_mode=NetworkMode.ALLOWLIST,
+        )
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+        self.assertEqual(merged.allowed_hosts, {"localhost", "127.0.0.1", "::1"})
+        self.assertEqual(merged.network_mode, NetworkMode.ALLOWLIST)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+            network_mode=NetworkMode.DENYLIST,
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+        self.assertEqual(report["network_mode"], "denylist")
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..c54da343e61ad79209b7911116c136aba5a5cdfc
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,141 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    enforce_endpoint_allowed,
+    extract_host_from_endpoint,
+    is_endpoint_blocked,
+    merge_policies,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_extract_host_from_endpoint(self):
+        self.assertEqual(extract_host_from_endpoint("https://api.segment.io/v1/write"), "api.segment.io")
+        self.assertEqual(extract_host_from_endpoint("api.segment.io:443"), "api.segment.io")
+        self.assertEqual(extract_host_from_endpoint("segment.io"), "segment.io")
+
+    def test_is_endpoint_blocked(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+
+        self.assertTrue(is_endpoint_blocked("https://api.segment.io/v1/write", policy))
+        self.assertFalse(is_endpoint_blocked("https://example.com", policy))
+
+    def test_enforce_endpoint_allowed(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+
+        with self.assertRaises(TelemetryBlockedError):
+            enforce_endpoint_allowed("https://segment.io/collect", policy)
+
+        enforce_endpoint_allowed("https://example.com", policy)
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a4d6c600e236af3dcaa45caf5cdb6036c843eaee
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,261 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+class InvalidTelemetryPolicyError(ValueError):
+    """Raised when policy configuration is malformed."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+
+    normalized = str(host).strip().lower().rstrip(".")
+    if "://" in normalized:
+        # Caller provided a URL; keep host-only behavior explicit and safe.
+        return ""
+
+    return normalized
+
+
+def _validate_env_overrides(env_overrides: Mapping[str, str]) -> None:
+    for key, value in env_overrides.items():
+        if not isinstance(key, str) or not key.strip():
+            raise InvalidTelemetryPolicyError("Environment override keys must be non-empty strings.")
+        if "=" in key:
+            raise InvalidTelemetryPolicyError(f"Invalid env key '{key}': must not contain '='.")
+        if not isinstance(value, str):
+            raise InvalidTelemetryPolicyError(f"Invalid env value for '{key}': expected string.")
+
+
+def normalize_policy(policy: TelemetryPolicy) -> TelemetryPolicy:
+    """Return a sanitized policy with normalized hosts and validated env overrides."""
+    _validate_env_overrides(policy.env_overrides)
+
+    normalized_hosts = {_normalize_host(host) for host in policy.blocked_hosts}
+    normalized_hosts = {host for host in normalized_hosts if host}
+
+    return TelemetryPolicy(env_overrides=dict(policy.env_overrides), blocked_hosts=normalized_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        normalized = normalize_policy(policy)
+        combined_env.update(normalized.env_overrides)
+        combined_hosts |= normalized.blocked_hosts
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in normalized.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    normalized = normalize_policy(policy)
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= normalized.blocked_hosts
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in normalized.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(normalized.blocked_hosts),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = normalize_policy(policy or TelemetryPolicy())
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = normalize_policy(TelemetryPolicy())
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
# Run PowerShell as Administrator

# 1) Set outbound to Block for all profiles
Set-NetFirewallProfile -Profile Domain,Public,Private -DefaultOutboundAction Block

# 2) (Optional) Allow DNS + DHCP if you still want basic network operation
# DNS (53)
New-NetFirewallRule -DisplayName "Allow DNS Outbound" -Direction Outbound -Action Allow -Protocol UDP -RemotePort 53
New-NetFirewallRule -DisplayName "Allow DNS TCP Outbound" -Direction Outbound -Action Allow -Protocol TCP -RemotePort 53

# DHCP (67/68) - needed for many networks
New-NetFirewallRule -DisplayName "Allow DHCP Outbound" -Direction Outbound -Action Allow -Protocol UDP -RemotePort 67,68

# 3) Add allow rules per app as needed (example: allow a specific exe)
# New-NetFirewallRule -DisplayName "Allow MyApp" -Direction Outbound -Action Allow -Program "C:\Path\MyApp.exe"
# Enable and set default policies
sudo ufw default deny outgoing
sudo ufw default deny incoming

# Allow DNS (adjust if you use a specific resolver)
sudo ufw allow out 53/udp
sudo ufw allow out 53/tcp

# Allow DHCP (common on client machines)
sudo ufw allow out 67,68/udp

sudo ufw enable
sudo ufw status verbose
receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  batch:

exporters:
  nop: {}

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [nop]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [nop]
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [nop]
# Flush existing rules
sudo nft flush ruleset

# Create table and chains
sudo nft add table inet filter
sudo nft 'add chain inet filter input { type filter hook input priority 0 ; policy drop; }'
sudo nft 'add chain inet filter output { type filter hook output priority 0 ; policy drop; }'

# Allow loopback
sudo nft add rule inet filter input iif lo accept
sudo nft add rule inet filter output oif lo accept

# Allow established connections
sudo nft add rule inet filter input ct state established,related accept
sudo nft add rule inet filter output ct state established,related accept

# Allow DNS outbound only
sudo nft add rule inet filter output udp dport 53 accept
sudo nft add rule inet filter output tcp dport 53 accept
#include <tunables/global>

profile myapp /usr/bin/myapp {
  network deny,
  capability,
  file,
  deny /etc/** w,
}
sudo apparmor_parser -r /etc/apparmor.d/usr.bin.myapp
receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  memory_limiter:
    limit_mib: 200
  batch:

exporters:
  file:
    path: /var/log/otel-local.json

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [memory_limiter, batch]
      exporters: [file]
    logs:
      receivers: [otlp]
      processors: [memory_limiter, batch]
      exporters: [file]
address=/maliciousdomain.com/0.0.0.0
address=/badactor.net/0.0.0.0
sudo systemctl restart dnsmasq
import psutil
import socket
import time

ALLOWED_PORTS = {53, 443, 80}

def monitor():
    print("Monitoring outbound connections...")
    while True:
        for conn in psutil.net_connections(kind='inet'):
            if conn.status == 'ESTABLISHED' and conn.raddr:
                if conn.raddr.port not in ALLOWED_PORTS:
                    print(f"[ALERT] PID {conn.pid} connected to "
                          f"{conn.raddr.ip}:{conn.raddr.port}")
        time.sleep(5)

if __name__ == "__main__":
    monitor()
cat /proc/sys/kernel/randomize_va_space
sudo ip link set eth0 down
sudo ip link set wlan0 down
sudo nft add rule inet filter output drop
[Endpoint]
    
[Local Firewall - Default Deny]
    
[DNS Sinkhole]
    
[Internal Proxy]
    
[Allowlisted Internet Egress]
# Block outbound by default
Set-NetFirewallProfile -Profile Domain,Public,Private -DefaultOutboundAction Block

# Allow DNS
New-NetFirewallRule -DisplayName "Allow DNS UDP" -Direction Outbound -Action Allow -Protocol UDP -RemotePort 53
New-NetFirewallRule -DisplayName "Allow DNS TCP" -Direction Outbound -Action Allow -Protocol TCP -RemotePort 53

# Allow HTTPS (if needed)
New-NetFirewallRule -DisplayName "Allow HTTPS" -Direction Outbound -Action Allow -Protocol TCP -RemotePort 443

# Allow Windows Update only
New-NetFirewallRule -DisplayName "Allow Windows Update" `
  -Direction Outbound -Action Allow `
  -Program "%SystemRoot%\System32\svchost.exe" `
  -Service wuauserv
Set-MpPreference -AttackSurfaceReductionRules_Ids `
  D4F940AB-401B-4EFC-AADC-AD5F3C50688A, `
  3B576869-A4EC-4529-8536-B80A7769E899 `
  -AttackSurfaceReductionRules_Actions Enabled
while ($true) {
    Get-NetTCPConnection -State Established |
    Where-Object { $_.RemotePort -notin 80,443,53 } |
    ForEach-Object {
        Write-Host "[ALERT] Unexpected outbound connection to $($_.RemoteAddress):$($_.RemotePort)"
    }
    Start-Sleep -Seconds 5
}
Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol
Disable-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2
Set-ExecutionPolicy AllSigned -Scope LocalMachine
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL /t REG_DWORD /d 1 /f
Set-MpPreference -EnableControlledFolderAccess Enabled
Set-DnsClientServerAddress -InterfaceAlias "Ethernet" -ServerAddresses ("1.1.1.1")
Set-DnsClientDohServerAddress -ServerAddress "1.1.1.1" -DohTemplate "https://cloudflare-dns.com/dns-query" -AllowFallbackToUdp $False
Windows Security  App & Browser Control  Exploit Protection
Set-AppLockerPolicy -XMLPolicy "C:\Path\To\Policy.xml"
secpol.msc  Application Control Policies
Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection" `
  -Name "AllowTelemetry" -Value 0 -Type DWord
Disable-NetAdapter -Name "Ethernet" -Confirm:$false
Disable-NetAdapter -Name "Wi-Fi" -Confirm:$false
Windows Defender (Real-Time + ASR)
        
Default-Deny Outbound Firewall
        
AppLocker
        
Script Block Logging
        
Encrypted DNS
        
Controlled Folder Access
diff --git a/telemetry_cybersecurity.py b/telemetry_cybersecurity.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb54ac62f223d3d59b1f038c92d6faff0d73cca1
--- /dev/null
+++ b/telemetry_cybersecurity.py
@@ -0,0 +1,104 @@
+"""Cybersecurity-oriented telemetry controls.
+
+This script provides practical, process-local controls for telemetry hygiene:
+- apply safe telemetry restrictions (env + network denylist)
+- audit active telemetry policy state
+- run DNS-level egress probes against known telemetry destinations
+
+Usage examples:
+  python telemetry_cybersecurity.py --audit
+  python telemetry_cybersecurity.py --enforce --probe
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import socket
+from typing import Dict, List
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    normalize_policy,
+)
+
+
+def run_egress_probe(policy: TelemetryPolicy) -> Dict[str, object]:
+    """Probe telemetry host resolution to verify denylist enforcement."""
+    normalized = normalize_policy(policy)
+    blocked_results: Dict[str, str] = {}
+    blocked_count = 0
+
+    for host in sorted(normalized.blocked_hosts):
+        try:
+            socket.getaddrinfo(host, 443)
+            blocked_results[host] = "resolved"
+        except TelemetryBlockedError:
+            blocked_results[host] = "blocked"
+            blocked_count += 1
+
+    return {
+        "total_hosts_tested": len(normalized.blocked_hosts),
+        "blocked_hosts": blocked_count,
+        "all_blocked": blocked_count == len(normalized.blocked_hosts),
+        "results": blocked_results,
+    }
+
+
+def enforce_and_audit(policy: TelemetryPolicy, *, run_probe: bool = False) -> Dict[str, object]:
+    """Apply restrictions, optionally probe egress, and return a report."""
+    normalized = normalize_policy(policy)
+    apply_env_restrictions(normalized)
+    activate_network_block(normalized)
+
+    report: Dict[str, object] = {
+        "audit": audit_policy_state(normalized),
+    }
+
+    if run_probe:
+        report["probe"] = run_egress_probe(normalized)
+
+    return report
+
+
+def parse_args(argv: List[str] | None = None) -> argparse.Namespace:
+    parser = argparse.ArgumentParser(description="Telemetry cybersecurity utility")
+    parser.add_argument("--audit", action="store_true", help="Print current policy audit report")
+    parser.add_argument("--enforce", action="store_true", help="Apply telemetry restrictions to this process")
+    parser.add_argument("--probe", action="store_true", help="Probe denylist hosts after enforcement")
+    parser.add_argument("--pretty", action="store_true", help="Pretty-print JSON output")
+    return parser.parse_args(argv)
+
+
+def main(argv: List[str] | None = None) -> int:
+    args = parse_args(argv)
+    policy = TelemetryPolicy()
+
+    if not args.audit and not args.enforce:
+        args.audit = True
+
+    output: Dict[str, object] = {}
+    if args.enforce:
+        output = enforce_and_audit(policy, run_probe=args.probe)
+    elif args.audit:
+        output = {"audit": audit_policy_state(policy)}
+
+    if args.pretty:
+        print(json.dumps(output, indent=2, sort_keys=True))
+    else:
+        print(json.dumps(output, sort_keys=True))
+
+    # Keep explicit cleanup for script runs that enforced restrictions.
+    if args.enforce:
+        deactivate_network_block()
+
+    return 0
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a4d6c600e236af3dcaa45caf5cdb6036c843eaee
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,261 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+class InvalidTelemetryPolicyError(ValueError):
+    """Raised when policy configuration is malformed."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+
+    normalized = str(host).strip().lower().rstrip(".")
+    if "://" in normalized:
+        # Caller provided a URL; keep host-only behavior explicit and safe.
+        return ""
+
+    return normalized
+
+
+def _validate_env_overrides(env_overrides: Mapping[str, str]) -> None:
+    for key, value in env_overrides.items():
+        if not isinstance(key, str) or not key.strip():
+            raise InvalidTelemetryPolicyError("Environment override keys must be non-empty strings.")
+        if "=" in key:
+            raise InvalidTelemetryPolicyError(f"Invalid env key '{key}': must not contain '='.")
+        if not isinstance(value, str):
+            raise InvalidTelemetryPolicyError(f"Invalid env value for '{key}': expected string.")
+
+
+def normalize_policy(policy: TelemetryPolicy) -> TelemetryPolicy:
+    """Return a sanitized policy with normalized hosts and validated env overrides."""
+    _validate_env_overrides(policy.env_overrides)
+
+    normalized_hosts = {_normalize_host(host) for host in policy.blocked_hosts}
+    normalized_hosts = {host for host in normalized_hosts if host}
+
+    return TelemetryPolicy(env_overrides=dict(policy.env_overrides), blocked_hosts=normalized_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        normalized = normalize_policy(policy)
+        combined_env.update(normalized.env_overrides)
+        combined_hosts |= normalized.blocked_hosts
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in normalized.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    normalized = normalize_policy(policy)
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= normalized.blocked_hosts
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in normalized.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(normalized.blocked_hosts),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = normalize_policy(policy or TelemetryPolicy())
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = normalize_policy(TelemetryPolicy())
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_cybersecurity.py b/test_telemetry_cybersecurity.py
new file mode 100644
index 0000000000000000000000000000000000000000..3b0e7ceb30212d745e7e42bfad55b0f9e44e026e
--- /dev/null
+++ b/test_telemetry_cybersecurity.py
@@ -0,0 +1,53 @@
+import unittest
+
+from telemetry_cybersecurity import (
+    enforce_and_audit,
+    parse_args,
+    run_egress_probe,
+)
+from telemetry_restrictions import (
+    TelemetryPolicy,
+    activate_network_block,
+    deactivate_network_block,
+)
+
+
+class TelemetryCybersecurityTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_parse_args_defaults_to_no_flags(self):
+        args = parse_args([])
+        self.assertFalse(args.audit)
+        self.assertFalse(args.enforce)
+        self.assertFalse(args.probe)
+
+    def test_run_egress_probe_detects_blocking(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        report = run_egress_probe(policy)
+
+        self.assertEqual(report["total_hosts_tested"], 1)
+        self.assertEqual(report["blocked_hosts"], 1)
+        self.assertTrue(report["all_blocked"])
+        self.assertEqual(report["results"]["segment.io"], "blocked")
+
+    def test_enforce_and_audit_with_probe(self):
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = enforce_and_audit(policy, run_probe=True)
+
+        self.assertIn("audit", report)
+        self.assertIn("probe", report)
+        self.assertTrue(report["audit"]["network_block_active"])
+        self.assertEqual(report["audit"]["network_block_refcount"], 1)
+        self.assertEqual(report["probe"]["results"]["segment.io"], "blocked")
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_cybersecurity.py b/telemetry_cybersecurity.py
new file mode 100644
index 0000000000000000000000000000000000000000..8d4d204a493798b2f39e69ba70c38da67e07f365
--- /dev/null
+++ b/telemetry_cybersecurity.py
@@ -0,0 +1,124 @@
+"""Telemetry cybersecurity runner.
+
+Defensive script to harden a process against common telemetry egress by applying
+validated telemetry policy controls, optionally then launching a target command.
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import os
+import subprocess
+import sys
+from typing import Any, Mapping, Optional, Sequence
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryPolicy,
+    audit_policy_state,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+def _read_json_file(path: str) -> Mapping[str, Any]:
+    with open(path, "r", encoding="utf-8") as f:
+        data = json.load(f)
+    if not isinstance(data, dict):
+        raise InvalidTelemetryPolicyError("Policy JSON root must be an object.")
+    return data
+
+
+def policy_from_mapping(mapping: Mapping[str, Any]) -> TelemetryPolicy:
+    env_overrides = mapping.get("env_overrides", {})
+    blocked_hosts = mapping.get("blocked_hosts", [])
+
+    if not isinstance(env_overrides, dict):
+        raise InvalidTelemetryPolicyError("'env_overrides' must be a JSON object.")
+    if not isinstance(blocked_hosts, (list, set, tuple)):
+        raise InvalidTelemetryPolicyError("'blocked_hosts' must be an array.")
+
+    # Preserve strict validation in normalize_policy.
+    policy = TelemetryPolicy(
+        env_overrides={str(k): v for k, v in env_overrides.items()},
+        blocked_hosts={str(host) for host in blocked_hosts},
+    )
+    return normalize_policy(policy)
+
+
+def load_policy(path: Optional[str]) -> TelemetryPolicy:
+    if not path:
+        return normalize_policy(TelemetryPolicy())
+    return policy_from_mapping(_read_json_file(path))
+
+
+def run_with_policy(
+    policy: TelemetryPolicy,
+    *,
+    command: Optional[Sequence[str]] = None,
+    print_audit: bool = False,
+    block_network: bool = True,
+) -> int:
+    with telemetry_restricted(policy, block_network=block_network):
+        if print_audit:
+            report = audit_policy_state(policy)
+            print(json.dumps(report, indent=2, sort_keys=True))
+
+        if not command:
+            return 0
+
+        completed = subprocess.run(command, env=os.environ.copy(), check=False)
+        return int(completed.returncode)
+
+
+def build_parser() -> argparse.ArgumentParser:
+    parser = argparse.ArgumentParser(
+        description="Apply telemetry cybersecurity policy and optionally run a command."
+    )
+    parser.add_argument(
+        "--policy-json",
+        help="Path to policy JSON file with keys: env_overrides, blocked_hosts.",
+    )
+    parser.add_argument(
+        "--no-network-block",
+        action="store_true",
+        help="Only apply environment-based restrictions (skip host-level blocking).",
+    )
+    parser.add_argument(
+        "--print-audit",
+        action="store_true",
+        help="Print active policy/audit information as JSON.",
+    )
+    parser.add_argument(
+        "command",
+        nargs=argparse.REMAINDER,
+        help="Optional command to run under telemetry restrictions. Prefix with '--'.",
+    )
+    return parser
+
+
+def main(argv: Optional[Sequence[str]] = None) -> int:
+    parser = build_parser()
+    args = parser.parse_args(argv)
+
+    command = args.command
+    if command and command[0] == "--":
+        command = command[1:]
+
+    try:
+        policy = load_policy(args.policy_json)
+    except (OSError, json.JSONDecodeError, InvalidTelemetryPolicyError) as exc:
+        print(f"Failed to load policy: {exc}", file=sys.stderr)
+        return 2
+
+    return run_with_policy(
+        policy,
+        command=command,
+        print_audit=args.print_audit,
+        block_network=not args.no_network_block,
+    )
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a4d6c600e236af3dcaa45caf5cdb6036c843eaee
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,261 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+class InvalidTelemetryPolicyError(ValueError):
+    """Raised when policy configuration is malformed."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+
+    normalized = str(host).strip().lower().rstrip(".")
+    if "://" in normalized:
+        # Caller provided a URL; keep host-only behavior explicit and safe.
+        return ""
+
+    return normalized
+
+
+def _validate_env_overrides(env_overrides: Mapping[str, str]) -> None:
+    for key, value in env_overrides.items():
+        if not isinstance(key, str) or not key.strip():
+            raise InvalidTelemetryPolicyError("Environment override keys must be non-empty strings.")
+        if "=" in key:
+            raise InvalidTelemetryPolicyError(f"Invalid env key '{key}': must not contain '='.")
+        if not isinstance(value, str):
+            raise InvalidTelemetryPolicyError(f"Invalid env value for '{key}': expected string.")
+
+
+def normalize_policy(policy: TelemetryPolicy) -> TelemetryPolicy:
+    """Return a sanitized policy with normalized hosts and validated env overrides."""
+    _validate_env_overrides(policy.env_overrides)
+
+    normalized_hosts = {_normalize_host(host) for host in policy.blocked_hosts}
+    normalized_hosts = {host for host in normalized_hosts if host}
+
+    return TelemetryPolicy(env_overrides=dict(policy.env_overrides), blocked_hosts=normalized_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        normalized = normalize_policy(policy)
+        combined_env.update(normalized.env_overrides)
+        combined_hosts |= normalized.blocked_hosts
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in normalized.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    normalized = normalize_policy(policy)
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= normalized.blocked_hosts
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in normalized.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(normalized.blocked_hosts),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = normalize_policy(policy or TelemetryPolicy())
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = normalize_policy(TelemetryPolicy())
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_cybersecurity.py b/test_telemetry_cybersecurity.py
new file mode 100644
index 0000000000000000000000000000000000000000..416ea5b8db4828a4a2d84d5329c4d1d6302ce1f2
--- /dev/null
+++ b/test_telemetry_cybersecurity.py
@@ -0,0 +1,55 @@
+import json
+import os
+import tempfile
+import unittest
+
+from telemetry_cybersecurity import load_policy, main, policy_from_mapping, run_with_policy
+from telemetry_restrictions import InvalidTelemetryPolicyError, TelemetryPolicy
+
+
+class TelemetryCybersecurityTests(unittest.TestCase):
+    def test_policy_from_mapping(self):
+        policy = policy_from_mapping(
+            {
+                "env_overrides": {"DO_NOT_TRACK": "1"},
+                "blocked_hosts": [" Segment.io ", "https://invalid"],
+            }
+        )
+        self.assertEqual(policy.env_overrides["DO_NOT_TRACK"], "1")
+        self.assertEqual(policy.blocked_hosts, {"segment.io"})
+
+    def test_policy_from_mapping_invalid_env_type(self):
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            policy_from_mapping({"env_overrides": [], "blocked_hosts": []})
+
+    def test_load_policy_from_file(self):
+        with tempfile.NamedTemporaryFile("w", suffix=".json", delete=False) as f:
+            json.dump({"env_overrides": {"X": "1"}, "blocked_hosts": ["sentry.io"]}, f)
+            path = f.name
+
+        try:
+            policy = load_policy(path)
+            self.assertEqual(policy.env_overrides["X"], "1")
+            self.assertEqual(policy.blocked_hosts, {"sentry.io"})
+        finally:
+            os.remove(path)
+
+    def test_run_with_policy_no_command(self):
+        policy = TelemetryPolicy(env_overrides={"TEST_TELEM": "ok"}, blocked_hosts=set())
+        rc = run_with_policy(policy, command=None, print_audit=False, block_network=False)
+        self.assertEqual(rc, 0)
+
+    def test_main_invalid_json(self):
+        with tempfile.NamedTemporaryFile("w", suffix=".json", delete=False) as f:
+            f.write("{not-valid-json")
+            path = f.name
+
+        try:
+            rc = main(["--policy-json", path])
+            self.assertEqual(rc, 2)
+        finally:
+            os.remove(path)
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_cybersecurity_guard.py b/telemetry_cybersecurity_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..7c2c28e25f49090da70696d796477f5ff6dbdc5b
--- /dev/null
+++ b/telemetry_cybersecurity_guard.py
@@ -0,0 +1,99 @@
+"""Cybersecurity-focused telemetry guard utilities.
+
+This script builds on process-local telemetry restrictions to provide:
+- explicit guard setup for secure application startup,
+- audit snapshots for security logging,
+- safe destination checks for outbound hosts.
+"""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from datetime import datetime, timezone
+from typing import Dict, Iterable, List, Optional
+
+from telemetry_restrictions import (
+    TelemetryPolicy,
+    audit_policy_state,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+@dataclass
+class TelemetrySecurityReport:
+    """Serializable telemetry security report."""
+
+    timestamp_utc: str
+    blocked_destination: bool
+    destination_host: str
+    policy_host_count: int
+    active_block_refcount: int
+    env_overrides_active: int
+    details: Dict[str, object] = field(default_factory=dict)
+
+
+class TelemetrySecurityGuard:
+    """Convenience wrapper for runtime telemetry defense checks."""
+
+    def __init__(self, policy: Optional[TelemetryPolicy] = None):
+        self.policy = normalize_policy(policy or TelemetryPolicy())
+
+    def is_destination_blocked(self, host: str) -> bool:
+        """Return True when host is in policy blocked hosts (incl. subdomains)."""
+        normalized_host = host.strip().lower().rstrip(".")
+        if not normalized_host:
+            return False
+
+        for blocked in self.policy.blocked_hosts:
+            if normalized_host == blocked or normalized_host.endswith(f".{blocked}"):
+                return True
+        return False
+
+    def audit_snapshot(self) -> Dict[str, object]:
+        """Current audit snapshot from telemetry restrictions core."""
+        return audit_policy_state(self.policy)
+
+    def build_report(self, destination_host: str) -> TelemetrySecurityReport:
+        """Build structured report for SOC/log ingestion."""
+        snapshot = self.audit_snapshot()
+        env_active_count = sum(1 for v in snapshot["env"].values() if v["active"])
+
+        return TelemetrySecurityReport(
+            timestamp_utc=datetime.now(timezone.utc).isoformat(),
+            blocked_destination=self.is_destination_blocked(destination_host),
+            destination_host=destination_host,
+            policy_host_count=len(self.policy.blocked_hosts),
+            active_block_refcount=int(snapshot["network_block_refcount"]),
+            env_overrides_active=env_active_count,
+            details=snapshot,
+        )
+
+
+def build_policy_with_extra_hosts(extra_hosts: Iterable[str]) -> TelemetryPolicy:
+    """Return policy extended with additional telemetry endpoints to block."""
+    base = normalize_policy(TelemetryPolicy())
+    extended_hosts = set(base.blocked_hosts)
+
+    for host in extra_hosts:
+        candidate = str(host).strip().lower().rstrip(".")
+        if candidate and "://" not in candidate:
+            extended_hosts.add(candidate)
+
+    return TelemetryPolicy(env_overrides=dict(base.env_overrides), blocked_hosts=extended_hosts)
+
+
+def secure_telemetry_context(policy: Optional[TelemetryPolicy] = None):
+    """Helper alias for explicit, readable secure context usage."""
+    return telemetry_restricted(policy=policy, block_network=True)
+
+
+if __name__ == "__main__":
+    guard = TelemetrySecurityGuard()
+    with secure_telemetry_context(guard.policy):
+        report = guard.build_report("api.segment.io")
+
+    print("Telemetry cybersecurity guard active.")
+    print(f"Blocked destination check for '{report.destination_host}': {report.blocked_destination}")
+    print(f"Active env overrides: {report.env_overrides_active}")
+    print(f"Policy blocked hosts: {report.policy_host_count}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_cyber_guard.py b/telemetry_cyber_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..4362412215ffe4b174335f6456ea93155245e85a
--- /dev/null
+++ b/telemetry_cyber_guard.py
@@ -0,0 +1,129 @@
+"""CLI cybersecurity utility for process-local telemetry hardening.
+
+This script uses `telemetry_restrictions` to:
+- apply telemetry-focused environment overrides,
+- optionally activate in-process host blocking,
+- audit active policy state,
+- probe whether a host would be blocked.
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import socket
+from typing import Iterable, List
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+)
+
+
+def parse_csv_hosts(csv: str) -> List[str]:
+    """Parse a comma-separated host string into a normalized list (raw form)."""
+    return [item.strip() for item in csv.split(",") if item.strip()]
+
+
+def build_policy(extra_hosts: Iterable[str], strict_mode: bool) -> TelemetryPolicy:
+    """Build a policy optionally extended for stricter telemetry controls."""
+    base_policy = TelemetryPolicy()
+
+    strict_policy = TelemetryPolicy(
+        env_overrides={
+            "OTEL_SDK_DISABLED": "true",
+            "SCARF_ANALYTICS": "false",
+            "CHECKPOINT_DISABLE_TELEMETRY": "1",
+        },
+        blocked_hosts={
+            "api.segment.io",
+            "api.mixpanel.com",
+            "ingest.sentry.io",
+        },
+    )
+
+    extras_policy = TelemetryPolicy(env_overrides={}, blocked_hosts=set(extra_hosts))
+
+    if strict_mode:
+        return merge_policies(base_policy, strict_policy, extras_policy)
+    return merge_policies(base_policy, extras_policy)
+
+
+def probe_hosts(policy: TelemetryPolicy, hosts: Iterable[str]) -> List[dict]:
+    """Attempt DNS resolution for hosts and report allowed/blocked/error status."""
+    results = []
+
+    activate_network_block(policy)
+    try:
+        for host in hosts:
+            try:
+                socket.getaddrinfo(host, 443)
+            except TelemetryBlockedError as exc:
+                results.append({"host": host, "status": "blocked", "detail": str(exc)})
+            except OSError as exc:
+                # DNS/network issues are environment-dependent; keep visible.
+                results.append({"host": host, "status": "error", "detail": str(exc)})
+            else:
+                results.append({"host": host, "status": "allowed", "detail": "resolved"})
+    finally:
+        deactivate_network_block()
+
+    return results
+
+
+def main() -> int:
+    parser = argparse.ArgumentParser(description="Process-local telemetry cybersecurity guard")
+    parser.add_argument("--strict", action="store_true", help="Enable stricter telemetry defaults")
+    parser.add_argument(
+        "--extra-blocked-hosts",
+        default="",
+        help="Comma-separated hosts to add to blocked host set",
+    )
+    parser.add_argument(
+        "--probe-hosts",
+        default="",
+        help="Comma-separated hosts to probe against the telemetry block",
+    )
+    parser.add_argument("--no-network-block", action="store_true", help="Skip network blocking activation")
+
+    args = parser.parse_args()
+
+    extra_hosts = parse_csv_hosts(args.extra_blocked_hosts)
+    probe_targets = parse_csv_hosts(args.probe_hosts)
+
+    policy = build_policy(extra_hosts=extra_hosts, strict_mode=args.strict)
+
+    apply_env_restrictions(policy)
+
+    if not args.no_network_block:
+        activate_network_block(policy)
+
+    try:
+        report = audit_policy_state(policy)
+        output = {
+            "summary": {
+                "env_overrides": len(policy.env_overrides),
+                "blocked_hosts": len(policy.blocked_hosts),
+                "network_block_active": report["network_block_active"],
+                "network_block_refcount": report["network_block_refcount"],
+            },
+            "audit": report,
+        }
+
+        if probe_targets:
+            output["probe_results"] = probe_hosts(policy, probe_targets)
+
+        print(json.dumps(output, indent=2, sort_keys=True))
+        return 0
+    finally:
+        if not args.no_network_block:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a4d6c600e236af3dcaa45caf5cdb6036c843eaee
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,261 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+class InvalidTelemetryPolicyError(ValueError):
+    """Raised when policy configuration is malformed."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+
+    normalized = str(host).strip().lower().rstrip(".")
+    if "://" in normalized:
+        # Caller provided a URL; keep host-only behavior explicit and safe.
+        return ""
+
+    return normalized
+
+
+def _validate_env_overrides(env_overrides: Mapping[str, str]) -> None:
+    for key, value in env_overrides.items():
+        if not isinstance(key, str) or not key.strip():
+            raise InvalidTelemetryPolicyError("Environment override keys must be non-empty strings.")
+        if "=" in key:
+            raise InvalidTelemetryPolicyError(f"Invalid env key '{key}': must not contain '='.")
+        if not isinstance(value, str):
+            raise InvalidTelemetryPolicyError(f"Invalid env value for '{key}': expected string.")
+
+
+def normalize_policy(policy: TelemetryPolicy) -> TelemetryPolicy:
+    """Return a sanitized policy with normalized hosts and validated env overrides."""
+    _validate_env_overrides(policy.env_overrides)
+
+    normalized_hosts = {_normalize_host(host) for host in policy.blocked_hosts}
+    normalized_hosts = {host for host in normalized_hosts if host}
+
+    return TelemetryPolicy(env_overrides=dict(policy.env_overrides), blocked_hosts=normalized_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        normalized = normalize_policy(policy)
+        combined_env.update(normalized.env_overrides)
+        combined_hosts |= normalized.blocked_hosts
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in normalized.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    normalized = normalize_policy(policy)
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= normalized.blocked_hosts
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in normalized.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(normalized.blocked_hosts),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = normalize_policy(policy or TelemetryPolicy())
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = normalize_policy(TelemetryPolicy())
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_cyber_guard.py b/test_telemetry_cyber_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3b126a6f64f73dbc2897f39a9356afb03afaa11
--- /dev/null
+++ b/test_telemetry_cyber_guard.py
@@ -0,0 +1,33 @@
+import unittest
+
+from telemetry_cyber_guard import build_policy, parse_csv_hosts, probe_hosts
+from telemetry_restrictions import deactivate_network_block
+
+
+class TelemetryCyberGuardTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_parse_csv_hosts(self):
+        hosts = parse_csv_hosts(" segment.io, api.mixpanel.com ,, localhost ")
+        self.assertEqual(hosts, ["segment.io", "api.mixpanel.com", "localhost"])
+
+    def test_build_policy_strict_adds_controls(self):
+        policy = build_policy(extra_hosts=["custom.example"], strict_mode=True)
+
+        self.assertIn("OTEL_SDK_DISABLED", policy.env_overrides)
+        self.assertIn("custom.example", policy.blocked_hosts)
+        self.assertIn("segment.io", policy.blocked_hosts)
+
+    def test_probe_hosts_blocks_and_allows(self):
+        policy = build_policy(extra_hosts=["blocked.example"], strict_mode=False)
+        results = probe_hosts(policy, ["blocked.example", "localhost"])
+
+        by_host = {row["host"]: row for row in results}
+        self.assertEqual(by_host["blocked.example"]["status"], "blocked")
+        self.assertIn(by_host["localhost"]["status"], {"allowed", "error"})
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_guard.rb b/telemetry_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..4528c19c31ca64c9dc63999c9fd99f1e68a0174d
--- /dev/null
+++ b/telemetry_guard.rb
@@ -0,0 +1,221 @@
+# frozen_string_literal: true
+
+# Process-local telemetry hardening for Ruby applications.
+#
+# This module is defensive and non-destructive:
+# - applies telemetry opt-out environment settings,
+# - blocks DNS resolution for configured telemetry hosts,
+# - offers integrity auditing so callers can detect tampering.
+
+require 'digest'
+require 'socket'
+require 'thread'
+
+module TelemetryGuard
+  class TelemetryBlockedError < StandardError; end
+  class InvalidPolicyError < StandardError; end
+
+  DEFAULT_ENV_OVERRIDES = {
+    'DO_NOT_TRACK' => '1',
+    'RUBYOPT' => '',
+    'BUNDLE_DISABLE_VERSION_CHECK' => '1',
+    'SENTRY_DSN' => '',
+    'SEGMENT_WRITE_KEY' => '',
+    'AMPLITUDE_API_KEY' => ''
+  }.freeze
+
+  DEFAULT_BLOCKED_HOSTS = %w[
+    segment.io
+    mixpanel.com
+    sentry.io
+    plausible.io
+    amplitude.com
+  ].freeze
+
+  Policy = Struct.new(:env_overrides, :blocked_hosts, keyword_init: true) do
+    def initialize(env_overrides: DEFAULT_ENV_OVERRIDES, blocked_hosts: DEFAULT_BLOCKED_HOSTS)
+      super(env_overrides: env_overrides, blocked_hosts: blocked_hosts)
+      freeze
+    end
+  end
+
+  @mutex = Mutex.new
+  @refcount = 0
+  @active_hosts = []
+  @original_getaddrinfo = nil
+  @baseline_signature = nil
+
+  class << self
+    def normalize_policy(policy)
+      env = validate_env_overrides(policy.env_overrides)
+      hosts = Array(policy.blocked_hosts).map { |h| normalize_host(h) }.reject(&:empty?).uniq
+      Policy.new(env_overrides: env, blocked_hosts: hosts)
+    end
+
+    def merge_policies(*policies)
+      merged_env = {}
+      merged_hosts = []
+
+      policies.each do |policy|
+        normalized = normalize_policy(policy)
+        merged_env.merge!(normalized.env_overrides)
+        merged_hosts.concat(normalized.blocked_hosts)
+      end
+
+      Policy.new(env_overrides: merged_env, blocked_hosts: merged_hosts.uniq)
+    end
+
+    def apply_env(policy, environment: ENV)
+      normalized = normalize_policy(policy)
+      previous = {}
+
+      normalized.env_overrides.each do |key, value|
+        previous[key] = environment[key] if environment.key?(key)
+        environment[key] = value
+      end
+
+      previous
+    end
+
+    def activate_network_block(policy)
+      normalized = normalize_policy(policy)
+
+      @mutex.synchronize do
+        @active_hosts |= normalized.blocked_hosts
+
+        if @refcount.zero?
+          @original_getaddrinfo = Socket.singleton_class.instance_method(:getaddrinfo)
+          blocked = @active_hosts
+          Socket.singleton_class.define_method(:getaddrinfo) do |host, *args|
+            target = TelemetryGuard.normalize_host(host)
+            if TelemetryGuard.host_blocked?(target, blocked)
+              raise TelemetryBlockedError, "Blocked telemetry destination: #{host}"
+            end
+
+            TelemetryGuard.original_getaddrinfo.bind_call(Socket, host, *args)
+          end
+        end
+
+        @refcount += 1
+      end
+
+      refresh_signature
+      nil
+    end
+
+    def deactivate_network_block
+      @mutex.synchronize do
+        return if @refcount.zero?
+
+        @refcount -= 1
+        return unless @refcount.zero?
+
+        if @original_getaddrinfo
+          Socket.singleton_class.define_method(:getaddrinfo, @original_getaddrinfo)
+        end
+
+        @active_hosts = []
+      end
+
+      refresh_signature
+      nil
+    end
+
+    def with_telemetry_guard(policy, environment: ENV, block_network: true)
+      previous = apply_env(policy, environment: environment)
+      activate_network_block(policy) if block_network
+
+      begin
+        yield normalize_policy(policy)
+      ensure
+        normalize_policy(policy).env_overrides.each_key do |key|
+          if previous.key?(key)
+            environment[key] = previous[key]
+          else
+            environment.delete(key)
+          end
+        end
+        deactivate_network_block if block_network
+      end
+    end
+
+    def audit(policy, environment: ENV)
+      normalized = normalize_policy(policy)
+      env_report = normalized.env_overrides.to_h do |k, expected|
+        actual = environment[k]
+        [k, { expected: expected, actual: actual, active: actual == expected }]
+      end
+
+      {
+        env: env_report,
+        blocked_hosts: normalized.blocked_hosts.sort,
+        active_blocked_hosts: @active_hosts.sort,
+        network_block_active: @refcount.positive?,
+        network_block_refcount: @refcount,
+        integrity_signature: current_signature,
+        integrity_ok: integrity_ok?
+      }
+    end
+
+    def integrity_ok?
+      !@baseline_signature.nil? && @baseline_signature == current_signature
+    end
+
+    def refresh_signature
+      @baseline_signature = current_signature
+    end
+
+    def current_signature
+      Digest::SHA256.hexdigest([
+        @refcount,
+        @active_hosts.sort.join(','),
+        ENV.select { |k, _| DEFAULT_ENV_OVERRIDES.key?(k) }.sort.map { |k, v| "#{k}=#{v}" }.join('|')
+      ].join('||'))
+    end
+
+    def normalize_host(host)
+      return '' if host.nil?
+
+      normalized = host.to_s.strip.downcase.sub(/\.$/, '')
+      return '' if normalized.include?('://')
+
+      normalized
+    end
+
+    def host_blocked?(host, blocked_hosts)
+      return false if host.nil? || host.empty?
+
+      blocked_hosts.any? { |blocked| host == blocked || host.end_with?(".#{blocked}") }
+    end
+
+    def original_getaddrinfo
+      @original_getaddrinfo
+    end
+
+    private
+
+    def validate_env_overrides(env_overrides)
+      env = env_overrides.to_h
+      env.each do |key, value|
+        raise InvalidPolicyError, 'Env key must be non-empty string' unless key.is_a?(String) && !key.strip.empty?
+        raise InvalidPolicyError, "Invalid env key '#{key}'" if key.include?('=')
+        raise InvalidPolicyError, "Env value for '#{key}' must be string" unless value.is_a?(String)
+      end
+      env
+    end
+  end
+end
+
+if $PROGRAM_NAME == __FILE__
+  policy = TelemetryGuard::Policy.new
+  TelemetryGuard.apply_env(policy)
+  TelemetryGuard.activate_network_block(policy)
+  report = TelemetryGuard.audit(policy)
+
+  puts "Telemetry guard active (process-local)."
+  puts "Env active: #{report[:env].count { |_k, v| v[:active] }}/#{report[:env].size}"
+  puts "Blocked hosts: #{report[:blocked_hosts].join(', ')}"
+  puts "Integrity OK: #{report[:integrity_ok]}"
+
+  TelemetryGuard.deactivate_network_block
+end
diff --git a/test_telemetry_guard.rb b/test_telemetry_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..fede5bdbf77cd3133d742ef1b6abd2181bf8470c
--- /dev/null
+++ b/test_telemetry_guard.rb
@@ -0,0 +1,60 @@
+# frozen_string_literal: true
+
+require 'minitest/autorun'
+require_relative 'telemetry_guard'
+
+class TelemetryGuardTest < Minitest::Test
+  def teardown
+    3.times { TelemetryGuard.deactivate_network_block }
+  end
+
+  def test_normalize_policy_filters_invalid_hosts
+    policy = TelemetryGuard::Policy.new(env_overrides: { 'A' => '1' }, blocked_hosts: [' segment.io ', '', 'https://bad'])
+    normalized = TelemetryGuard.normalize_policy(policy)
+
+    assert_equal ['segment.io'], normalized.blocked_hosts
+  end
+
+  def test_apply_env
+    env = { 'DO_NOT_TRACK' => '0' }
+    policy = TelemetryGuard::Policy.new(env_overrides: { 'DO_NOT_TRACK' => '1', 'X' => 'abc' }, blocked_hosts: [])
+
+    previous = TelemetryGuard.apply_env(policy, environment: env)
+
+    assert_equal({ 'DO_NOT_TRACK' => '0' }, previous)
+    assert_equal '1', env['DO_NOT_TRACK']
+    assert_equal 'abc', env['X']
+  end
+
+  def test_network_blocks_exact_and_subdomain
+    policy = TelemetryGuard::Policy.new(env_overrides: {}, blocked_hosts: ['segment.io'])
+    TelemetryGuard.activate_network_block(policy)
+
+    assert_raises(TelemetryGuard::TelemetryBlockedError) { Socket.getaddrinfo('segment.io', 443) }
+    assert_raises(TelemetryGuard::TelemetryBlockedError) { Socket.getaddrinfo('api.segment.io', 443) }
+  end
+
+  def test_merge_policies
+    p1 = TelemetryGuard::Policy.new(env_overrides: { 'A' => '1' }, blocked_hosts: ['segment.io'])
+    p2 = TelemetryGuard::Policy.new(env_overrides: { 'A' => '2', 'B' => '3' }, blocked_hosts: ['sentry.io'])
+
+    merged = TelemetryGuard.merge_policies(p1, p2)
+
+    assert_equal '2', merged.env_overrides['A']
+    assert_equal '3', merged.env_overrides['B']
+    assert_equal %w[segment.io sentry.io].sort, merged.blocked_hosts.sort
+  end
+
+  def test_with_telemetry_guard_restores_environment
+    env = { 'DO_NOT_TRACK' => '0' }
+    policy = TelemetryGuard::Policy.new(env_overrides: { 'DO_NOT_TRACK' => '1', 'TEMP_KEY' => 'v' }, blocked_hosts: [])
+
+    TelemetryGuard.with_telemetry_guard(policy, environment: env, block_network: false) do
+      assert_equal '1', env['DO_NOT_TRACK']
+      assert_equal 'v', env['TEMP_KEY']
+    end
+
+    assert_equal '0', env['DO_NOT_TRACK']
+    refute env.key?('TEMP_KEY')
+  end
+end
diff --git a/test_telemetry_cyber_guard.py b/test_telemetry_cyber_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3b126a6f64f73dbc2897f39a9356afb03afaa11
--- /dev/null
+++ b/test_telemetry_cyber_guard.py
@@ -0,0 +1,33 @@
+import unittest
+
+from telemetry_cyber_guard import build_policy, parse_csv_hosts, probe_hosts
+from telemetry_restrictions import deactivate_network_block
+
+
+class TelemetryCyberGuardTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_parse_csv_hosts(self):
+        hosts = parse_csv_hosts(" segment.io, api.mixpanel.com ,, localhost ")
+        self.assertEqual(hosts, ["segment.io", "api.mixpanel.com", "localhost"])
+
+    def test_build_policy_strict_adds_controls(self):
+        policy = build_policy(extra_hosts=["custom.example"], strict_mode=True)
+
+        self.assertIn("OTEL_SDK_DISABLED", policy.env_overrides)
+        self.assertIn("custom.example", policy.blocked_hosts)
+        self.assertIn("segment.io", policy.blocked_hosts)
+
+    def test_probe_hosts_blocks_and_allows(self):
+        policy = build_policy(extra_hosts=["blocked.example"], strict_mode=False)
+        results = probe_hosts(policy, ["blocked.example", "localhost"])
+
+        by_host = {row["host"]: row for row in results}
+        self.assertEqual(by_host["blocked.example"]["status"], "blocked")
+        self.assertIn(by_host["localhost"]["status"], {"allowed", "error"})
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_cyber_guard.py b/telemetry_cyber_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..4362412215ffe4b174335f6456ea93155245e85a
--- /dev/null
+++ b/telemetry_cyber_guard.py
@@ -0,0 +1,129 @@
+"""CLI cybersecurity utility for process-local telemetry hardening.
+
+This script uses `telemetry_restrictions` to:
+- apply telemetry-focused environment overrides,
+- optionally activate in-process host blocking,
+- audit active policy state,
+- probe whether a host would be blocked.
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import socket
+from typing import Iterable, List
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+)
+
+
+def parse_csv_hosts(csv: str) -> List[str]:
+    """Parse a comma-separated host string into a normalized list (raw form)."""
+    return [item.strip() for item in csv.split(",") if item.strip()]
+
+
+def build_policy(extra_hosts: Iterable[str], strict_mode: bool) -> TelemetryPolicy:
+    """Build a policy optionally extended for stricter telemetry controls."""
+    base_policy = TelemetryPolicy()
+
+    strict_policy = TelemetryPolicy(
+        env_overrides={
+            "OTEL_SDK_DISABLED": "true",
+            "SCARF_ANALYTICS": "false",
+            "CHECKPOINT_DISABLE_TELEMETRY": "1",
+        },
+        blocked_hosts={
+            "api.segment.io",
+            "api.mixpanel.com",
+            "ingest.sentry.io",
+        },
+    )
+
+    extras_policy = TelemetryPolicy(env_overrides={}, blocked_hosts=set(extra_hosts))
+
+    if strict_mode:
+        return merge_policies(base_policy, strict_policy, extras_policy)
+    return merge_policies(base_policy, extras_policy)
+
+
+def probe_hosts(policy: TelemetryPolicy, hosts: Iterable[str]) -> List[dict]:
+    """Attempt DNS resolution for hosts and report allowed/blocked/error status."""
+    results = []
+
+    activate_network_block(policy)
+    try:
+        for host in hosts:
+            try:
+                socket.getaddrinfo(host, 443)
+            except TelemetryBlockedError as exc:
+                results.append({"host": host, "status": "blocked", "detail": str(exc)})
+            except OSError as exc:
+                # DNS/network issues are environment-dependent; keep visible.
+                results.append({"host": host, "status": "error", "detail": str(exc)})
+            else:
+                results.append({"host": host, "status": "allowed", "detail": "resolved"})
+    finally:
+        deactivate_network_block()
+
+    return results
+
+
+def main() -> int:
+    parser = argparse.ArgumentParser(description="Process-local telemetry cybersecurity guard")
+    parser.add_argument("--strict", action="store_true", help="Enable stricter telemetry defaults")
+    parser.add_argument(
+        "--extra-blocked-hosts",
+        default="",
+        help="Comma-separated hosts to add to blocked host set",
+    )
+    parser.add_argument(
+        "--probe-hosts",
+        default="",
+        help="Comma-separated hosts to probe against the telemetry block",
+    )
+    parser.add_argument("--no-network-block", action="store_true", help="Skip network blocking activation")
+
+    args = parser.parse_args()
+
+    extra_hosts = parse_csv_hosts(args.extra_blocked_hosts)
+    probe_targets = parse_csv_hosts(args.probe_hosts)
+
+    policy = build_policy(extra_hosts=extra_hosts, strict_mode=args.strict)
+
+    apply_env_restrictions(policy)
+
+    if not args.no_network_block:
+        activate_network_block(policy)
+
+    try:
+        report = audit_policy_state(policy)
+        output = {
+            "summary": {
+                "env_overrides": len(policy.env_overrides),
+                "blocked_hosts": len(policy.blocked_hosts),
+                "network_block_active": report["network_block_active"],
+                "network_block_refcount": report["network_block_refcount"],
+            },
+            "audit": report,
+        }
+
+        if probe_targets:
+            output["probe_results"] = probe_hosts(policy, probe_targets)
+
+        print(json.dumps(output, indent=2, sort_keys=True))
+        return 0
+    finally:
+        if not args.no_network_block:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a4d6c600e236af3dcaa45caf5cdb6036c843eaee
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,261 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+class InvalidTelemetryPolicyError(ValueError):
+    """Raised when policy configuration is malformed."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+
+    normalized = str(host).strip().lower().rstrip(".")
+    if "://" in normalized:
+        # Caller provided a URL; keep host-only behavior explicit and safe.
+        return ""
+
+    return normalized
+
+
+def _validate_env_overrides(env_overrides: Mapping[str, str]) -> None:
+    for key, value in env_overrides.items():
+        if not isinstance(key, str) or not key.strip():
+            raise InvalidTelemetryPolicyError("Environment override keys must be non-empty strings.")
+        if "=" in key:
+            raise InvalidTelemetryPolicyError(f"Invalid env key '{key}': must not contain '='.")
+        if not isinstance(value, str):
+            raise InvalidTelemetryPolicyError(f"Invalid env value for '{key}': expected string.")
+
+
+def normalize_policy(policy: TelemetryPolicy) -> TelemetryPolicy:
+    """Return a sanitized policy with normalized hosts and validated env overrides."""
+    _validate_env_overrides(policy.env_overrides)
+
+    normalized_hosts = {_normalize_host(host) for host in policy.blocked_hosts}
+    normalized_hosts = {host for host in normalized_hosts if host}
+
+    return TelemetryPolicy(env_overrides=dict(policy.env_overrides), blocked_hosts=normalized_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        normalized = normalize_policy(policy)
+        combined_env.update(normalized.env_overrides)
+        combined_hosts |= normalized.blocked_hosts
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in normalized.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    normalized = normalize_policy(policy)
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= normalized.blocked_hosts
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in normalized.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(normalized.blocked_hosts),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = normalize_policy(policy or TelemetryPolicy())
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = normalize_policy(TelemetryPolicy())
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_guard.rb b/telemetry_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..b4ef695af60bc3c5984bb142cbee6b138ac7a83d
--- /dev/null
+++ b/telemetry_guard.rb
@@ -0,0 +1,227 @@
+# frozen_string_literal: true
+
+# Process-local telemetry hardening utilities for Ruby applications.
+#
+# Safety scope:
+# - Defensive and opt-in.
+# - Does not attempt system-wide or RF/network infrastructure disruption.
+
+require "set"
+require "socket"
+require "thread"
+
+module TelemetryGuard
+  class TelemetryBlockedError < StandardError; end
+  class InvalidPolicyError < StandardError; end
+
+  Policy = Struct.new(:env_overrides, :blocked_hosts, keyword_init: true)
+
+  DEFAULT_ENV_OVERRIDES = {
+    "DO_NOT_TRACK" => "1",
+    "BUNDLE_DISABLE_VERSION_CHECK" => "true",
+    "RUBYGEMS_GEMDEPS" => "-",
+    "SENTRY_DSN" => "",
+    "SEGMENT_WRITE_KEY" => "",
+    "POSTHOG_DISABLED" => "1"
+  }.freeze
+
+  DEFAULT_BLOCKED_HOSTS = Set.new(
+    %w[
+      segment.io
+      mixpanel.com
+      sentry.io
+      plausible.io
+      telemetry.rubygems.org
+      amplitude.com
+      posthog.com
+    ]
+  ).freeze
+
+  class << self
+    def default_policy
+      Policy.new(env_overrides: DEFAULT_ENV_OVERRIDES.dup, blocked_hosts: DEFAULT_BLOCKED_HOSTS.dup)
+    end
+
+    def normalize_policy(policy)
+      validate_env_overrides!(policy.env_overrides)
+
+      normalized_hosts = Array(policy.blocked_hosts).map { |host| normalize_host(host) }.reject(&:empty?).to_set
+
+      Policy.new(env_overrides: policy.env_overrides.dup, blocked_hosts: normalized_hosts)
+    end
+
+    def merge_policies(*policies)
+      env = {}
+      hosts = Set.new
+
+      policies.each do |policy|
+        normalized = normalize_policy(policy)
+        env.merge!(normalized.env_overrides)
+        hosts.merge(normalized.blocked_hosts)
+      end
+
+      Policy.new(env_overrides: env, blocked_hosts: hosts)
+    end
+
+    def apply_env_restrictions!(policy, environment: ENV)
+      normalized = normalize_policy(policy)
+      previous = {}
+
+      normalized.env_overrides.each do |key, value|
+        previous[key] = environment[key] if environment.key?(key)
+        environment[key] = value
+      end
+
+      previous
+    end
+
+    def activate_network_block!(policy)
+      normalized = normalize_policy(policy)
+
+      mutex.synchronize do
+        @current_blocked_hosts.merge(normalized.blocked_hosts)
+
+        if @network_block_refcount.zero?
+          install_socket_guard!
+        end
+
+        @network_block_refcount += 1
+      end
+    end
+
+    def deactivate_network_block!
+      mutex.synchronize do
+        return if @network_block_refcount.zero?
+
+        @network_block_refcount -= 1
+        if @network_block_refcount.zero?
+          uninstall_socket_guard!
+          @current_blocked_hosts = Set.new
+        end
+      end
+    end
+
+    def telemetry_restricted(policy = default_policy, environment: ENV, block_network: true)
+      normalized = normalize_policy(policy)
+      previous = apply_env_restrictions!(normalized, environment: environment)
+      activate_network_block!(normalized) if block_network
+
+      yield normalized
+    ensure
+      normalized.env_overrides.each_key do |key|
+        if previous.key?(key)
+          environment[key] = previous[key]
+        else
+          environment.delete(key)
+        end
+      end
+      deactivate_network_block! if block_network
+    end
+
+    def audit(policy, environment: ENV)
+      normalized = normalize_policy(policy)
+
+      env_state = normalized.env_overrides.each_with_object({}) do |(key, expected), memo|
+        actual = environment[key]
+        memo[key] = { "expected" => expected, "actual" => actual, "active" => actual == expected }
+      end
+
+      mutex.synchronize do
+        {
+          "env" => env_state,
+          "network_block_active" => @network_block_refcount.positive?,
+          "network_block_refcount" => @network_block_refcount,
+          "blocked_hosts" => normalized.blocked_hosts.to_a.sort,
+          "active_blocked_hosts" => @current_blocked_hosts.to_a.sort
+        }
+      end
+    end
+
+    def blocked_host?(host)
+      normalized = normalize_host(host)
+      return false if normalized.empty?
+
+      mutex.synchronize do
+        @current_blocked_hosts.any? do |blocked|
+          normalized == blocked || normalized.end_with?(".#{blocked}")
+        end
+      end
+    end
+
+    private
+
+    def normalize_host(host)
+      return "" if host.nil?
+
+      normalized = host.to_s.strip.downcase.delete_suffix(".")
+      return "" if normalized.include?("://")
+
+      normalized
+    end
+
+    def validate_env_overrides!(env_overrides)
+      env_overrides.each do |key, value|
+        raise InvalidPolicyError, "env key must be non-empty string" unless key.is_a?(String) && !key.strip.empty?
+        raise InvalidPolicyError, "env key must not contain '='" if key.include?("=")
+        raise InvalidPolicyError, "env value must be string" unless value.is_a?(String)
+      end
+    end
+
+    def install_socket_guard!
+      return if @socket_guard_installed
+
+      socket_singleton = class << Socket; self; end
+      socket_singleton.class_eval do
+        alias_method :telemetry_guard_original_getaddrinfo, :getaddrinfo
+
+        def getaddrinfo(host, *args)
+          if TelemetryGuard.blocked_host?(host)
+            raise TelemetryGuard::TelemetryBlockedError, "Blocked telemetry destination: #{host}"
+          end
+
+          telemetry_guard_original_getaddrinfo(host, *args)
+        end
+      end
+
+      @socket_guard_installed = true
+    end
+
+    def uninstall_socket_guard!
+      return unless @socket_guard_installed
+
+      socket_singleton = class << Socket; self; end
+      socket_singleton.class_eval do
+        alias_method :getaddrinfo, :telemetry_guard_original_getaddrinfo
+        remove_method :telemetry_guard_original_getaddrinfo
+      end
+
+      @socket_guard_installed = false
+    end
+
+    def mutex
+      @mutex ||= Mutex.new
+    end
+  end
+
+  @network_block_refcount = 0
+  @current_blocked_hosts = Set.new
+  @socket_guard_installed = false
+end
+
+if $PROGRAM_NAME == __FILE__
+  begin
+    policy = TelemetryGuard.default_policy
+    TelemetryGuard.apply_env_restrictions!(policy)
+    TelemetryGuard.activate_network_block!(policy)
+
+    report = TelemetryGuard.audit(policy)
+    enabled_count = report["env"].count { |_k, details| details["active"] }
+
+    puts "Telemetry guard enabled (Ruby, process-local, opt-in)."
+    puts "Environment overrides active: #{enabled_count}/#{policy.env_overrides.size}"
+    puts "Network block active: #{report['network_block_active']} (refcount=#{report['network_block_refcount']})"
+    puts "Blocked hosts: #{report['active_blocked_hosts'].join(', ')}"
+  ensure
+    TelemetryGuard.deactivate_network_block!
+  end
+end
diff --git a/test_telemetry_guard.rb b/test_telemetry_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..b640e36c7bf477fe44bb612dc404b86f7ae49321
--- /dev/null
+++ b/test_telemetry_guard.rb
@@ -0,0 +1,62 @@
+# frozen_string_literal: true
+
+require "minitest/autorun"
+require_relative "telemetry_guard"
+
+class TelemetryGuardTest < Minitest::Test
+  def teardown
+    3.times { TelemetryGuard.deactivate_network_block! }
+  end
+
+  def test_apply_env_restrictions
+    env = { "DO_NOT_TRACK" => "0", "UNCHANGED" => "yes" }
+    policy = TelemetryGuard::Policy.new(env_overrides: { "DO_NOT_TRACK" => "1", "X" => "abc" }, blocked_hosts: Set.new)
+
+    previous = TelemetryGuard.apply_env_restrictions!(policy, environment: env)
+
+    assert_equal({ "DO_NOT_TRACK" => "0" }, previous)
+    assert_equal("1", env["DO_NOT_TRACK"])
+    assert_equal("abc", env["X"])
+    assert_equal("yes", env["UNCHANGED"])
+  end
+
+  def test_invalid_policy_rejected
+    policy = TelemetryGuard::Policy.new(env_overrides: { "BAD=KEY" => "1" }, blocked_hosts: Set.new)
+    assert_raises(TelemetryGuard::InvalidPolicyError) { TelemetryGuard.normalize_policy(policy) }
+  end
+
+  def test_network_block_blocks_exact_and_subdomain
+    policy = TelemetryGuard::Policy.new(env_overrides: {}, blocked_hosts: Set["segment.io"])
+    TelemetryGuard.activate_network_block!(policy)
+
+    assert_raises(TelemetryGuard::TelemetryBlockedError) { Socket.getaddrinfo("segment.io", 443) }
+    assert_raises(TelemetryGuard::TelemetryBlockedError) { Socket.getaddrinfo("api.segment.io", 443) }
+  end
+
+  def test_merge_and_audit
+    p1 = TelemetryGuard::Policy.new(env_overrides: { "A" => "1" }, blocked_hosts: Set["segment.io"])
+    p2 = TelemetryGuard::Policy.new(env_overrides: { "A" => "2", "B" => "3" }, blocked_hosts: Set["sentry.io"])
+
+    merged = TelemetryGuard.merge_policies(p1, p2)
+    assert_equal("2", merged.env_overrides["A"])
+    assert_equal("3", merged.env_overrides["B"])
+    assert_equal(Set["segment.io", "sentry.io"], merged.blocked_hosts)
+
+    report = TelemetryGuard.audit(merged, environment: { "A" => "2", "B" => "3" })
+    assert report["env"]["A"]["active"]
+    assert report["env"]["B"]["active"]
+  end
+
+  def test_telemetry_restricted_restores_environment
+    env = { "DO_NOT_TRACK" => "0" }
+    policy = TelemetryGuard::Policy.new(env_overrides: { "DO_NOT_TRACK" => "1", "TEMP_KEY" => "v" }, blocked_hosts: Set.new)
+
+    TelemetryGuard.telemetry_restricted(policy, environment: env, block_network: false) do
+      assert_equal("1", env["DO_NOT_TRACK"])
+      assert_equal("v", env["TEMP_KEY"])
+    end
+
+    assert_equal("0", env["DO_NOT_TRACK"])
+    refute_includes(env.keys, "TEMP_KEY")
+  end
+end
diff --git a/telemetry_defense_guard.rb b/telemetry_defense_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..780440b1e61744b0616ebd045ce205fe299aee3e
--- /dev/null
+++ b/telemetry_defense_guard.rb
@@ -0,0 +1,207 @@
+# frozen_string_literal: true
+
+# Process-local telemetry defense guard.
+#
+# This script provides defensive controls:
+# - Telemetry-related environment hardening.
+# - Blocking known telemetry hosts (exact + subdomain).
+# - Policy integrity verification via digest snapshots.
+# - Runtime tamper checks that can be audited.
+#
+# Note: No script can guarantee "entire" anti-tampering at system scope.
+# This implementation is intentionally non-destructive and process-local.
+
+require 'digest'
+require 'json'
+require 'socket'
+require 'thread'
+
+module TelemetryDefense
+  class TamperDetectedError < StandardError; end
+
+  DEFAULT_ENV_OVERRIDES = {
+    'DO_NOT_TRACK' => '1',
+    'PIP_DISABLE_PIP_VERSION_CHECK' => '1',
+    'PIP_NO_PYTHON_VERSION_WARNING' => '1',
+    'NPM_CONFIG_FUND' => 'false',
+    'NPM_CONFIG_AUDIT' => 'false',
+    'YARN_ENABLE_TELEMETRY' => '0',
+    'NEXT_TELEMETRY_DISABLED' => '1',
+    'HF_HUB_DISABLE_TELEMETRY' => '1',
+    'WANDB_DISABLED' => 'true',
+    'SENTRY_DSN' => ''
+  }.freeze
+
+  DEFAULT_BLOCKED_HOSTS = %w[
+    segment.io
+    mixpanel.com
+    sentry.io
+    plausible.io
+    telemetry.pypi.org
+    amplitude.com
+    posthog.com
+  ].freeze
+
+  class Policy
+    attr_reader :env_overrides, :blocked_hosts
+
+    def initialize(env_overrides: DEFAULT_ENV_OVERRIDES, blocked_hosts: DEFAULT_BLOCKED_HOSTS)
+      @env_overrides = normalize_env(env_overrides)
+      @blocked_hosts = normalize_hosts(blocked_hosts)
+      freeze
+    end
+
+    def snapshot_digest
+      serialized = JSON.generate(
+        env_overrides: @env_overrides.sort.to_h,
+        blocked_hosts: @blocked_hosts.sort
+      )
+      Digest::SHA256.hexdigest(serialized)
+    end
+
+    private
+
+    def normalize_env(env)
+      normalized = {}
+      env.each do |k, v|
+        key = k.to_s.strip
+        raise ArgumentError, 'empty env key' if key.empty?
+        raise ArgumentError, "invalid env key: #{key}" if key.include?('=')
+
+        normalized[key] = v.to_s
+      end
+      normalized.freeze
+    end
+
+    def normalize_hosts(hosts)
+      clean = hosts.map { |h| normalize_host(h) }.compact.uniq
+      clean.freeze
+    end
+
+    def normalize_host(host)
+      raw = host.to_s.strip.downcase.sub(/\.+\z/, '')
+      return nil if raw.empty?
+      return nil if raw.include?('://')
+
+      raw
+    end
+  end
+
+  class Guard
+    def initialize(policy: Policy.new)
+      @policy = policy
+      @expected_digest = policy.snapshot_digest
+      @env_previous = {}
+      @active = false
+      @mutex = Mutex.new
+    end
+
+    def enable!
+      @mutex.synchronize do
+        verify_policy_integrity!
+        return if @active
+
+        @policy.env_overrides.each do |k, v|
+          @env_previous[k] = ENV[k] if ENV.key?(k)
+          ENV[k] = v
+        end
+
+        @active = true
+      end
+    end
+
+    def disable!
+      @mutex.synchronize do
+        return unless @active
+
+        @policy.env_overrides.each_key do |k|
+          if @env_previous.key?(k)
+            ENV[k] = @env_previous[k]
+          else
+            ENV.delete(k)
+          end
+        end
+
+        @env_previous.clear
+        @active = false
+      end
+    end
+
+    def active?
+      @active
+    end
+
+    def blocked_host?(host)
+      normalized = normalize_host(host)
+      return false if normalized.nil?
+
+      @policy.blocked_hosts.any? do |blocked|
+        normalized == blocked || normalized.end_with?(".#{blocked}")
+      end
+    end
+
+    def resolve_host(host, port = 443)
+      raise TamperDetectedError, 'policy tampering detected' unless policy_integrity_ok?
+      raise TamperDetectedError, "blocked telemetry destination: #{host}" if blocked_host?(host)
+
+      Addrinfo.getaddrinfo(host, port)
+    end
+
+    def audit
+      env_status = {}
+      @policy.env_overrides.each do |k, expected|
+        actual = ENV[k]
+        env_status[k] = {
+          expected: expected,
+          actual: actual,
+          active: actual == expected
+        }
+      end
+
+      {
+        active: @active,
+        policy_digest: @policy.snapshot_digest,
+        digest_matches: policy_integrity_ok?,
+        blocked_hosts: @policy.blocked_hosts,
+        env: env_status
+      }
+    end
+
+    def verify_policy_integrity!
+      return if policy_integrity_ok?
+
+      raise TamperDetectedError, 'policy digest mismatch'
+    end
+
+    private
+
+    def policy_integrity_ok?
+      @policy.snapshot_digest == @expected_digest
+    end
+
+    def normalize_host(host)
+      raw = host.to_s.strip.downcase.sub(/\.+\z/, '')
+      return nil if raw.empty? || raw.include?('://')
+
+      raw
+    end
+  end
+end
+
+if $PROGRAM_NAME == __FILE__
+  guard = TelemetryDefense::Guard.new
+  guard.enable!
+
+  report = guard.audit
+  enabled_count = report[:env].values.count { |v| v[:active] }
+
+  puts JSON.pretty_generate(
+    summary: {
+      active: report[:active],
+      env_overrides_active: "#{enabled_count}/#{report[:env].size}",
+      blocked_hosts: report[:blocked_hosts].size,
+      digest_matches: report[:digest_matches]
+    },
+    audit: report
+  )
+end
diff --git a/test_telemetry_defense_guard.rb b/test_telemetry_defense_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..ba0fc5fc1404f7cc574ae2c3193262964fffeb1d
--- /dev/null
+++ b/test_telemetry_defense_guard.rb
@@ -0,0 +1,71 @@
+# frozen_string_literal: true
+
+require 'minitest/autorun'
+require_relative 'telemetry_defense_guard'
+
+class TelemetryDefenseGuardTest < Minitest::Test
+  def teardown
+    %w[DO_NOT_TRACK NPM_CONFIG_FUND].each { |k| ENV.delete(k) }
+  end
+
+  def test_policy_normalization_and_digest
+    policy = TelemetryDefense::Policy.new(
+      env_overrides: { ' A ' => 1 },
+      blocked_hosts: [' Segment.io ', 'https://bad', '', 'segment.io']
+    )
+
+    assert_equal({ 'A' => '1' }, policy.env_overrides)
+    assert_equal(['segment.io'], policy.blocked_hosts)
+    refute_nil(policy.snapshot_digest)
+  end
+
+  def test_enable_and_disable_restore_environment
+    policy = TelemetryDefense::Policy.new(env_overrides: { 'DO_NOT_TRACK' => '1' }, blocked_hosts: [])
+    guard = TelemetryDefense::Guard.new(policy: policy)
+
+    ENV['DO_NOT_TRACK'] = '0'
+    guard.enable!
+    assert_equal('1', ENV['DO_NOT_TRACK'])
+    assert(guard.active?)
+
+    guard.disable!
+    assert_equal('0', ENV['DO_NOT_TRACK'])
+    refute(guard.active?)
+  end
+
+  def test_blocked_host_matching_exact_and_subdomain
+    policy = TelemetryDefense::Policy.new(env_overrides: {}, blocked_hosts: ['segment.io'])
+    guard = TelemetryDefense::Guard.new(policy: policy)
+
+    assert(guard.blocked_host?('segment.io'))
+    assert(guard.blocked_host?('api.segment.io'))
+    refute(guard.blocked_host?('localhost'))
+  end
+
+  def test_resolve_host_blocks_telemetry_destination
+    policy = TelemetryDefense::Policy.new(env_overrides: {}, blocked_hosts: ['segment.io'])
+    guard = TelemetryDefense::Guard.new(policy: policy)
+
+    assert_raises(TelemetryDefense::TamperDetectedError) do
+      guard.resolve_host('segment.io', 443)
+    end
+  end
+
+  def test_audit_reports_active_env_values
+    policy = TelemetryDefense::Policy.new(
+      env_overrides: { 'DO_NOT_TRACK' => '1', 'NPM_CONFIG_FUND' => 'false' },
+      blocked_hosts: ['segment.io']
+    )
+    guard = TelemetryDefense::Guard.new(policy: policy)
+
+    guard.enable!
+    report = guard.audit
+
+    assert_equal(true, report[:active])
+    assert_equal(true, report[:digest_matches])
+    assert_equal(true, report[:env]['DO_NOT_TRACK'][:active])
+    assert_equal(true, report[:env]['NPM_CONFIG_FUND'][:active])
+  ensure
+    guard.disable!
+  end
+end
diff --git a/telemetry_defense_guard.rb b/telemetry_defense_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..b996a62f1c373d1391eab02ae4466f6ecee7dd10
--- /dev/null
+++ b/telemetry_defense_guard.rb
@@ -0,0 +1,280 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+# Defensive, process-local telemetry hardening for Ruby runtimes.
+#
+# What this does:
+# - Enforces telemetry opt-out environment variables.
+# - Blocks DNS resolution to configured telemetry hosts/subdomains.
+# - Runs tamper watchdog checks for env + network hook integrity.
+# - Emits tamper events to an append-only local log.
+#
+# What this does NOT do:
+# - It cannot guarantee global/system-wide prevention by itself.
+# - It only protects the current process unless integrated by launcher/service.
+
+require 'digest'
+require 'json'
+require 'socket'
+require 'thread'
+require 'time'
+
+module TelemetryDefenseGuard
+  class TelemetryBlockedError < StandardError; end
+
+  class TamperDetectedError < StandardError; end
+
+  DEFAULT_ENV_OVERRIDES = {
+    'DO_NOT_TRACK' => '1',
+    'OTEL_SDK_DISABLED' => 'true',
+    'CHECKPOINT_DISABLE_TELEMETRY' => '1',
+    'SENTRY_DSN' => '',
+    'SEGMENT_WRITE_KEY' => '',
+    'AMPLITUDE_API_KEY' => '',
+    'POSTHOG_DISABLED' => '1'
+  }.freeze
+
+  DEFAULT_BLOCKED_HOSTS = %w[
+    segment.io
+    mixpanel.com
+    sentry.io
+    plausible.io
+    amplitude.com
+    posthog.com
+    telemetry.pypi.org
+  ].freeze
+
+  State = Struct.new(
+    :env_before,
+    :policy,
+    :original_socket_method,
+    :network_active,
+    :watchdog_thread,
+    :watchdog_stop,
+    :lock,
+    keyword_init: true
+  )
+
+  module_function
+
+  def build_policy(env_overrides: {}, blocked_hosts: [])
+    merged_env = DEFAULT_ENV_OVERRIDES.merge(stringify_hash(env_overrides))
+    merged_hosts = (DEFAULT_BLOCKED_HOSTS + blocked_hosts.map { |h| normalize_host(h) }).reject(&:empty?).uniq
+
+    {
+      env_overrides: merged_env.freeze,
+      blocked_hosts: merged_hosts.freeze,
+      integrity_hash: Digest::SHA256.hexdigest(JSON.generate({ env: merged_env, hosts: merged_hosts }))
+    }.freeze
+  end
+
+  def activate!(policy: build_policy, tamper_log: 'telemetry_tamper.log', watchdog_interval: 0.5)
+    state = State.new(
+      env_before: {},
+      policy: policy,
+      original_socket_method: Socket.method(:getaddrinfo),
+      network_active: false,
+      watchdog_stop: false,
+      lock: Mutex.new
+    )
+
+    enforce_env!(state)
+    install_network_block!(state)
+    start_watchdog!(state, tamper_log: tamper_log, interval: watchdog_interval)
+    trap_signals!(state, tamper_log: tamper_log)
+
+    state
+  end
+
+  def deactivate!(state)
+    state.lock.synchronize do
+      restore_env!(state)
+      restore_network_block!(state)
+      stop_watchdog!(state)
+    end
+  end
+
+  def audit(state)
+    env_status = {}
+    state.policy[:env_overrides].each do |k, expected|
+      actual = ENV[k]
+      env_status[k] = { expected: expected, actual: actual, active: (actual == expected) }
+    end
+
+    {
+      env: env_status,
+      blocked_hosts: state.policy[:blocked_hosts],
+      network_block_active: state.network_active,
+      policy_integrity_hash: state.policy[:integrity_hash]
+    }
+  end
+
+  def probe_host(host)
+    Socket.getaddrinfo(host, 443)
+    { host: host, status: 'allowed' }
+  rescue TelemetryBlockedError => e
+    { host: host, status: 'blocked', detail: e.message }
+  rescue StandardError => e
+    { host: host, status: 'error', detail: e.message }
+  end
+
+  def run_cli!
+    strict_hosts = (ENV['TDG_EXTRA_BLOCKED_HOSTS'] || '').split(',').map(&:strip).reject(&:empty?)
+    policy = build_policy(blocked_hosts: strict_hosts)
+    state = activate!(policy: policy)
+
+    at_exit { deactivate!(state) }
+
+    output = {
+      summary: {
+        blocked_hosts: policy[:blocked_hosts].length,
+        env_overrides: policy[:env_overrides].length,
+        network_block_active: state.network_active
+      },
+      audit: audit(state)
+    }
+
+    probe = (ENV['TDG_PROBE_HOSTS'] || '').split(',').map(&:strip).reject(&:empty?)
+    output[:probe_results] = probe.map { |h| probe_host(h) } unless probe.empty?
+
+    puts JSON.pretty_generate(output)
+  end
+
+  def enforce_env!(state)
+    state.policy[:env_overrides].each do |key, value|
+      state.env_before[key] = ENV[key] if ENV.key?(key)
+      ENV[key] = value
+    end
+  end
+  private_class_method :enforce_env!
+
+  def restore_env!(state)
+    state.policy[:env_overrides].each_key do |key|
+      if state.env_before.key?(key)
+        ENV[key] = state.env_before[key]
+      else
+        ENV.delete(key)
+      end
+    end
+  end
+  private_class_method :restore_env!
+
+  def install_network_block!(state)
+    return if state.network_active
+
+    blocked = state.policy[:blocked_hosts]
+
+    Socket.singleton_class.class_eval do
+      define_method(:getaddrinfo) do |host, *args|
+        normalized = TelemetryDefenseGuard.normalize_host(host)
+        if TelemetryDefenseGuard.blocked?(normalized, blocked)
+          raise TelemetryDefenseGuard::TelemetryBlockedError, "Blocked telemetry destination: #{host}"
+        end
+
+        Socket.method(:__tdg_original_getaddrinfo).call(host, *args)
+      end
+    end
+
+    Socket.singleton_class.class_eval do
+      define_method(:__tdg_original_getaddrinfo, &state.original_socket_method)
+    end
+
+    state.network_active = true
+  end
+  private_class_method :install_network_block!
+
+  def restore_network_block!(state)
+    return unless state.network_active
+
+    original = state.original_socket_method
+    Socket.singleton_class.class_eval do
+      define_method(:getaddrinfo, &original)
+      remove_method(:__tdg_original_getaddrinfo) if method_defined?(:__tdg_original_getaddrinfo)
+    end
+
+    state.network_active = false
+  end
+  private_class_method :restore_network_block!
+
+  def start_watchdog!(state, tamper_log:, interval:)
+    state.watchdog_thread = Thread.new do
+      Thread.current.abort_on_exception = false
+
+      until state.watchdog_stop
+        begin
+          verify_integrity!(state)
+        rescue TamperDetectedError => e
+          append_tamper_log(tamper_log, e.message)
+        end
+        sleep(interval)
+      end
+    end
+  end
+  private_class_method :start_watchdog!
+
+  def stop_watchdog!(state)
+    return unless state.watchdog_thread
+
+    state.watchdog_stop = true
+    state.watchdog_thread.join(1)
+    state.watchdog_thread = nil
+  end
+  private_class_method :stop_watchdog!
+
+  def verify_integrity!(state)
+    state.policy[:env_overrides].each do |k, v|
+      next if ENV[k] == v
+
+      ENV[k] = v
+      raise TamperDetectedError, "Env override tampered and restored: #{k}"
+    end
+
+    unless Socket.method(:getaddrinfo).owner == Socket.singleton_class
+      raise TamperDetectedError, 'Socket.getaddrinfo hook tampered'
+    end
+  end
+  private_class_method :verify_integrity!
+
+  def trap_signals!(state, tamper_log:)
+    %w[INT TERM].each do |sig|
+      Signal.trap(sig) do
+        append_tamper_log(tamper_log, "Received signal #{sig}; shutting down guard")
+        deactivate!(state)
+        exit(0)
+      end
+    end
+  rescue ArgumentError
+    # Signal unavailable on current platform/runtime.
+  end
+  private_class_method :trap_signals!
+
+  def append_tamper_log(path, message)
+    File.open(path, 'a') do |f|
+      f.puts("#{Time.now.utc.iso8601} #{message}")
+    end
+  rescue StandardError
+    nil
+  end
+  private_class_method :append_tamper_log
+
+  def blocked?(normalized_host, blocked_hosts)
+    blocked_hosts.any? do |blocked|
+      normalized_host == blocked || normalized_host.end_with?(".#{blocked}")
+    end
+  end
+  module_function :blocked?
+
+  def normalize_host(host)
+    return '' if host.nil?
+
+    host.to_s.strip.downcase.sub(/\.+\z/, '')
+  end
+  module_function :normalize_host
+
+  def stringify_hash(h)
+    h.each_with_object({}) { |(k, v), acc| acc[k.to_s] = v.to_s }
+  end
+  private_class_method :stringify_hash
+end
+
+TelemetryDefenseGuard.run_cli! if $PROGRAM_NAME == __FILE__
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_cyber_guard.py b/telemetry_cyber_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..4362412215ffe4b174335f6456ea93155245e85a
--- /dev/null
+++ b/telemetry_cyber_guard.py
@@ -0,0 +1,129 @@
+"""CLI cybersecurity utility for process-local telemetry hardening.
+
+This script uses `telemetry_restrictions` to:
+- apply telemetry-focused environment overrides,
+- optionally activate in-process host blocking,
+- audit active policy state,
+- probe whether a host would be blocked.
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import socket
+from typing import Iterable, List
+
+from telemetry_restrictions import (
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+)
+
+
+def parse_csv_hosts(csv: str) -> List[str]:
+    """Parse a comma-separated host string into a normalized list (raw form)."""
+    return [item.strip() for item in csv.split(",") if item.strip()]
+
+
+def build_policy(extra_hosts: Iterable[str], strict_mode: bool) -> TelemetryPolicy:
+    """Build a policy optionally extended for stricter telemetry controls."""
+    base_policy = TelemetryPolicy()
+
+    strict_policy = TelemetryPolicy(
+        env_overrides={
+            "OTEL_SDK_DISABLED": "true",
+            "SCARF_ANALYTICS": "false",
+            "CHECKPOINT_DISABLE_TELEMETRY": "1",
+        },
+        blocked_hosts={
+            "api.segment.io",
+            "api.mixpanel.com",
+            "ingest.sentry.io",
+        },
+    )
+
+    extras_policy = TelemetryPolicy(env_overrides={}, blocked_hosts=set(extra_hosts))
+
+    if strict_mode:
+        return merge_policies(base_policy, strict_policy, extras_policy)
+    return merge_policies(base_policy, extras_policy)
+
+
+def probe_hosts(policy: TelemetryPolicy, hosts: Iterable[str]) -> List[dict]:
+    """Attempt DNS resolution for hosts and report allowed/blocked/error status."""
+    results = []
+
+    activate_network_block(policy)
+    try:
+        for host in hosts:
+            try:
+                socket.getaddrinfo(host, 443)
+            except TelemetryBlockedError as exc:
+                results.append({"host": host, "status": "blocked", "detail": str(exc)})
+            except OSError as exc:
+                # DNS/network issues are environment-dependent; keep visible.
+                results.append({"host": host, "status": "error", "detail": str(exc)})
+            else:
+                results.append({"host": host, "status": "allowed", "detail": "resolved"})
+    finally:
+        deactivate_network_block()
+
+    return results
+
+
+def main() -> int:
+    parser = argparse.ArgumentParser(description="Process-local telemetry cybersecurity guard")
+    parser.add_argument("--strict", action="store_true", help="Enable stricter telemetry defaults")
+    parser.add_argument(
+        "--extra-blocked-hosts",
+        default="",
+        help="Comma-separated hosts to add to blocked host set",
+    )
+    parser.add_argument(
+        "--probe-hosts",
+        default="",
+        help="Comma-separated hosts to probe against the telemetry block",
+    )
+    parser.add_argument("--no-network-block", action="store_true", help="Skip network blocking activation")
+
+    args = parser.parse_args()
+
+    extra_hosts = parse_csv_hosts(args.extra_blocked_hosts)
+    probe_targets = parse_csv_hosts(args.probe_hosts)
+
+    policy = build_policy(extra_hosts=extra_hosts, strict_mode=args.strict)
+
+    apply_env_restrictions(policy)
+
+    if not args.no_network_block:
+        activate_network_block(policy)
+
+    try:
+        report = audit_policy_state(policy)
+        output = {
+            "summary": {
+                "env_overrides": len(policy.env_overrides),
+                "blocked_hosts": len(policy.blocked_hosts),
+                "network_block_active": report["network_block_active"],
+                "network_block_refcount": report["network_block_refcount"],
+            },
+            "audit": report,
+        }
+
+        if probe_targets:
+            output["probe_results"] = probe_hosts(policy, probe_targets)
+
+        print(json.dumps(output, indent=2, sort_keys=True))
+        return 0
+    finally:
+        if not args.no_network_block:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/telemetry_data_hygiene.rb b/telemetry_data_hygiene.rb
new file mode 100644
index 0000000000000000000000000000000000000000..a999c8ea2ea59c5a1dfb0186609a5171fefa1573
--- /dev/null
+++ b/telemetry_data_hygiene.rb
@@ -0,0 +1,149 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+# Safe telemetry data hygiene utility.
+#
+# Purpose:
+# - Remove low-quality telemetry records (placeholder/placebo/test rows)
+# - Redact sensitive-like fields from retained records
+# - Operate only on caller-provided files (no system-wide deletion)
+#
+# Usage:
+#   ruby telemetry_data_hygiene.rb --input in.jsonl --output out.jsonl --report report.json
+#   ruby telemetry_data_hygiene.rb --input in.jsonl --output out.jsonl --dry-run
+
+require 'json'
+require 'optparse'
+require 'time'
+
+module TelemetryDataHygiene
+  PLACEHOLDER_MARKERS = %w[
+    placeholder
+    placebo
+    dummy
+    synthetic
+    mock
+    test_record
+  ].freeze
+
+  REDACT_FIELDS = %w[
+    biometric_signature
+    neural_pattern
+    dna_hash
+    private_notes
+  ].freeze
+
+  module_function
+
+  def marker_record?(record)
+    blob = [
+      record['type'],
+      record['category'],
+      record['source'],
+      Array(record['tags']).join(' '),
+      record['label'],
+      record['notes']
+    ].compact.join(' ').downcase
+
+    PLACEHOLDER_MARKERS.any? { |marker| blob.include?(marker) }
+  end
+
+  def suspicious_capability_record?(record)
+    capability_fields = %w[power_transfer power_extraction capability_drain human_override]
+    capability_fields.any? do |field|
+      value = record[field]
+      value == true || value.to_s.downcase == 'true'
+    end
+  end
+
+  def redact_record(record)
+    sanitized = record.dup
+    REDACT_FIELDS.each do |field|
+      sanitized[field] = '[REDACTED]' if sanitized.key?(field)
+    end
+    sanitized
+  end
+
+  def process_records(records)
+    kept = []
+    dropped = []
+
+    records.each do |record|
+      if marker_record?(record)
+        dropped << { reason: 'placeholder_or_placebo_marker', id: record['id'] }
+        next
+      end
+
+      if suspicious_capability_record?(record)
+        dropped << { reason: 'suspicious_capability_flag', id: record['id'] }
+        next
+      end
+
+      kept << redact_record(record)
+    end
+
+    [kept, dropped]
+  end
+
+  def load_jsonl(path)
+    File.readlines(path, chomp: true).reject(&:empty?).map { |line| JSON.parse(line) }
+  end
+
+  def write_jsonl(path, rows)
+    File.open(path, 'w') do |f|
+      rows.each { |row| f.puts(JSON.generate(row)) }
+    end
+  end
+
+  def run!(input:, output:, report_path: nil, dry_run: false)
+    records = load_jsonl(input)
+    kept, dropped = process_records(records)
+
+    write_jsonl(output, kept) unless dry_run
+
+    report = {
+      timestamp_utc: Time.now.utc.iso8601,
+      input_records: records.length,
+      output_records: kept.length,
+      dropped_records: dropped.length,
+      dropped_reasons: dropped.group_by { |r| r[:reason] }.transform_values(&:length),
+      dropped_ids: dropped.map { |r| r[:id] }.compact
+    }
+
+    File.write(report_path, JSON.pretty_generate(report)) if report_path
+
+    report
+  end
+end
+
+if $PROGRAM_NAME == __FILE__
+  options = {
+    dry_run: false,
+    report_path: nil
+  }
+
+  parser = OptionParser.new do |opts|
+    opts.banner = 'Usage: telemetry_data_hygiene.rb --input INPUT --output OUTPUT [options]'
+
+    opts.on('--input PATH', 'Input JSONL path') { |v| options[:input] = v }
+    opts.on('--output PATH', 'Output JSONL path') { |v| options[:output] = v }
+    opts.on('--report PATH', 'Write JSON report to file') { |v| options[:report_path] = v }
+    opts.on('--dry-run', 'Do not write output data') { options[:dry_run] = true }
+  end
+
+  parser.parse!
+
+  unless options[:input] && options[:output]
+    warn parser.to_s
+    exit(1)
+  end
+
+  report = TelemetryDataHygiene.run!(
+    input: options[:input],
+    output: options[:output],
+    report_path: options[:report_path],
+    dry_run: options[:dry_run]
+  )
+
+  puts JSON.pretty_generate(report)
+end
diff --git a/telemetry_defense_guard.rb b/telemetry_defense_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..b996a62f1c373d1391eab02ae4466f6ecee7dd10
--- /dev/null
+++ b/telemetry_defense_guard.rb
@@ -0,0 +1,280 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+# Defensive, process-local telemetry hardening for Ruby runtimes.
+#
+# What this does:
+# - Enforces telemetry opt-out environment variables.
+# - Blocks DNS resolution to configured telemetry hosts/subdomains.
+# - Runs tamper watchdog checks for env + network hook integrity.
+# - Emits tamper events to an append-only local log.
+#
+# What this does NOT do:
+# - It cannot guarantee global/system-wide prevention by itself.
+# - It only protects the current process unless integrated by launcher/service.
+
+require 'digest'
+require 'json'
+require 'socket'
+require 'thread'
+require 'time'
+
+module TelemetryDefenseGuard
+  class TelemetryBlockedError < StandardError; end
+
+  class TamperDetectedError < StandardError; end
+
+  DEFAULT_ENV_OVERRIDES = {
+    'DO_NOT_TRACK' => '1',
+    'OTEL_SDK_DISABLED' => 'true',
+    'CHECKPOINT_DISABLE_TELEMETRY' => '1',
+    'SENTRY_DSN' => '',
+    'SEGMENT_WRITE_KEY' => '',
+    'AMPLITUDE_API_KEY' => '',
+    'POSTHOG_DISABLED' => '1'
+  }.freeze
+
+  DEFAULT_BLOCKED_HOSTS = %w[
+    segment.io
+    mixpanel.com
+    sentry.io
+    plausible.io
+    amplitude.com
+    posthog.com
+    telemetry.pypi.org
+  ].freeze
+
+  State = Struct.new(
+    :env_before,
+    :policy,
+    :original_socket_method,
+    :network_active,
+    :watchdog_thread,
+    :watchdog_stop,
+    :lock,
+    keyword_init: true
+  )
+
+  module_function
+
+  def build_policy(env_overrides: {}, blocked_hosts: [])
+    merged_env = DEFAULT_ENV_OVERRIDES.merge(stringify_hash(env_overrides))
+    merged_hosts = (DEFAULT_BLOCKED_HOSTS + blocked_hosts.map { |h| normalize_host(h) }).reject(&:empty?).uniq
+
+    {
+      env_overrides: merged_env.freeze,
+      blocked_hosts: merged_hosts.freeze,
+      integrity_hash: Digest::SHA256.hexdigest(JSON.generate({ env: merged_env, hosts: merged_hosts }))
+    }.freeze
+  end
+
+  def activate!(policy: build_policy, tamper_log: 'telemetry_tamper.log', watchdog_interval: 0.5)
+    state = State.new(
+      env_before: {},
+      policy: policy,
+      original_socket_method: Socket.method(:getaddrinfo),
+      network_active: false,
+      watchdog_stop: false,
+      lock: Mutex.new
+    )
+
+    enforce_env!(state)
+    install_network_block!(state)
+    start_watchdog!(state, tamper_log: tamper_log, interval: watchdog_interval)
+    trap_signals!(state, tamper_log: tamper_log)
+
+    state
+  end
+
+  def deactivate!(state)
+    state.lock.synchronize do
+      restore_env!(state)
+      restore_network_block!(state)
+      stop_watchdog!(state)
+    end
+  end
+
+  def audit(state)
+    env_status = {}
+    state.policy[:env_overrides].each do |k, expected|
+      actual = ENV[k]
+      env_status[k] = { expected: expected, actual: actual, active: (actual == expected) }
+    end
+
+    {
+      env: env_status,
+      blocked_hosts: state.policy[:blocked_hosts],
+      network_block_active: state.network_active,
+      policy_integrity_hash: state.policy[:integrity_hash]
+    }
+  end
+
+  def probe_host(host)
+    Socket.getaddrinfo(host, 443)
+    { host: host, status: 'allowed' }
+  rescue TelemetryBlockedError => e
+    { host: host, status: 'blocked', detail: e.message }
+  rescue StandardError => e
+    { host: host, status: 'error', detail: e.message }
+  end
+
+  def run_cli!
+    strict_hosts = (ENV['TDG_EXTRA_BLOCKED_HOSTS'] || '').split(',').map(&:strip).reject(&:empty?)
+    policy = build_policy(blocked_hosts: strict_hosts)
+    state = activate!(policy: policy)
+
+    at_exit { deactivate!(state) }
+
+    output = {
+      summary: {
+        blocked_hosts: policy[:blocked_hosts].length,
+        env_overrides: policy[:env_overrides].length,
+        network_block_active: state.network_active
+      },
+      audit: audit(state)
+    }
+
+    probe = (ENV['TDG_PROBE_HOSTS'] || '').split(',').map(&:strip).reject(&:empty?)
+    output[:probe_results] = probe.map { |h| probe_host(h) } unless probe.empty?
+
+    puts JSON.pretty_generate(output)
+  end
+
+  def enforce_env!(state)
+    state.policy[:env_overrides].each do |key, value|
+      state.env_before[key] = ENV[key] if ENV.key?(key)
+      ENV[key] = value
+    end
+  end
+  private_class_method :enforce_env!
+
+  def restore_env!(state)
+    state.policy[:env_overrides].each_key do |key|
+      if state.env_before.key?(key)
+        ENV[key] = state.env_before[key]
+      else
+        ENV.delete(key)
+      end
+    end
+  end
+  private_class_method :restore_env!
+
+  def install_network_block!(state)
+    return if state.network_active
+
+    blocked = state.policy[:blocked_hosts]
+
+    Socket.singleton_class.class_eval do
+      define_method(:getaddrinfo) do |host, *args|
+        normalized = TelemetryDefenseGuard.normalize_host(host)
+        if TelemetryDefenseGuard.blocked?(normalized, blocked)
+          raise TelemetryDefenseGuard::TelemetryBlockedError, "Blocked telemetry destination: #{host}"
+        end
+
+        Socket.method(:__tdg_original_getaddrinfo).call(host, *args)
+      end
+    end
+
+    Socket.singleton_class.class_eval do
+      define_method(:__tdg_original_getaddrinfo, &state.original_socket_method)
+    end
+
+    state.network_active = true
+  end
+  private_class_method :install_network_block!
+
+  def restore_network_block!(state)
+    return unless state.network_active
+
+    original = state.original_socket_method
+    Socket.singleton_class.class_eval do
+      define_method(:getaddrinfo, &original)
+      remove_method(:__tdg_original_getaddrinfo) if method_defined?(:__tdg_original_getaddrinfo)
+    end
+
+    state.network_active = false
+  end
+  private_class_method :restore_network_block!
+
+  def start_watchdog!(state, tamper_log:, interval:)
+    state.watchdog_thread = Thread.new do
+      Thread.current.abort_on_exception = false
+
+      until state.watchdog_stop
+        begin
+          verify_integrity!(state)
+        rescue TamperDetectedError => e
+          append_tamper_log(tamper_log, e.message)
+        end
+        sleep(interval)
+      end
+    end
+  end
+  private_class_method :start_watchdog!
+
+  def stop_watchdog!(state)
+    return unless state.watchdog_thread
+
+    state.watchdog_stop = true
+    state.watchdog_thread.join(1)
+    state.watchdog_thread = nil
+  end
+  private_class_method :stop_watchdog!
+
+  def verify_integrity!(state)
+    state.policy[:env_overrides].each do |k, v|
+      next if ENV[k] == v
+
+      ENV[k] = v
+      raise TamperDetectedError, "Env override tampered and restored: #{k}"
+    end
+
+    unless Socket.method(:getaddrinfo).owner == Socket.singleton_class
+      raise TamperDetectedError, 'Socket.getaddrinfo hook tampered'
+    end
+  end
+  private_class_method :verify_integrity!
+
+  def trap_signals!(state, tamper_log:)
+    %w[INT TERM].each do |sig|
+      Signal.trap(sig) do
+        append_tamper_log(tamper_log, "Received signal #{sig}; shutting down guard")
+        deactivate!(state)
+        exit(0)
+      end
+    end
+  rescue ArgumentError
+    # Signal unavailable on current platform/runtime.
+  end
+  private_class_method :trap_signals!
+
+  def append_tamper_log(path, message)
+    File.open(path, 'a') do |f|
+      f.puts("#{Time.now.utc.iso8601} #{message}")
+    end
+  rescue StandardError
+    nil
+  end
+  private_class_method :append_tamper_log
+
+  def blocked?(normalized_host, blocked_hosts)
+    blocked_hosts.any? do |blocked|
+      normalized_host == blocked || normalized_host.end_with?(".#{blocked}")
+    end
+  end
+  module_function :blocked?
+
+  def normalize_host(host)
+    return '' if host.nil?
+
+    host.to_s.strip.downcase.sub(/\.+\z/, '')
+  end
+  module_function :normalize_host
+
+  def stringify_hash(h)
+    h.each_with_object({}) { |(k, v), acc| acc[k.to_s] = v.to_s }
+  end
+  private_class_method :stringify_hash
+end
+
+TelemetryDefenseGuard.run_cli! if $PROGRAM_NAME == __FILE__
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a4d6c600e236af3dcaa45caf5cdb6036c843eaee
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,261 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+class InvalidTelemetryPolicyError(ValueError):
+    """Raised when policy configuration is malformed."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+
+    normalized = str(host).strip().lower().rstrip(".")
+    if "://" in normalized:
+        # Caller provided a URL; keep host-only behavior explicit and safe.
+        return ""
+
+    return normalized
+
+
+def _validate_env_overrides(env_overrides: Mapping[str, str]) -> None:
+    for key, value in env_overrides.items():
+        if not isinstance(key, str) or not key.strip():
+            raise InvalidTelemetryPolicyError("Environment override keys must be non-empty strings.")
+        if "=" in key:
+            raise InvalidTelemetryPolicyError(f"Invalid env key '{key}': must not contain '='.")
+        if not isinstance(value, str):
+            raise InvalidTelemetryPolicyError(f"Invalid env value for '{key}': expected string.")
+
+
+def normalize_policy(policy: TelemetryPolicy) -> TelemetryPolicy:
+    """Return a sanitized policy with normalized hosts and validated env overrides."""
+    _validate_env_overrides(policy.env_overrides)
+
+    normalized_hosts = {_normalize_host(host) for host in policy.blocked_hosts}
+    normalized_hosts = {host for host in normalized_hosts if host}
+
+    return TelemetryPolicy(env_overrides=dict(policy.env_overrides), blocked_hosts=normalized_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        normalized = normalize_policy(policy)
+        combined_env.update(normalized.env_overrides)
+        combined_hosts |= normalized.blocked_hosts
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in normalized.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    normalized = normalize_policy(policy)
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= normalized.blocked_hosts
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in normalized.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(normalized.blocked_hosts),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = normalize_policy(policy or TelemetryPolicy())
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = normalize_policy(TelemetryPolicy())
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/test_telemetry_cyber_guard.py b/test_telemetry_cyber_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3b126a6f64f73dbc2897f39a9356afb03afaa11
--- /dev/null
+++ b/test_telemetry_cyber_guard.py
@@ -0,0 +1,33 @@
+import unittest
+
+from telemetry_cyber_guard import build_policy, parse_csv_hosts, probe_hosts
+from telemetry_restrictions import deactivate_network_block
+
+
+class TelemetryCyberGuardTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_parse_csv_hosts(self):
+        hosts = parse_csv_hosts(" segment.io, api.mixpanel.com ,, localhost ")
+        self.assertEqual(hosts, ["segment.io", "api.mixpanel.com", "localhost"])
+
+    def test_build_policy_strict_adds_controls(self):
+        policy = build_policy(extra_hosts=["custom.example"], strict_mode=True)
+
+        self.assertIn("OTEL_SDK_DISABLED", policy.env_overrides)
+        self.assertIn("custom.example", policy.blocked_hosts)
+        self.assertIn("segment.io", policy.blocked_hosts)
+
+    def test_probe_hosts_blocks_and_allows(self):
+        policy = build_policy(extra_hosts=["blocked.example"], strict_mode=False)
+        results = probe_hosts(policy, ["blocked.example", "localhost"])
+
+        by_host = {row["host"]: row for row in results}
+        self.assertEqual(by_host["blocked.example"]["status"], "blocked")
+        self.assertIn(by_host["localhost"]["status"], {"allowed", "error"})
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_restrictions.py b/test_telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..89fc75f8b1ac01a7e6f28f4fef6ae911d85bdd2b
--- /dev/null
+++ b/test_telemetry_restrictions.py
@@ -0,0 +1,133 @@
+import socket
+import unittest
+
+from telemetry_restrictions import (
+    InvalidTelemetryPolicyError,
+    TelemetryBlockedError,
+    TelemetryPolicy,
+    activate_network_block,
+    apply_env_restrictions,
+    audit_policy_state,
+    deactivate_network_block,
+    merge_policies,
+    normalize_policy,
+    telemetry_restricted,
+)
+
+
+class TelemetryRestrictionTests(unittest.TestCase):
+    def tearDown(self):
+        # Ensure all nested activations are cleared.
+        deactivate_network_block()
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_apply_env_restrictions(self):
+        env = {"DO_NOT_TRACK": "0", "UNCHANGED": "yes"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "X": "abc"}, blocked_hosts=set())
+
+        previous = apply_env_restrictions(policy, environment=env)
+
+        self.assertEqual(previous, {"DO_NOT_TRACK": "0"})
+        self.assertEqual(env["DO_NOT_TRACK"], "1")
+        self.assertEqual(env["X"], "abc")
+        self.assertEqual(env["UNCHANGED"], "yes")
+
+    def test_policy_normalization_filters_invalid_hosts(self):
+        policy = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={" segment.io ", "", "https://bad"})
+        normalized = normalize_policy(policy)
+
+        self.assertEqual(normalized.blocked_hosts, {"segment.io"})
+
+    def test_policy_validation_rejects_invalid_env_key(self):
+        policy = TelemetryPolicy(env_overrides={"BAD=KEY": "1"}, blocked_hosts=set())
+
+        with self.assertRaises(InvalidTelemetryPolicyError):
+            normalize_policy(policy)
+
+    def test_network_block_blocks_exact_host(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+    def test_network_block_blocks_subdomain(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("api.segment.io", 443)
+
+    def test_network_block_allows_other_hosts(self):
+        policy = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        activate_network_block(policy)
+
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_nested_activation_refcount(self):
+        p1 = TelemetryPolicy(env_overrides={}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={}, blocked_hosts={"sentry.io"})
+
+        activate_network_block(p1)
+        activate_network_block(p2)
+
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("sentry.io", 443)
+
+        report = audit_policy_state(p1, environment={})
+        self.assertTrue(report["network_block_active"])
+        self.assertEqual(report["network_block_refcount"], 2)
+
+        deactivate_network_block()
+
+        # Still active because one activation remains.
+        with self.assertRaises(TelemetryBlockedError):
+            socket.getaddrinfo("segment.io", 443)
+
+        deactivate_network_block()
+
+        # Fully restored; localhost should resolve.
+        result = socket.getaddrinfo("localhost", 80)
+        self.assertTrue(len(result) > 0)
+
+    def test_merge_policies(self):
+        p1 = TelemetryPolicy(env_overrides={"A": "1"}, blocked_hosts={"segment.io"})
+        p2 = TelemetryPolicy(env_overrides={"B": "2", "A": "override"}, blocked_hosts={"sentry.io"})
+
+        merged = merge_policies(p1, p2)
+
+        self.assertEqual(merged.env_overrides["A"], "override")
+        self.assertEqual(merged.env_overrides["B"], "2")
+        self.assertEqual(merged.blocked_hosts, {"segment.io", "sentry.io"})
+
+    def test_context_manager_restores_env(self):
+        env = {"DO_NOT_TRACK": "0"}
+        policy = TelemetryPolicy(env_overrides={"DO_NOT_TRACK": "1", "TEMP_KEY": "value"}, blocked_hosts=set())
+
+        with telemetry_restricted(policy, environment=env, block_network=False):
+            self.assertEqual(env["DO_NOT_TRACK"], "1")
+            self.assertEqual(env["TEMP_KEY"], "value")
+
+        self.assertEqual(env["DO_NOT_TRACK"], "0")
+        self.assertNotIn("TEMP_KEY", env)
+
+    def test_audit_policy_state(self):
+        env = {"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"}
+        policy = TelemetryPolicy(
+            env_overrides={"DO_NOT_TRACK": "1", "WANDB_DISABLED": "true"},
+            blocked_hosts={"segment.io"},
+        )
+
+        report = audit_policy_state(policy, environment=env)
+
+        self.assertTrue(report["env"]["DO_NOT_TRACK"]["active"])
+        self.assertTrue(report["env"]["WANDB_DISABLED"]["active"])
+        self.assertEqual(report["blocked_hosts"], ["segment.io"])
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/test_telemetry_defense_guard.rb b/test_telemetry_defense_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..f6afd8183f66bd2fa3c0817c42fddfcdaf7fa595
--- /dev/null
+++ b/test_telemetry_defense_guard.rb
@@ -0,0 +1,46 @@
+# frozen_string_literal: true
+
+require 'minitest/autorun'
+require_relative 'telemetry_defense_guard'
+
+class TelemetryDefenseGuardTest < Minitest::Test
+  def teardown
+    # best-effort cleanup in case tests fail mid-way
+    ENV.delete('TDG_TEST_FLAG')
+  end
+
+  def test_build_policy_merges_defaults_and_extras
+    policy = TelemetryDefenseGuard.build_policy(
+      env_overrides: { TDG_TEST_FLAG: 'on' },
+      blocked_hosts: [' example.com ']
+    )
+
+    assert_equal 'on', policy[:env_overrides]['TDG_TEST_FLAG']
+    assert_includes policy[:blocked_hosts], 'example.com'
+    assert_includes policy[:blocked_hosts], 'segment.io'
+  end
+
+  def test_blocked_helper
+    assert TelemetryDefenseGuard.blocked?('api.segment.io', ['segment.io'])
+    refute TelemetryDefenseGuard.blocked?('localhost', ['segment.io'])
+  end
+
+  def test_activate_and_deactivate
+    policy = TelemetryDefenseGuard.build_policy(
+      env_overrides: { TDG_TEST_FLAG: 'enabled' },
+      blocked_hosts: ['blocked.example']
+    )
+
+    state = TelemetryDefenseGuard.activate!(policy: policy, watchdog_interval: 0.1)
+
+    assert_equal 'enabled', ENV['TDG_TEST_FLAG']
+    assert state.network_active
+
+    blocked = TelemetryDefenseGuard.probe_host('blocked.example')
+    assert_equal 'blocked', blocked[:status]
+
+    TelemetryDefenseGuard.deactivate!(state)
+    refute state.network_active
+    assert_nil ENV['TDG_TEST_FLAG']
+  end
+end
diff --git a/test_telemetry_data_hygiene.rb b/test_telemetry_data_hygiene.rb
new file mode 100644
index 0000000000000000000000000000000000000000..bc87307a22c5f50aaab31ff1c75acbd7f0eff53f
--- /dev/null
+++ b/test_telemetry_data_hygiene.rb
@@ -0,0 +1,56 @@
+# frozen_string_literal: true
+
+require 'json'
+require 'minitest/autorun'
+require 'tmpdir'
+require_relative 'telemetry_data_hygiene'
+
+class TelemetryDataHygieneTest < Minitest::Test
+  def test_marker_record_detection
+    record = { 'id' => '1', 'tags' => ['baseline', 'placeholder'] }
+    assert TelemetryDataHygiene.marker_record?(record)
+  end
+
+  def test_suspicious_capability_detection
+    record = { 'id' => '2', 'power_extraction' => true }
+    assert TelemetryDataHygiene.suspicious_capability_record?(record)
+  end
+
+  def test_redaction
+    record = { 'id' => '3', 'biometric_signature' => 'abc', 'ok' => 1 }
+    sanitized = TelemetryDataHygiene.redact_record(record)
+
+    assert_equal '[REDACTED]', sanitized['biometric_signature']
+    assert_equal 1, sanitized['ok']
+  end
+
+  def test_run_pipeline
+    Dir.mktmpdir do |dir|
+      input = File.join(dir, 'in.jsonl')
+      output = File.join(dir, 'out.jsonl')
+      report = File.join(dir, 'report.json')
+
+      rows = [
+        { 'id' => 'keep-1', 'type' => 'normal', 'biometric_signature' => 'secret' },
+        { 'id' => 'drop-1', 'tags' => ['placebo'] },
+        { 'id' => 'drop-2', 'power_extraction' => true }
+      ]
+
+      File.open(input, 'w') { |f| rows.each { |r| f.puts(JSON.generate(r)) } }
+
+      result = TelemetryDataHygiene.run!(input: input, output: output, report_path: report)
+
+      assert_equal 3, result[:input_records]
+      assert_equal 1, result[:output_records]
+      assert_equal 2, result[:dropped_records]
+
+      out_rows = File.readlines(output, chomp: true).map { |line| JSON.parse(line) }
+      assert_equal 1, out_rows.length
+      assert_equal 'keep-1', out_rows[0]['id']
+      assert_equal '[REDACTED]', out_rows[0]['biometric_signature']
+
+      report_obj = JSON.parse(File.read(report))
+      assert_equal 2, report_obj['dropped_records']
+    end
+  end
+end
diff --git a/test_telemetry_cyber_guard.py b/test_telemetry_cyber_guard.py
new file mode 100644
index 0000000000000000000000000000000000000000..c3b126a6f64f73dbc2897f39a9356afb03afaa11
--- /dev/null
+++ b/test_telemetry_cyber_guard.py
@@ -0,0 +1,33 @@
+import unittest
+
+from telemetry_cyber_guard import build_policy, parse_csv_hosts, probe_hosts
+from telemetry_restrictions import deactivate_network_block
+
+
+class TelemetryCyberGuardTests(unittest.TestCase):
+    def tearDown(self):
+        deactivate_network_block()
+        deactivate_network_block()
+
+    def test_parse_csv_hosts(self):
+        hosts = parse_csv_hosts(" segment.io, api.mixpanel.com ,, localhost ")
+        self.assertEqual(hosts, ["segment.io", "api.mixpanel.com", "localhost"])
+
+    def test_build_policy_strict_adds_controls(self):
+        policy = build_policy(extra_hosts=["custom.example"], strict_mode=True)
+
+        self.assertIn("OTEL_SDK_DISABLED", policy.env_overrides)
+        self.assertIn("custom.example", policy.blocked_hosts)
+        self.assertIn("segment.io", policy.blocked_hosts)
+
+    def test_probe_hosts_blocks_and_allows(self):
+        policy = build_policy(extra_hosts=["blocked.example"], strict_mode=False)
+        results = probe_hosts(policy, ["blocked.example", "localhost"])
+
+        by_host = {row["host"]: row for row in results}
+        self.assertEqual(by_host["blocked.example"]["status"], "blocked")
+        self.assertIn(by_host["localhost"]["status"], {"allowed", "error"})
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/telemetry_restrictions.py b/telemetry_restrictions.py
new file mode 100644
index 0000000000000000000000000000000000000000..a4d6c600e236af3dcaa45caf5cdb6036c843eaee
--- /dev/null
+++ b/telemetry_restrictions.py
@@ -0,0 +1,261 @@
+"""Telemetry restriction utilities.
+
+This module provides a defensive, opt-out-oriented approach to reduce telemetry
+emission from Python processes without destructive system behavior.
+
+Important scope note:
+- This is process-local and opt-in.
+- It does not rewrite or deactivate arbitrary applications.
+"""
+
+from __future__ import annotations
+
+from contextlib import contextmanager
+from dataclasses import dataclass, field
+import os
+import socket
+import threading
+from typing import Dict, Iterator, Mapping, MutableMapping, Optional, Set
+
+
+DEFAULT_TELEMETRY_ENV_OVERRIDES: Mapping[str, str] = {
+    # General
+    "DO_NOT_TRACK": "1",
+    # Python / tooling
+    "PYTHONWARNINGS": "ignore::UserWarning",
+    "PIP_DISABLE_PIP_VERSION_CHECK": "1",
+    "PIP_NO_PYTHON_VERSION_WARNING": "1",
+    "POETRY_NO_INTERACTION": "1",
+    # Node ecosystem (often present in mixed repos)
+    "NPM_CONFIG_FUND": "false",
+    "NPM_CONFIG_AUDIT": "false",
+    "YARN_ENABLE_TELEMETRY": "0",
+    "NEXT_TELEMETRY_DISABLED": "1",
+    "ASTRO_TELEMETRY_DISABLED": "1",
+    # Common SDK telemetry controls
+    "HF_HUB_DISABLE_TELEMETRY": "1",
+    "WANDB_DISABLED": "true",
+    "SENTRY_DSN": "",
+    "SEGMENT_WRITE_KEY": "",
+    "AMPLITUDE_API_KEY": "",
+    "POSTHOG_DISABLED": "1",
+}
+
+DEFAULT_TELEMETRY_BLOCKED_HOSTS: Set[str] = {
+    "segment.io",
+    "mixpanel.com",
+    "sentry.io",
+    "plausible.io",
+    "telemetry.pypi.org",
+    "amplitude.com",
+    "posthog.com",
+}
+
+
+@dataclass(frozen=True)
+class TelemetryPolicy:
+    """Defines environment-level and host-level telemetry restrictions."""
+
+    env_overrides: Mapping[str, str] = field(default_factory=lambda: dict(DEFAULT_TELEMETRY_ENV_OVERRIDES))
+    blocked_hosts: Set[str] = field(default_factory=lambda: set(DEFAULT_TELEMETRY_BLOCKED_HOSTS))
+
+
+_ORIGINAL_GETADDRINFO = socket.getaddrinfo
+_NETWORK_BLOCK_LOCK = threading.Lock()
+_NETWORK_BLOCK_REFCOUNT = 0
+_CURRENT_BLOCKED_HOSTS: Set[str] = set()
+
+
+class TelemetryBlockedError(ConnectionError):
+    """Raised when a blocked telemetry destination is requested."""
+
+
+class InvalidTelemetryPolicyError(ValueError):
+    """Raised when policy configuration is malformed."""
+
+
+def _normalize_host(host: object) -> str:
+    if host is None:
+        return ""
+
+    normalized = str(host).strip().lower().rstrip(".")
+    if "://" in normalized:
+        # Caller provided a URL; keep host-only behavior explicit and safe.
+        return ""
+
+    return normalized
+
+
+def _validate_env_overrides(env_overrides: Mapping[str, str]) -> None:
+    for key, value in env_overrides.items():
+        if not isinstance(key, str) or not key.strip():
+            raise InvalidTelemetryPolicyError("Environment override keys must be non-empty strings.")
+        if "=" in key:
+            raise InvalidTelemetryPolicyError(f"Invalid env key '{key}': must not contain '='.")
+        if not isinstance(value, str):
+            raise InvalidTelemetryPolicyError(f"Invalid env value for '{key}': expected string.")
+
+
+def normalize_policy(policy: TelemetryPolicy) -> TelemetryPolicy:
+    """Return a sanitized policy with normalized hosts and validated env overrides."""
+    _validate_env_overrides(policy.env_overrides)
+
+    normalized_hosts = {_normalize_host(host) for host in policy.blocked_hosts}
+    normalized_hosts = {host for host in normalized_hosts if host}
+
+    return TelemetryPolicy(env_overrides=dict(policy.env_overrides), blocked_hosts=normalized_hosts)
+
+
+def _is_host_blocked(host: object, blocked_hosts: Set[str]) -> bool:
+    normalized = _normalize_host(host)
+    if not normalized:
+        return False
+
+    # Exact host or subdomain match.
+    for blocked in blocked_hosts:
+        if normalized == blocked or normalized.endswith(f".{blocked}"):
+            return True
+    return False
+
+
+def merge_policies(*policies: TelemetryPolicy) -> TelemetryPolicy:
+    """Merge multiple policies into a single combined policy."""
+    combined_env: Dict[str, str] = {}
+    combined_hosts: Set[str] = set()
+
+    for policy in policies:
+        normalized = normalize_policy(policy)
+        combined_env.update(normalized.env_overrides)
+        combined_hosts |= normalized.blocked_hosts
+
+    return TelemetryPolicy(env_overrides=combined_env, blocked_hosts=combined_hosts)
+
+
+def apply_env_restrictions(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+) -> Dict[str, str]:
+    """Apply environment variable overrides and return previous values."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+    previous: Dict[str, str] = {}
+
+    for key, value in normalized.env_overrides.items():
+        if key in env:
+            previous[key] = env[key]
+        env[key] = value
+
+    return previous
+
+
+def activate_network_block(policy: TelemetryPolicy) -> None:
+    """Monkey patch socket name resolution to deny selected telemetry hosts."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    normalized = normalize_policy(policy)
+
+    with _NETWORK_BLOCK_LOCK:
+        _CURRENT_BLOCKED_HOSTS |= normalized.blocked_hosts
+
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+
+            def _guarded_getaddrinfo(host, *args, **kwargs):
+                if _is_host_blocked(host, _CURRENT_BLOCKED_HOSTS):
+                    raise TelemetryBlockedError(f"Blocked telemetry destination: {host}")
+                return _ORIGINAL_GETADDRINFO(host, *args, **kwargs)
+
+            socket.getaddrinfo = _guarded_getaddrinfo
+
+        _NETWORK_BLOCK_REFCOUNT += 1
+
+
+def deactivate_network_block() -> None:
+    """Restore original socket name resolution when last activation exits."""
+    global _NETWORK_BLOCK_REFCOUNT
+    global _CURRENT_BLOCKED_HOSTS
+
+    with _NETWORK_BLOCK_LOCK:
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            return
+
+        _NETWORK_BLOCK_REFCOUNT -= 1
+        if _NETWORK_BLOCK_REFCOUNT == 0:
+            socket.getaddrinfo = _ORIGINAL_GETADDRINFO
+            _CURRENT_BLOCKED_HOSTS = set()
+
+
+def audit_policy_state(
+    policy: TelemetryPolicy,
+    *,
+    environment: Optional[Mapping[str, str]] = None,
+) -> Dict[str, object]:
+    """Return a report showing active restrictions."""
+    normalized = normalize_policy(policy)
+    env = os.environ if environment is None else environment
+
+    env_status = {
+        key: {
+            "expected": expected,
+            "actual": env.get(key),
+            "active": env.get(key) == expected,
+        }
+        for key, expected in normalized.env_overrides.items()
+    }
+
+    with _NETWORK_BLOCK_LOCK:
+        active_hosts = sorted(_CURRENT_BLOCKED_HOSTS)
+        is_active = _NETWORK_BLOCK_REFCOUNT > 0
+        refcount = _NETWORK_BLOCK_REFCOUNT
+
+    return {
+        "env": env_status,
+        "network_block_active": is_active,
+        "network_block_refcount": refcount,
+        "blocked_hosts": sorted(normalized.blocked_hosts),
+        "active_blocked_hosts": active_hosts,
+    }
+
+
+@contextmanager
+def telemetry_restricted(
+    policy: Optional[TelemetryPolicy] = None,
+    *,
+    environment: Optional[MutableMapping[str, str]] = None,
+    block_network: bool = True,
+) -> Iterator[TelemetryPolicy]:
+    """Context manager that applies telemetry restrictions for a code region."""
+    active_policy = normalize_policy(policy or TelemetryPolicy())
+    previous = apply_env_restrictions(active_policy, environment=environment)
+
+    if block_network:
+        activate_network_block(active_policy)
+
+    try:
+        yield active_policy
+    finally:
+        env = os.environ if environment is None else environment
+
+        for key in active_policy.env_overrides:
+            if key in previous:
+                env[key] = previous[key]
+            else:
+                env.pop(key, None)
+
+        if block_network:
+            deactivate_network_block()
+
+
+if __name__ == "__main__":
+    policy = normalize_policy(TelemetryPolicy())
+    apply_env_restrictions(policy)
+    activate_network_block(policy)
+
+    report = audit_policy_state(policy)
+    enabled_count = sum(1 for details in report["env"].values() if details["active"])
+
+    print("Telemetry restrictions enabled (process-local, opt-in).")
+    print(f"Environment overrides active: {enabled_count}/{len(policy.env_overrides)}")
+    print(f"Network block active: {report['network_block_active']} (refcount={report['network_block_refcount']})")
+    print(f"Blocked telemetry hosts: {', '.join(report['active_blocked_hosts'])}")
diff --git a/telemetry_defense_guard.rb b/telemetry_defense_guard.rb
new file mode 100644
index 0000000000000000000000000000000000000000..b996a62f1c373d1391eab02ae4466f6ecee7dd10
--- /dev/null
+++ b/telemetry_defense_guard.rb
@@ -0,0 +1,280 @@
+#!/usr/bin/env ruby
+# frozen_string_literal: true
+
+# Defensive, process-local telemetry hardening for Ruby runtimes.
+#
+# What this does:
+# - Enforces telemetry opt-out environment variables.
+# - Blocks DNS resolution to configured telemetry hosts/subdomains.
+# - Runs tamper watchdog checks for env + network hook integrity.
+# - Emits tamper events to an append-only local log.
+#
+# What this does NOT do:
+# - It cannot guarantee global/system-wide prevention by itself.
+# - It only protects the current process unless integrated by launcher/service.
+
+require 'digest'
+require 'json'
+require 'socket'
+require 'thread'
+require 'time'
+
+module TelemetryDefenseGuard
+  class TelemetryBlockedError < StandardError; end
+
+  class TamperDetectedError < StandardError; end
+
+  DEFAULT_ENV_OVERRIDES = {
+    'DO_NOT_TRACK' => '1',
+    'OTEL_SDK_DISABLED' => 'true',
+    'CHECKPOINT_DISABLE_TELEMETRY' => '1',
+    'SENTRY_DSN' => '',
+    'SEGMENT_WRITE_KEY' => '',
+    'AMPLITUDE_API_KEY' => '',
+    'POSTHOG_DISABLED' => '1'
+  }.freeze
+
+  DEFAULT_BLOCKED_HOSTS = %w[
+    segment.io
+    mixpanel.com
+    sentry.io
+    plausible.io
+    amplitude.com
+    posthog.com
+    telemetry.pypi.org
+  ].freeze
+
+  State = Struct.new(
+    :env_before,
+    :policy,
+    :original_socket_method,
+    :network_active,
+    :watchdog_thread,
+    :watchdog_stop,
+    :lock,
+    keyword_init: true
+  )
+
+  module_function
+
+  def build_policy(env_overrides: {}, blocked_hosts: [])
+    merged_env = DEFAULT_ENV_OVERRIDES.merge(stringify_hash(env_overrides))
+    merged_hosts = (DEFAULT_BLOCKED_HOSTS + blocked_hosts.map { |h| normalize_host(h) }).reject(&:empty?).uniq
+
+    {
+      env_overrides: merged_env.freeze,
+      blocked_hosts: merged_hosts.freeze,
+      integrity_hash: Digest::SHA256.hexdigest(JSON.generate({ env: merged_env, hosts: merged_hosts }))
+    }.freeze
+  end
+
+  def activate!(policy: build_policy, tamper_log: 'telemetry_tamper.log', watchdog_interval: 0.5)
+    state = State.new(
+      env_before: {},
+      policy: policy,
+      original_socket_method: Socket.method(:getaddrinfo),
+      network_active: false,
+      watchdog_stop: false,
+      lock: Mutex.new
+    )
+
+    enforce_env!(state)
+    install_network_block!(state)
+    start_watchdog!(state, tamper_log: tamper_log, interval: watchdog_interval)
+    trap_signals!(state, tamper_log: tamper_log)
+
+    state
+  end
+
+  def deactivate!(state)
+    state.lock.synchronize do
+      restore_env!(state)
+      restore_network_block!(state)
+      stop_watchdog!(state)
+    end
+  end
+
+  def audit(state)
+    env_status = {}
+    state.policy[:env_overrides].each do |k, expected|
+      actual = ENV[k]
+      env_status[k] = { expected: expected, actual: actual, active: (actual == expected) }
+    end
+
+    {
+      env: env_status,
+      blocked_hosts: state.policy[:blocked_hosts],
+      network_block_active: state.network_active,
+      policy_integrity_hash: state.policy[:integrity_hash]
+    }
+  end
+
+  def probe_host(host)
+    Socket.getaddrinfo(host, 443)
+    { host: host, status: 'allowed' }
+  rescue TelemetryBlockedError => e
+    { host: host, status: 'blocked', detail: e.message }
+  rescue StandardError => e
+    { host: host, status: 'error', detail: e.message }
+  end
+
+  def run_cli!
+    strict_hosts = (ENV['TDG_EXTRA_BLOCKED_HOSTS'] || '').split(',').map(&:strip).reject(&:empty?)
+    policy = build_policy(blocked_hosts: strict_hosts)
+    state = activate!(policy: policy)
+
+    at_exit { deactivate!(state) }
+
+    output = {
+      summary: {
+        blocked_hosts: policy[:blocked_hosts].length,
+        env_overrides: policy[:env_overrides].length,
+        network_block_active: state.network_active
+      },
+      audit: audit(state)
+    }
+
+    probe = (ENV['TDG_PROBE_HOSTS'] || '').split(',').map(&:strip).reject(&:empty?)
+    output[:probe_results] = probe.map { |h| probe_host(h) } unless probe.empty?
+
+    puts JSON.pretty_generate(output)
+  end
+
+  def enforce_env!(state)
+    state.policy[:env_overrides].each do |key, value|
+      state.env_before[key] = ENV[key] if ENV.key?(key)
+      ENV[key] = value
+    end
+  end
+  private_class_method :enforce_env!
+
+  def restore_env!(state)
+    state.policy[:env_overrides].each_key do |key|
+      if state.env_before.key?(key)
+        ENV[key] = state.env_before[key]
+      else
+        ENV.delete(key)
+      end
+    end
+  end
+  private_class_method :restore_env!
+
+  def install_network_block!(state)
+    return if state.network_active
+
+    blocked = state.policy[:blocked_hosts]
+
+    Socket.singleton_class.class_eval do
+      define_method(:getaddrinfo) do |host, *args|
+        normalized = TelemetryDefenseGuard.normalize_host(host)
+        if TelemetryDefenseGuard.blocked?(normalized, blocked)
+          raise TelemetryDefenseGuard::TelemetryBlockedError, "Blocked telemetry destination: #{host}"
+        end
+
+        Socket.method(:__tdg_original_getaddrinfo).call(host, *args)
+      end
+    end
+
+    Socket.singleton_class.class_eval do
+      define_method(:__tdg_original_getaddrinfo, &state.original_socket_method)
+    end
+
+    state.network_active = true
+  end
+  private_class_method :install_network_block!
+
+  def restore_network_block!(state)
+    return unless state.network_active
+
+    original = state.original_socket_method
+    Socket.singleton_class.class_eval do
+      define_method(:getaddrinfo, &original)
+      remove_method(:__tdg_original_getaddrinfo) if method_defined?(:__tdg_original_getaddrinfo)
+    end
+
+    state.network_active = false
+  end
+  private_class_method :restore_network_block!
+
+  def start_watchdog!(state, tamper_log:, interval:)
+    state.watchdog_thread = Thread.new do
+      Thread.current.abort_on_exception = false
+
+      until state.watchdog_stop
+        begin
+          verify_integrity!(state)
+        rescue TamperDetectedError => e
+          append_tamper_log(tamper_log, e.message)
+        end
+        sleep(interval)
+      end
+    end
+  end
+  private_class_method :start_watchdog!
+
+  def stop_watchdog!(state)
+    return unless state.watchdog_thread
+
+    state.watchdog_stop = true
+    state.watchdog_thread.join(1)
+    state.watchdog_thread = nil
+  end
+  private_class_method :stop_watchdog!
+
+  def verify_integrity!(state)
+    state.policy[:env_overrides].each do |k, v|
+      next if ENV[k] == v
+
+      ENV[k] = v
+      raise TamperDetectedError, "Env override tampered and restored: #{k}"
+    end
+
+    unless Socket.method(:getaddrinfo).owner == Socket.singleton_class
+      raise TamperDetectedError, 'Socket.getaddrinfo hook tampered'
+    end
+  end
+  private_class_method :verify_integrity!
+
+  def trap_signals!(state, tamper_log:)
+    %w[INT TERM].each do |sig|
+      Signal.trap(sig) do
+        append_tamper_log(tamper_log, "Received signal #{sig}; shutting down guard")
+        deactivate!(state)
+        exit(0)
+      end
+    end
+  rescue ArgumentError
+    # Signal unavailable on current platform/runtime.
+  end
+  private_class_method :trap_signals!
+
+  def append_tamper_log(path, message)
+    File.open(path, 'a') do |f|
+      f.puts("#{Time.now.utc.iso8601} #{message}")
+    end
+  rescue StandardError
+    nil
+  end
+  private_class_method :append_tamper_log
+
+  def blocked?(normalized_host, blocked_hosts)
+    blocked_hosts.any? do |blocked|
+      normalized_host == blocked || normalized_host.end_with?(".#{blocked}")
+    end
+  end
+  module_function :blocked?
+
+  def normalize_host(host)
+    return '' if host.nil?
+
+    host.to_s.strip.downcase.sub(/\.+\z/, '')
+  end
+  module_function :normalize_host
+
+  def stringify_hash(h)
+    h.each_with_object({}) { |(k, v), acc| acc[k.to_s] = v.to_s }
+  end
+  private_class_method :stringify_hash
+end
+
+TelemetryDefenseGuard.run_cli! if $PROGRAM_NAME == __FILE__
